
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions

export type PrismaPromise<T> = $Public.PrismaPromise<T>


export type RolePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Role"
  objects: {
    users: UserPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
  }, ExtArgs["result"]["role"]>
  composites: {}
}

/**
 * Model Role
 * 
 */
export type Role = runtime.Types.DefaultSelection<RolePayload>
export type UserPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "User"
  objects: {
    activitylog: ActivityLogPayload<ExtArgs>[]
    admin: AdminPayload<ExtArgs> | null
    alert: AlertPayload<ExtArgs>[]
    distributor: DistributorPayload<ExtArgs> | null
    doctor: DoctorPayload<ExtArgs> | null
    manufacturer: ManufacturerPayload<ExtArgs> | null
    otp: OtpPayload<ExtArgs>[]
    patient: PatientPayload<ExtArgs> | null
    pharmacist: PharmacistPayload<ExtArgs> | null
    regulator: RegulatorPayload<ExtArgs> | null
    reports: ReportPayload<ExtArgs>[]
    revocationrecord: RevocationRecordPayload<ExtArgs>[]
    supplychainrecord_supplychainrecord_fromentityidTousers: SupplyChainRecordPayload<ExtArgs>[]
    supplychainrecord_supplychainrecord_toentityidTousers: SupplyChainRecordPayload<ExtArgs>[]
    roles: RolePayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    wallet: string
    email: string | null
    passwordhash: string | null
    roleid: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }, ExtArgs["result"]["user"]>
  composites: {}
}

/**
 * Model User
 * 
 */
export type User = runtime.Types.DefaultSelection<UserPayload>
export type PermissionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Permission"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    name: string
  }, ExtArgs["result"]["permission"]>
  composites: {}
}

/**
 * Model Permission
 * 
 */
export type Permission = runtime.Types.DefaultSelection<PermissionPayload>
export type DoctorPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Doctor"
  objects: {
    users: UserPayload<ExtArgs> | null
    prescription: PrescriptionPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    userid: number | null
    licenseno: string
    hospital: string
  }, ExtArgs["result"]["doctor"]>
  composites: {}
}

/**
 * Model Doctor
 * 
 */
export type Doctor = runtime.Types.DefaultSelection<DoctorPayload>
export type PatientPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Patient"
  objects: {
    users: UserPayload<ExtArgs> | null
    prescription: PrescriptionPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    userid: number | null
    dateofbirth: Date
  }, ExtArgs["result"]["patient"]>
  composites: {}
}

/**
 * Model Patient
 * 
 */
export type Patient = runtime.Types.DefaultSelection<PatientPayload>
export type PharmacistPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Pharmacist"
  objects: {
    dispenserecord: DispenseRecordPayload<ExtArgs>[]
    users: UserPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    userid: number | null
    licenseno: string
    pharmacy: string
  }, ExtArgs["result"]["pharmacist"]>
  composites: {}
}

/**
 * Model Pharmacist
 * 
 */
export type Pharmacist = runtime.Types.DefaultSelection<PharmacistPayload>
export type ManufacturerPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Manufacturer"
  objects: {
    drugbatch: DrugBatchPayload<ExtArgs>[]
    users: UserPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    userid: number | null
    companyname: string
  }, ExtArgs["result"]["manufacturer"]>
  composites: {}
}

/**
 * Model Manufacturer
 * 
 */
export type Manufacturer = runtime.Types.DefaultSelection<ManufacturerPayload>
export type DistributorPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Distributor"
  objects: {
    users: UserPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    userid: number | null
    companyname: string
  }, ExtArgs["result"]["distributor"]>
  composites: {}
}

/**
 * Model Distributor
 * 
 */
export type Distributor = runtime.Types.DefaultSelection<DistributorPayload>
export type RegulatorPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Regulator"
  objects: {
    users: UserPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    userid: number | null
    agencyname: string
  }, ExtArgs["result"]["regulator"]>
  composites: {}
}

/**
 * Model Regulator
 * 
 */
export type Regulator = runtime.Types.DefaultSelection<RegulatorPayload>
export type AdminPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Admin"
  objects: {
    users: UserPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    userid: number | null
  }, ExtArgs["result"]["admin"]>
  composites: {}
}

/**
 * Model Admin
 * 
 */
export type Admin = runtime.Types.DefaultSelection<AdminPayload>
export type DrugPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Drug"
  objects: {
    drugbatch: DrugBatchPayload<ExtArgs>[]
    prescription: PrescriptionPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    code: string
    formulation: string
    dosageunit: string
  }, ExtArgs["result"]["drug"]>
  composites: {}
}

/**
 * Model Drug
 * 
 */
export type Drug = runtime.Types.DefaultSelection<DrugPayload>
export type PrescriptionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Prescription"
  objects: {
    blockchaineventlog: BlockchainEventLogPayload<ExtArgs>[]
    dispenserecord: DispenseRecordPayload<ExtArgs>[]
    doctor: DoctorPayload<ExtArgs> | null
    drug: DrugPayload<ExtArgs> | null
    patient: PatientPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    patientid: number | null
    doctorid: number | null
    drugid: number | null
    dosage: string
    issuedat: Date | null
    expiresat: Date
    blockchaintx: string | null
    qrcode: string
    ipfshash: string | null
    status: string
  }, ExtArgs["result"]["prescription"]>
  composites: {}
}

/**
 * Model Prescription
 * 
 */
export type Prescription = runtime.Types.DefaultSelection<PrescriptionPayload>
export type DrugBatchPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "DrugBatch"
  objects: {
    blockchaineventlog: BlockchainEventLogPayload<ExtArgs>[]
    dispenserecord: DispenseRecordPayload<ExtArgs>[]
    drug: DrugPayload<ExtArgs> | null
    manufacturer: ManufacturerPayload<ExtArgs> | null
    supplychainrecord: SupplyChainRecordPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    manufacturerid: number | null
    drugid: number | null
    batchnumber: string
    manufacturedate: Date
    expirydate: Date
    blockchaintx: string | null
    qrcode: string
    ipfshash: string | null
  }, ExtArgs["result"]["drugBatch"]>
  composites: {}
}

/**
 * Model DrugBatch
 * 
 */
export type DrugBatch = runtime.Types.DefaultSelection<DrugBatchPayload>
export type SupplyChainRecordPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "SupplyChainRecord"
  objects: {
    blockchaineventlog: BlockchainEventLogPayload<ExtArgs>[]
    drugbatch: DrugBatchPayload<ExtArgs> | null
    users_supplychainrecord_fromentityidTousers: UserPayload<ExtArgs> | null
    users_supplychainrecord_toentityidTousers: UserPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    drugbatchid: number | null
    fromentityid: number | null
    toentityid: number | null
    action: string
    timestamp: Date | null
    blockchaintx: string | null
  }, ExtArgs["result"]["supplyChainRecord"]>
  composites: {}
}

/**
 * Model SupplyChainRecord
 * 
 */
export type SupplyChainRecord = runtime.Types.DefaultSelection<SupplyChainRecordPayload>
export type RevocationRecordPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "RevocationRecord"
  objects: {
    users: UserPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    type: string
    refid: number
    reason: string
    revokedbyid: number | null
    timestamp: Date | null
    blockchaintx: string | null
  }, ExtArgs["result"]["revocationRecord"]>
  composites: {}
}

/**
 * Model RevocationRecord
 * 
 */
export type RevocationRecord = runtime.Types.DefaultSelection<RevocationRecordPayload>
export type OtpPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Otp"
  objects: {
    users: UserPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    userid: number | null
    code: string
    expiresat: Date
    createdat: Date | null
  }, ExtArgs["result"]["otp"]>
  composites: {}
}

/**
 * Model Otp
 * 
 */
export type Otp = runtime.Types.DefaultSelection<OtpPayload>
export type AlertPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Alert"
  objects: {
    users: UserPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    userid: number | null
    title: string
    message: string
    isread: boolean | null
    priority: string
    createdat: Date | null
  }, ExtArgs["result"]["alert"]>
  composites: {}
}

/**
 * Model Alert
 * 
 */
export type Alert = runtime.Types.DefaultSelection<AlertPayload>
export type ActivityLogPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ActivityLog"
  objects: {
    users: UserPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    userid: number | null
    action: string
    details: string | null
    timestamp: Date | null
  }, ExtArgs["result"]["activityLog"]>
  composites: {}
}

/**
 * Model ActivityLog
 * 
 */
export type ActivityLog = runtime.Types.DefaultSelection<ActivityLogPayload>
export type ReportPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Report"
  objects: {
    users: UserPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    userid: number | null
    reporttype: string
    filters: Prisma.JsonValue | null
    generatedat: Date | null
    ipfshash: string | null
  }, ExtArgs["result"]["report"]>
  composites: {}
}

/**
 * Model Report
 * 
 */
export type Report = runtime.Types.DefaultSelection<ReportPayload>
export type DispenseRecordPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "DispenseRecord"
  objects: {
    drugbatch: DrugBatchPayload<ExtArgs> | null
    pharmacist: PharmacistPayload<ExtArgs> | null
    prescription: PrescriptionPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    prescriptionid: number | null
    pharmacistid: number | null
    drugbatchid: number | null
    quantity: number
    dispensedat: Date | null
    blockchaintx: string | null
  }, ExtArgs["result"]["dispenseRecord"]>
  composites: {}
}

/**
 * Model DispenseRecord
 * 
 */
export type DispenseRecord = runtime.Types.DefaultSelection<DispenseRecordPayload>
export type BlockchainEventLogPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "BlockchainEventLog"
  objects: {
    drugbatch: DrugBatchPayload<ExtArgs> | null
    prescription: PrescriptionPayload<ExtArgs> | null
    supplychainrecord: SupplyChainRecordPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    eventname: string
    contractname: string
    entityid: number | null
    entitytype: string | null
    transactionhash: string
    timestamp: Date | null
    processed: boolean | null
  }, ExtArgs["result"]["blockchainEventLog"]>
  composites: {}
}

/**
 * Model BlockchainEventLog
 * 
 */
export type BlockchainEventLog = runtime.Types.DefaultSelection<BlockchainEventLogPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Roles
 * const roles = await prisma.role.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Roles
   * const roles = await prisma.role.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.doctor`: Exposes CRUD operations for the **Doctor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Doctors
    * const doctors = await prisma.doctor.findMany()
    * ```
    */
  get doctor(): Prisma.DoctorDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.patient`: Exposes CRUD operations for the **Patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.PatientDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.pharmacist`: Exposes CRUD operations for the **Pharmacist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pharmacists
    * const pharmacists = await prisma.pharmacist.findMany()
    * ```
    */
  get pharmacist(): Prisma.PharmacistDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.manufacturer`: Exposes CRUD operations for the **Manufacturer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Manufacturers
    * const manufacturers = await prisma.manufacturer.findMany()
    * ```
    */
  get manufacturer(): Prisma.ManufacturerDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.distributor`: Exposes CRUD operations for the **Distributor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Distributors
    * const distributors = await prisma.distributor.findMany()
    * ```
    */
  get distributor(): Prisma.DistributorDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.regulator`: Exposes CRUD operations for the **Regulator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Regulators
    * const regulators = await prisma.regulator.findMany()
    * ```
    */
  get regulator(): Prisma.RegulatorDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.drug`: Exposes CRUD operations for the **Drug** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drugs
    * const drugs = await prisma.drug.findMany()
    * ```
    */
  get drug(): Prisma.DrugDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.prescription`: Exposes CRUD operations for the **Prescription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prescriptions
    * const prescriptions = await prisma.prescription.findMany()
    * ```
    */
  get prescription(): Prisma.PrescriptionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.drugBatch`: Exposes CRUD operations for the **DrugBatch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DrugBatches
    * const drugBatches = await prisma.drugBatch.findMany()
    * ```
    */
  get drugBatch(): Prisma.DrugBatchDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.supplyChainRecord`: Exposes CRUD operations for the **SupplyChainRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupplyChainRecords
    * const supplyChainRecords = await prisma.supplyChainRecord.findMany()
    * ```
    */
  get supplyChainRecord(): Prisma.SupplyChainRecordDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.revocationRecord`: Exposes CRUD operations for the **RevocationRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RevocationRecords
    * const revocationRecords = await prisma.revocationRecord.findMany()
    * ```
    */
  get revocationRecord(): Prisma.RevocationRecordDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.otp`: Exposes CRUD operations for the **Otp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Otps
    * const otps = await prisma.otp.findMany()
    * ```
    */
  get otp(): Prisma.OtpDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.alert`: Exposes CRUD operations for the **Alert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alerts
    * const alerts = await prisma.alert.findMany()
    * ```
    */
  get alert(): Prisma.AlertDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.activityLog`: Exposes CRUD operations for the **ActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityLogs
    * const activityLogs = await prisma.activityLog.findMany()
    * ```
    */
  get activityLog(): Prisma.ActivityLogDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.dispenseRecord`: Exposes CRUD operations for the **DispenseRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DispenseRecords
    * const dispenseRecords = await prisma.dispenseRecord.findMany()
    * ```
    */
  get dispenseRecord(): Prisma.DispenseRecordDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.blockchainEventLog`: Exposes CRUD operations for the **BlockchainEventLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlockchainEventLogs
    * const blockchainEventLogs = await prisma.blockchainEventLog.findMany()
    * ```
    */
  get blockchainEventLog(): Prisma.BlockchainEventLogDelegate<GlobalReject, ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export type Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export type Args<T, F extends $Public.Operation> = $Public.Args<T, F>
  export type Payload<T, F extends $Public.Operation> = $Public.Payload<T, F>
  export type Result<T, A, F extends $Public.Operation> = $Public.Result<T, A, F>
  export type Exact<T, W> = $Public.Exact<T, W>

  /**
   * Prisma Client JS version: 4.16.2
   * Query Engine version: 4bc8b6e1b66cb932731fb1bdbbc550d1e010de81
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Role: 'Role',
    User: 'User',
    Permission: 'Permission',
    Doctor: 'Doctor',
    Patient: 'Patient',
    Pharmacist: 'Pharmacist',
    Manufacturer: 'Manufacturer',
    Distributor: 'Distributor',
    Regulator: 'Regulator',
    Admin: 'Admin',
    Drug: 'Drug',
    Prescription: 'Prescription',
    DrugBatch: 'DrugBatch',
    SupplyChainRecord: 'SupplyChainRecord',
    RevocationRecord: 'RevocationRecord',
    Otp: 'Otp',
    Alert: 'Alert',
    ActivityLog: 'ActivityLog',
    Report: 'Report',
    DispenseRecord: 'DispenseRecord',
    BlockchainEventLog: 'BlockchainEventLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'role' | 'user' | 'permission' | 'doctor' | 'patient' | 'pharmacist' | 'manufacturer' | 'distributor' | 'regulator' | 'admin' | 'drug' | 'prescription' | 'drugBatch' | 'supplyChainRecord' | 'revocationRecord' | 'otp' | 'alert' | 'activityLog' | 'report' | 'dispenseRecord' | 'blockchainEventLog'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Role: {
        payload: RolePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>,
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: UserPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: PermissionPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>,
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      Doctor: {
        payload: DoctorPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.DoctorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DoctorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DoctorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DoctorPayload>
          }
          findFirst: {
            args: Prisma.DoctorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DoctorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DoctorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DoctorPayload>
          }
          findMany: {
            args: Prisma.DoctorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DoctorPayload>[]
          }
          create: {
            args: Prisma.DoctorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DoctorPayload>
          }
          createMany: {
            args: Prisma.DoctorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DoctorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DoctorPayload>
          }
          update: {
            args: Prisma.DoctorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DoctorPayload>
          }
          deleteMany: {
            args: Prisma.DoctorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DoctorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DoctorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DoctorPayload>
          }
          aggregate: {
            args: Prisma.DoctorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDoctor>
          }
          groupBy: {
            args: Prisma.DoctorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DoctorGroupByOutputType>[]
          }
          count: {
            args: Prisma.DoctorCountArgs<ExtArgs>,
            result: $Utils.Optional<DoctorCountAggregateOutputType> | number
          }
        }
      }
      Patient: {
        payload: PatientPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.PatientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PatientPayload>
          }
          findFirst: {
            args: Prisma.PatientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PatientPayload>
          }
          findMany: {
            args: Prisma.PatientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PatientPayload>[]
          }
          create: {
            args: Prisma.PatientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PatientPayload>
          }
          createMany: {
            args: Prisma.PatientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PatientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PatientPayload>
          }
          update: {
            args: Prisma.PatientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PatientPayload>
          }
          deleteMany: {
            args: Prisma.PatientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PatientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PatientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PatientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.PatientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientCountArgs<ExtArgs>,
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
      Pharmacist: {
        payload: PharmacistPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.PharmacistFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PharmacistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PharmacistFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PharmacistPayload>
          }
          findFirst: {
            args: Prisma.PharmacistFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PharmacistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PharmacistFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PharmacistPayload>
          }
          findMany: {
            args: Prisma.PharmacistFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PharmacistPayload>[]
          }
          create: {
            args: Prisma.PharmacistCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PharmacistPayload>
          }
          createMany: {
            args: Prisma.PharmacistCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PharmacistDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PharmacistPayload>
          }
          update: {
            args: Prisma.PharmacistUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PharmacistPayload>
          }
          deleteMany: {
            args: Prisma.PharmacistDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PharmacistUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PharmacistUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PharmacistPayload>
          }
          aggregate: {
            args: Prisma.PharmacistAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePharmacist>
          }
          groupBy: {
            args: Prisma.PharmacistGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PharmacistGroupByOutputType>[]
          }
          count: {
            args: Prisma.PharmacistCountArgs<ExtArgs>,
            result: $Utils.Optional<PharmacistCountAggregateOutputType> | number
          }
        }
      }
      Manufacturer: {
        payload: ManufacturerPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ManufacturerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ManufacturerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ManufacturerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ManufacturerPayload>
          }
          findFirst: {
            args: Prisma.ManufacturerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ManufacturerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ManufacturerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ManufacturerPayload>
          }
          findMany: {
            args: Prisma.ManufacturerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ManufacturerPayload>[]
          }
          create: {
            args: Prisma.ManufacturerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ManufacturerPayload>
          }
          createMany: {
            args: Prisma.ManufacturerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ManufacturerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ManufacturerPayload>
          }
          update: {
            args: Prisma.ManufacturerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ManufacturerPayload>
          }
          deleteMany: {
            args: Prisma.ManufacturerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ManufacturerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ManufacturerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ManufacturerPayload>
          }
          aggregate: {
            args: Prisma.ManufacturerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateManufacturer>
          }
          groupBy: {
            args: Prisma.ManufacturerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ManufacturerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ManufacturerCountArgs<ExtArgs>,
            result: $Utils.Optional<ManufacturerCountAggregateOutputType> | number
          }
        }
      }
      Distributor: {
        payload: DistributorPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.DistributorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DistributorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DistributorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DistributorPayload>
          }
          findFirst: {
            args: Prisma.DistributorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DistributorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DistributorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DistributorPayload>
          }
          findMany: {
            args: Prisma.DistributorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DistributorPayload>[]
          }
          create: {
            args: Prisma.DistributorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DistributorPayload>
          }
          createMany: {
            args: Prisma.DistributorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DistributorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DistributorPayload>
          }
          update: {
            args: Prisma.DistributorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DistributorPayload>
          }
          deleteMany: {
            args: Prisma.DistributorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DistributorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DistributorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DistributorPayload>
          }
          aggregate: {
            args: Prisma.DistributorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDistributor>
          }
          groupBy: {
            args: Prisma.DistributorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DistributorGroupByOutputType>[]
          }
          count: {
            args: Prisma.DistributorCountArgs<ExtArgs>,
            result: $Utils.Optional<DistributorCountAggregateOutputType> | number
          }
        }
      }
      Regulator: {
        payload: RegulatorPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.RegulatorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RegulatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegulatorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RegulatorPayload>
          }
          findFirst: {
            args: Prisma.RegulatorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RegulatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegulatorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RegulatorPayload>
          }
          findMany: {
            args: Prisma.RegulatorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RegulatorPayload>[]
          }
          create: {
            args: Prisma.RegulatorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RegulatorPayload>
          }
          createMany: {
            args: Prisma.RegulatorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RegulatorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RegulatorPayload>
          }
          update: {
            args: Prisma.RegulatorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RegulatorPayload>
          }
          deleteMany: {
            args: Prisma.RegulatorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RegulatorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RegulatorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RegulatorPayload>
          }
          aggregate: {
            args: Prisma.RegulatorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRegulator>
          }
          groupBy: {
            args: Prisma.RegulatorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RegulatorGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegulatorCountArgs<ExtArgs>,
            result: $Utils.Optional<RegulatorCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: AdminPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>,
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      Drug: {
        payload: DrugPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.DrugFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DrugPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DrugFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DrugPayload>
          }
          findFirst: {
            args: Prisma.DrugFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DrugPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DrugFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DrugPayload>
          }
          findMany: {
            args: Prisma.DrugFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DrugPayload>[]
          }
          create: {
            args: Prisma.DrugCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DrugPayload>
          }
          createMany: {
            args: Prisma.DrugCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DrugDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DrugPayload>
          }
          update: {
            args: Prisma.DrugUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DrugPayload>
          }
          deleteMany: {
            args: Prisma.DrugDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DrugUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DrugUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DrugPayload>
          }
          aggregate: {
            args: Prisma.DrugAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDrug>
          }
          groupBy: {
            args: Prisma.DrugGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DrugGroupByOutputType>[]
          }
          count: {
            args: Prisma.DrugCountArgs<ExtArgs>,
            result: $Utils.Optional<DrugCountAggregateOutputType> | number
          }
        }
      }
      Prescription: {
        payload: PrescriptionPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.PrescriptionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PrescriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrescriptionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PrescriptionPayload>
          }
          findFirst: {
            args: Prisma.PrescriptionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PrescriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrescriptionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PrescriptionPayload>
          }
          findMany: {
            args: Prisma.PrescriptionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PrescriptionPayload>[]
          }
          create: {
            args: Prisma.PrescriptionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PrescriptionPayload>
          }
          createMany: {
            args: Prisma.PrescriptionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PrescriptionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PrescriptionPayload>
          }
          update: {
            args: Prisma.PrescriptionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PrescriptionPayload>
          }
          deleteMany: {
            args: Prisma.PrescriptionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PrescriptionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PrescriptionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PrescriptionPayload>
          }
          aggregate: {
            args: Prisma.PrescriptionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePrescription>
          }
          groupBy: {
            args: Prisma.PrescriptionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PrescriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrescriptionCountArgs<ExtArgs>,
            result: $Utils.Optional<PrescriptionCountAggregateOutputType> | number
          }
        }
      }
      DrugBatch: {
        payload: DrugBatchPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.DrugBatchFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DrugBatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DrugBatchFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DrugBatchPayload>
          }
          findFirst: {
            args: Prisma.DrugBatchFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DrugBatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DrugBatchFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DrugBatchPayload>
          }
          findMany: {
            args: Prisma.DrugBatchFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DrugBatchPayload>[]
          }
          create: {
            args: Prisma.DrugBatchCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DrugBatchPayload>
          }
          createMany: {
            args: Prisma.DrugBatchCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DrugBatchDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DrugBatchPayload>
          }
          update: {
            args: Prisma.DrugBatchUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DrugBatchPayload>
          }
          deleteMany: {
            args: Prisma.DrugBatchDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DrugBatchUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DrugBatchUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DrugBatchPayload>
          }
          aggregate: {
            args: Prisma.DrugBatchAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDrugBatch>
          }
          groupBy: {
            args: Prisma.DrugBatchGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DrugBatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.DrugBatchCountArgs<ExtArgs>,
            result: $Utils.Optional<DrugBatchCountAggregateOutputType> | number
          }
        }
      }
      SupplyChainRecord: {
        payload: SupplyChainRecordPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.SupplyChainRecordFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SupplyChainRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplyChainRecordFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SupplyChainRecordPayload>
          }
          findFirst: {
            args: Prisma.SupplyChainRecordFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SupplyChainRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplyChainRecordFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SupplyChainRecordPayload>
          }
          findMany: {
            args: Prisma.SupplyChainRecordFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SupplyChainRecordPayload>[]
          }
          create: {
            args: Prisma.SupplyChainRecordCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SupplyChainRecordPayload>
          }
          createMany: {
            args: Prisma.SupplyChainRecordCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SupplyChainRecordDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SupplyChainRecordPayload>
          }
          update: {
            args: Prisma.SupplyChainRecordUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SupplyChainRecordPayload>
          }
          deleteMany: {
            args: Prisma.SupplyChainRecordDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SupplyChainRecordUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SupplyChainRecordUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SupplyChainRecordPayload>
          }
          aggregate: {
            args: Prisma.SupplyChainRecordAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSupplyChainRecord>
          }
          groupBy: {
            args: Prisma.SupplyChainRecordGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SupplyChainRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplyChainRecordCountArgs<ExtArgs>,
            result: $Utils.Optional<SupplyChainRecordCountAggregateOutputType> | number
          }
        }
      }
      RevocationRecord: {
        payload: RevocationRecordPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.RevocationRecordFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RevocationRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RevocationRecordFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RevocationRecordPayload>
          }
          findFirst: {
            args: Prisma.RevocationRecordFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RevocationRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RevocationRecordFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RevocationRecordPayload>
          }
          findMany: {
            args: Prisma.RevocationRecordFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RevocationRecordPayload>[]
          }
          create: {
            args: Prisma.RevocationRecordCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RevocationRecordPayload>
          }
          createMany: {
            args: Prisma.RevocationRecordCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RevocationRecordDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RevocationRecordPayload>
          }
          update: {
            args: Prisma.RevocationRecordUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RevocationRecordPayload>
          }
          deleteMany: {
            args: Prisma.RevocationRecordDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RevocationRecordUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RevocationRecordUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RevocationRecordPayload>
          }
          aggregate: {
            args: Prisma.RevocationRecordAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRevocationRecord>
          }
          groupBy: {
            args: Prisma.RevocationRecordGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RevocationRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.RevocationRecordCountArgs<ExtArgs>,
            result: $Utils.Optional<RevocationRecordCountAggregateOutputType> | number
          }
        }
      }
      Otp: {
        payload: OtpPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.OtpFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OtpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OtpFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OtpPayload>
          }
          findFirst: {
            args: Prisma.OtpFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OtpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OtpFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OtpPayload>
          }
          findMany: {
            args: Prisma.OtpFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OtpPayload>[]
          }
          create: {
            args: Prisma.OtpCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OtpPayload>
          }
          createMany: {
            args: Prisma.OtpCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OtpDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OtpPayload>
          }
          update: {
            args: Prisma.OtpUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OtpPayload>
          }
          deleteMany: {
            args: Prisma.OtpDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OtpUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OtpUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OtpPayload>
          }
          aggregate: {
            args: Prisma.OtpAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOtp>
          }
          groupBy: {
            args: Prisma.OtpGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OtpGroupByOutputType>[]
          }
          count: {
            args: Prisma.OtpCountArgs<ExtArgs>,
            result: $Utils.Optional<OtpCountAggregateOutputType> | number
          }
        }
      }
      Alert: {
        payload: AlertPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.AlertFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlertFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AlertPayload>
          }
          findFirst: {
            args: Prisma.AlertFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlertFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AlertPayload>
          }
          findMany: {
            args: Prisma.AlertFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AlertPayload>[]
          }
          create: {
            args: Prisma.AlertCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AlertPayload>
          }
          createMany: {
            args: Prisma.AlertCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AlertDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AlertPayload>
          }
          update: {
            args: Prisma.AlertUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AlertPayload>
          }
          deleteMany: {
            args: Prisma.AlertDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AlertUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AlertUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AlertPayload>
          }
          aggregate: {
            args: Prisma.AlertAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAlert>
          }
          groupBy: {
            args: Prisma.AlertGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlertCountArgs<ExtArgs>,
            result: $Utils.Optional<AlertCountAggregateOutputType> | number
          }
        }
      }
      ActivityLog: {
        payload: ActivityLogPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ActivityLogFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityLogFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ActivityLogPayload>
          }
          findFirst: {
            args: Prisma.ActivityLogFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityLogFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ActivityLogPayload>
          }
          findMany: {
            args: Prisma.ActivityLogFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ActivityLogPayload>[]
          }
          create: {
            args: Prisma.ActivityLogCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ActivityLogPayload>
          }
          createMany: {
            args: Prisma.ActivityLogCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ActivityLogDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ActivityLogPayload>
          }
          update: {
            args: Prisma.ActivityLogUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.ActivityLogDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityLogUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ActivityLogUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ActivityLogPayload>
          }
          aggregate: {
            args: Prisma.ActivityLogAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateActivityLog>
          }
          groupBy: {
            args: Prisma.ActivityLogGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityLogCountArgs<ExtArgs>,
            result: $Utils.Optional<ActivityLogCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: ReportPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>,
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      DispenseRecord: {
        payload: DispenseRecordPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.DispenseRecordFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DispenseRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DispenseRecordFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DispenseRecordPayload>
          }
          findFirst: {
            args: Prisma.DispenseRecordFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DispenseRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DispenseRecordFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DispenseRecordPayload>
          }
          findMany: {
            args: Prisma.DispenseRecordFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DispenseRecordPayload>[]
          }
          create: {
            args: Prisma.DispenseRecordCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DispenseRecordPayload>
          }
          createMany: {
            args: Prisma.DispenseRecordCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DispenseRecordDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DispenseRecordPayload>
          }
          update: {
            args: Prisma.DispenseRecordUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DispenseRecordPayload>
          }
          deleteMany: {
            args: Prisma.DispenseRecordDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DispenseRecordUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DispenseRecordUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DispenseRecordPayload>
          }
          aggregate: {
            args: Prisma.DispenseRecordAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDispenseRecord>
          }
          groupBy: {
            args: Prisma.DispenseRecordGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DispenseRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.DispenseRecordCountArgs<ExtArgs>,
            result: $Utils.Optional<DispenseRecordCountAggregateOutputType> | number
          }
        }
      }
      BlockchainEventLog: {
        payload: BlockchainEventLogPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.BlockchainEventLogFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BlockchainEventLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockchainEventLogFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BlockchainEventLogPayload>
          }
          findFirst: {
            args: Prisma.BlockchainEventLogFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BlockchainEventLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockchainEventLogFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BlockchainEventLogPayload>
          }
          findMany: {
            args: Prisma.BlockchainEventLogFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BlockchainEventLogPayload>[]
          }
          create: {
            args: Prisma.BlockchainEventLogCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BlockchainEventLogPayload>
          }
          createMany: {
            args: Prisma.BlockchainEventLogCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BlockchainEventLogDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BlockchainEventLogPayload>
          }
          update: {
            args: Prisma.BlockchainEventLogUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BlockchainEventLogPayload>
          }
          deleteMany: {
            args: Prisma.BlockchainEventLogDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BlockchainEventLogUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BlockchainEventLogUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BlockchainEventLogPayload>
          }
          aggregate: {
            args: Prisma.BlockchainEventLogAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBlockchainEventLog>
          }
          groupBy: {
            args: Prisma.BlockchainEventLogGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BlockchainEventLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockchainEventLogCountArgs<ExtArgs>,
            result: $Utils.Optional<BlockchainEventLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type RoleCountOutputType
   */


  export type RoleCountOutputType = {
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    activitylog: number
    alert: number
    otp: number
    reports: number
    revocationrecord: number
    supplychainrecord_supplychainrecord_fromentityidTousers: number
    supplychainrecord_supplychainrecord_toentityidTousers: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    activitylog?: boolean | UserCountOutputTypeCountActivitylogArgs
    alert?: boolean | UserCountOutputTypeCountAlertArgs
    otp?: boolean | UserCountOutputTypeCountOtpArgs
    reports?: boolean | UserCountOutputTypeCountReportsArgs
    revocationrecord?: boolean | UserCountOutputTypeCountRevocationrecordArgs
    supplychainrecord_supplychainrecord_fromentityidTousers?: boolean | UserCountOutputTypeCountSupplychainrecord_supplychainrecord_fromentityidTousersArgs
    supplychainrecord_supplychainrecord_toentityidTousers?: boolean | UserCountOutputTypeCountSupplychainrecord_supplychainrecord_toentityidTousersArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivitylogArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAlertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOtpArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OtpWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRevocationrecordArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: RevocationRecordWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSupplychainrecord_supplychainrecord_fromentityidTousersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SupplyChainRecordWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSupplychainrecord_supplychainrecord_toentityidTousersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SupplyChainRecordWhereInput
  }



  /**
   * Count Type DoctorCountOutputType
   */


  export type DoctorCountOutputType = {
    prescription: number
  }

  export type DoctorCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    prescription?: boolean | DoctorCountOutputTypeCountPrescriptionArgs
  }

  // Custom InputTypes

  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorCountOutputType
     */
    select?: DoctorCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeCountPrescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
  }



  /**
   * Count Type PatientCountOutputType
   */


  export type PatientCountOutputType = {
    prescription: number
  }

  export type PatientCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    prescription?: boolean | PatientCountOutputTypeCountPrescriptionArgs
  }

  // Custom InputTypes

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientCountOutputType
     */
    select?: PatientCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountPrescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
  }



  /**
   * Count Type PharmacistCountOutputType
   */


  export type PharmacistCountOutputType = {
    dispenserecord: number
  }

  export type PharmacistCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    dispenserecord?: boolean | PharmacistCountOutputTypeCountDispenserecordArgs
  }

  // Custom InputTypes

  /**
   * PharmacistCountOutputType without action
   */
  export type PharmacistCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacistCountOutputType
     */
    select?: PharmacistCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PharmacistCountOutputType without action
   */
  export type PharmacistCountOutputTypeCountDispenserecordArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DispenseRecordWhereInput
  }



  /**
   * Count Type ManufacturerCountOutputType
   */


  export type ManufacturerCountOutputType = {
    drugbatch: number
  }

  export type ManufacturerCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    drugbatch?: boolean | ManufacturerCountOutputTypeCountDrugbatchArgs
  }

  // Custom InputTypes

  /**
   * ManufacturerCountOutputType without action
   */
  export type ManufacturerCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManufacturerCountOutputType
     */
    select?: ManufacturerCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ManufacturerCountOutputType without action
   */
  export type ManufacturerCountOutputTypeCountDrugbatchArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DrugBatchWhereInput
  }



  /**
   * Count Type DrugCountOutputType
   */


  export type DrugCountOutputType = {
    drugbatch: number
    prescription: number
  }

  export type DrugCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    drugbatch?: boolean | DrugCountOutputTypeCountDrugbatchArgs
    prescription?: boolean | DrugCountOutputTypeCountPrescriptionArgs
  }

  // Custom InputTypes

  /**
   * DrugCountOutputType without action
   */
  export type DrugCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugCountOutputType
     */
    select?: DrugCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DrugCountOutputType without action
   */
  export type DrugCountOutputTypeCountDrugbatchArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DrugBatchWhereInput
  }


  /**
   * DrugCountOutputType without action
   */
  export type DrugCountOutputTypeCountPrescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
  }



  /**
   * Count Type PrescriptionCountOutputType
   */


  export type PrescriptionCountOutputType = {
    blockchaineventlog: number
    dispenserecord: number
  }

  export type PrescriptionCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    blockchaineventlog?: boolean | PrescriptionCountOutputTypeCountBlockchaineventlogArgs
    dispenserecord?: boolean | PrescriptionCountOutputTypeCountDispenserecordArgs
  }

  // Custom InputTypes

  /**
   * PrescriptionCountOutputType without action
   */
  export type PrescriptionCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionCountOutputType
     */
    select?: PrescriptionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PrescriptionCountOutputType without action
   */
  export type PrescriptionCountOutputTypeCountBlockchaineventlogArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BlockchainEventLogWhereInput
  }


  /**
   * PrescriptionCountOutputType without action
   */
  export type PrescriptionCountOutputTypeCountDispenserecordArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DispenseRecordWhereInput
  }



  /**
   * Count Type DrugBatchCountOutputType
   */


  export type DrugBatchCountOutputType = {
    blockchaineventlog: number
    dispenserecord: number
    supplychainrecord: number
  }

  export type DrugBatchCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    blockchaineventlog?: boolean | DrugBatchCountOutputTypeCountBlockchaineventlogArgs
    dispenserecord?: boolean | DrugBatchCountOutputTypeCountDispenserecordArgs
    supplychainrecord?: boolean | DrugBatchCountOutputTypeCountSupplychainrecordArgs
  }

  // Custom InputTypes

  /**
   * DrugBatchCountOutputType without action
   */
  export type DrugBatchCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugBatchCountOutputType
     */
    select?: DrugBatchCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DrugBatchCountOutputType without action
   */
  export type DrugBatchCountOutputTypeCountBlockchaineventlogArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BlockchainEventLogWhereInput
  }


  /**
   * DrugBatchCountOutputType without action
   */
  export type DrugBatchCountOutputTypeCountDispenserecordArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DispenseRecordWhereInput
  }


  /**
   * DrugBatchCountOutputType without action
   */
  export type DrugBatchCountOutputTypeCountSupplychainrecordArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SupplyChainRecordWhereInput
  }



  /**
   * Count Type SupplyChainRecordCountOutputType
   */


  export type SupplyChainRecordCountOutputType = {
    blockchaineventlog: number
  }

  export type SupplyChainRecordCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    blockchaineventlog?: boolean | SupplyChainRecordCountOutputTypeCountBlockchaineventlogArgs
  }

  // Custom InputTypes

  /**
   * SupplyChainRecordCountOutputType without action
   */
  export type SupplyChainRecordCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplyChainRecordCountOutputType
     */
    select?: SupplyChainRecordCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SupplyChainRecordCountOutputType without action
   */
  export type SupplyChainRecordCountOutputTypeCountBlockchaineventlogArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BlockchainEventLogWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Role
   */


  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: Enumerable<RoleOrderByWithAggregationInput>
    by: RoleScalarFieldEnum[]
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }


  export type RoleGroupByOutputType = {
    id: number
    name: string
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type RoleInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeArgs<ExtArgs>
  }


  type RoleGetPayload<S extends boolean | null | undefined | RoleArgs> = $Types.GetResult<RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<RoleFindManyArgs, 'select' | 'include'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoleFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Role'> extends True ? Prisma__RoleClient<$Types.GetResult<RolePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__RoleClient<$Types.GetResult<RolePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Role that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RoleClient<$Types.GetResult<RolePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoleFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Role'> extends True ? Prisma__RoleClient<$Types.GetResult<RolePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__RoleClient<$Types.GetResult<RolePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Role that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RoleClient<$Types.GetResult<RolePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<RolePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
    **/
    create<T extends RoleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RoleCreateArgs<ExtArgs>>
    ): Prisma__RoleClient<$Types.GetResult<RolePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Roles.
     *     @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     *     @example
     *     // Create many Roles
     *     const role = await prisma.role.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
    **/
    delete<T extends RoleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>
    ): Prisma__RoleClient<$Types.GetResult<RolePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>
    ): Prisma__RoleClient<$Types.GetResult<RolePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
    **/
    upsert<T extends RoleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>
    ): Prisma__RoleClient<$Types.GetResult<RolePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UserPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Role base type for findUnique actions
   */
  export type RoleFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUnique
   */
  export interface RoleFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends RoleFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }


  /**
   * Role base type for findFirst actions
   */
  export type RoleFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: Enumerable<RoleScalarFieldEnum>
  }

  /**
   * Role findFirst
   */
  export interface RoleFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends RoleFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }


  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: Enumerable<RoleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }


  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }


  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }


  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }


  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }


  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * Role without action
   */
  export type RoleArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude<ExtArgs> | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    roleid: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    roleid: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    wallet: string | null
    email: string | null
    passwordhash: string | null
    roleid: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    wallet: string | null
    email: string | null
    passwordhash: string | null
    roleid: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    wallet: number
    email: number
    passwordhash: number
    roleid: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    roleid?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    roleid?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    wallet?: true
    email?: true
    passwordhash?: true
    roleid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    wallet?: true
    email?: true
    passwordhash?: true
    roleid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    wallet?: true
    email?: true
    passwordhash?: true
    roleid?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    wallet: string
    email: string | null
    passwordhash: string | null
    roleid: number | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wallet?: boolean
    email?: boolean
    passwordhash?: boolean
    roleid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    activitylog?: boolean | User$activitylogArgs<ExtArgs>
    admin?: boolean | AdminArgs<ExtArgs>
    alert?: boolean | User$alertArgs<ExtArgs>
    distributor?: boolean | DistributorArgs<ExtArgs>
    doctor?: boolean | DoctorArgs<ExtArgs>
    manufacturer?: boolean | ManufacturerArgs<ExtArgs>
    otp?: boolean | User$otpArgs<ExtArgs>
    patient?: boolean | PatientArgs<ExtArgs>
    pharmacist?: boolean | PharmacistArgs<ExtArgs>
    regulator?: boolean | RegulatorArgs<ExtArgs>
    reports?: boolean | User$reportsArgs<ExtArgs>
    revocationrecord?: boolean | User$revocationrecordArgs<ExtArgs>
    supplychainrecord_supplychainrecord_fromentityidTousers?: boolean | User$supplychainrecord_supplychainrecord_fromentityidTousersArgs<ExtArgs>
    supplychainrecord_supplychainrecord_toentityidTousers?: boolean | User$supplychainrecord_supplychainrecord_toentityidTousersArgs<ExtArgs>
    roles?: boolean | RoleArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    wallet?: boolean
    email?: boolean
    passwordhash?: boolean
    roleid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    activitylog?: boolean | User$activitylogArgs<ExtArgs>
    admin?: boolean | AdminArgs<ExtArgs>
    alert?: boolean | User$alertArgs<ExtArgs>
    distributor?: boolean | DistributorArgs<ExtArgs>
    doctor?: boolean | DoctorArgs<ExtArgs>
    manufacturer?: boolean | ManufacturerArgs<ExtArgs>
    otp?: boolean | User$otpArgs<ExtArgs>
    patient?: boolean | PatientArgs<ExtArgs>
    pharmacist?: boolean | PharmacistArgs<ExtArgs>
    regulator?: boolean | RegulatorArgs<ExtArgs>
    reports?: boolean | User$reportsArgs<ExtArgs>
    revocationrecord?: boolean | User$revocationrecordArgs<ExtArgs>
    supplychainrecord_supplychainrecord_fromentityidTousers?: boolean | User$supplychainrecord_supplychainrecord_fromentityidTousersArgs<ExtArgs>
    supplychainrecord_supplychainrecord_toentityidTousers?: boolean | User$supplychainrecord_supplychainrecord_toentityidTousersArgs<ExtArgs>
    roles?: boolean | RoleArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }


  type UserGetPayload<S extends boolean | null | undefined | UserArgs> = $Types.GetResult<UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UserPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    activitylog<T extends User$activitylogArgs<ExtArgs> = {}>(args?: Subset<T, User$activitylogArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ActivityLogPayload<ExtArgs>, T, 'findMany', never>| Null>;

    admin<T extends AdminArgs<ExtArgs> = {}>(args?: Subset<T, AdminArgs<ExtArgs>>): Prisma__AdminClient<$Types.GetResult<AdminPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    alert<T extends User$alertArgs<ExtArgs> = {}>(args?: Subset<T, User$alertArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AlertPayload<ExtArgs>, T, 'findMany', never>| Null>;

    distributor<T extends DistributorArgs<ExtArgs> = {}>(args?: Subset<T, DistributorArgs<ExtArgs>>): Prisma__DistributorClient<$Types.GetResult<DistributorPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    doctor<T extends DoctorArgs<ExtArgs> = {}>(args?: Subset<T, DoctorArgs<ExtArgs>>): Prisma__DoctorClient<$Types.GetResult<DoctorPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    manufacturer<T extends ManufacturerArgs<ExtArgs> = {}>(args?: Subset<T, ManufacturerArgs<ExtArgs>>): Prisma__ManufacturerClient<$Types.GetResult<ManufacturerPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    otp<T extends User$otpArgs<ExtArgs> = {}>(args?: Subset<T, User$otpArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<OtpPayload<ExtArgs>, T, 'findMany', never>| Null>;

    patient<T extends PatientArgs<ExtArgs> = {}>(args?: Subset<T, PatientArgs<ExtArgs>>): Prisma__PatientClient<$Types.GetResult<PatientPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    pharmacist<T extends PharmacistArgs<ExtArgs> = {}>(args?: Subset<T, PharmacistArgs<ExtArgs>>): Prisma__PharmacistClient<$Types.GetResult<PharmacistPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    regulator<T extends RegulatorArgs<ExtArgs> = {}>(args?: Subset<T, RegulatorArgs<ExtArgs>>): Prisma__RegulatorClient<$Types.GetResult<RegulatorPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    reports<T extends User$reportsArgs<ExtArgs> = {}>(args?: Subset<T, User$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ReportPayload<ExtArgs>, T, 'findMany', never>| Null>;

    revocationrecord<T extends User$revocationrecordArgs<ExtArgs> = {}>(args?: Subset<T, User$revocationrecordArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<RevocationRecordPayload<ExtArgs>, T, 'findMany', never>| Null>;

    supplychainrecord_supplychainrecord_fromentityidTousers<T extends User$supplychainrecord_supplychainrecord_fromentityidTousersArgs<ExtArgs> = {}>(args?: Subset<T, User$supplychainrecord_supplychainrecord_fromentityidTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<SupplyChainRecordPayload<ExtArgs>, T, 'findMany', never>| Null>;

    supplychainrecord_supplychainrecord_toentityidTousers<T extends User$supplychainrecord_supplychainrecord_toentityidTousersArgs<ExtArgs> = {}>(args?: Subset<T, User$supplychainrecord_supplychainrecord_toentityidTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<SupplyChainRecordPayload<ExtArgs>, T, 'findMany', never>| Null>;

    roles<T extends RoleArgs<ExtArgs> = {}>(args?: Subset<T, RoleArgs<ExtArgs>>): Prisma__RoleClient<$Types.GetResult<RolePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.activitylog
   */
  export type User$activitylogArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: Enumerable<ActivityLogOrderByWithRelationInput>
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ActivityLogScalarFieldEnum>
  }


  /**
   * User.alert
   */
  export type User$alertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude<ExtArgs> | null
    where?: AlertWhereInput
    orderBy?: Enumerable<AlertOrderByWithRelationInput>
    cursor?: AlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AlertScalarFieldEnum>
  }


  /**
   * User.otp
   */
  export type User$otpArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OtpInclude<ExtArgs> | null
    where?: OtpWhereInput
    orderBy?: Enumerable<OtpOrderByWithRelationInput>
    cursor?: OtpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OtpScalarFieldEnum>
  }


  /**
   * User.reports
   */
  export type User$reportsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: Enumerable<ReportOrderByWithRelationInput>
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * User.revocationrecord
   */
  export type User$revocationrecordArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevocationRecord
     */
    select?: RevocationRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RevocationRecordInclude<ExtArgs> | null
    where?: RevocationRecordWhereInput
    orderBy?: Enumerable<RevocationRecordOrderByWithRelationInput>
    cursor?: RevocationRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RevocationRecordScalarFieldEnum>
  }


  /**
   * User.supplychainrecord_supplychainrecord_fromentityidTousers
   */
  export type User$supplychainrecord_supplychainrecord_fromentityidTousersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplyChainRecord
     */
    select?: SupplyChainRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplyChainRecordInclude<ExtArgs> | null
    where?: SupplyChainRecordWhereInput
    orderBy?: Enumerable<SupplyChainRecordOrderByWithRelationInput>
    cursor?: SupplyChainRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SupplyChainRecordScalarFieldEnum>
  }


  /**
   * User.supplychainrecord_supplychainrecord_toentityidTousers
   */
  export type User$supplychainrecord_supplychainrecord_toentityidTousersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplyChainRecord
     */
    select?: SupplyChainRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplyChainRecordInclude<ExtArgs> | null
    where?: SupplyChainRecordWhereInput
    orderBy?: Enumerable<SupplyChainRecordOrderByWithRelationInput>
    cursor?: SupplyChainRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SupplyChainRecordScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Permission
   */


  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionAvgAggregateOutputType = {
    id: number | null
  }

  export type PermissionSumAggregateOutputType = {
    id: number | null
  }

  export type PermissionMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type PermissionAvgAggregateInputType = {
    id?: true
  }

  export type PermissionSumAggregateInputType = {
    id?: true
  }

  export type PermissionMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: Enumerable<PermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: Enumerable<PermissionOrderByWithAggregationInput>
    by: PermissionScalarFieldEnum[]
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _avg?: PermissionAvgAggregateInputType
    _sum?: PermissionSumAggregateInputType
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }


  export type PermissionGroupByOutputType = {
    id: number
    name: string
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    id?: boolean
    name?: boolean
  }


  type PermissionGetPayload<S extends boolean | null | undefined | PermissionArgs> = $Types.GetResult<PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PermissionFindManyArgs, 'select' | 'include'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PermissionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Permission'> extends True ? Prisma__PermissionClient<$Types.GetResult<PermissionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__PermissionClient<$Types.GetResult<PermissionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Permission that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PermissionClient<$Types.GetResult<PermissionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PermissionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Permission'> extends True ? Prisma__PermissionClient<$Types.GetResult<PermissionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__PermissionClient<$Types.GetResult<PermissionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Permission that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PermissionClient<$Types.GetResult<PermissionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PermissionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PermissionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
    **/
    create<T extends PermissionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>
    ): Prisma__PermissionClient<$Types.GetResult<PermissionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Permissions.
     *     @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     *     @example
     *     // Create many Permissions
     *     const permission = await prisma.permission.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PermissionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
    **/
    delete<T extends PermissionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>
    ): Prisma__PermissionClient<$Types.GetResult<PermissionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PermissionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>
    ): Prisma__PermissionClient<$Types.GetResult<PermissionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PermissionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PermissionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
    **/
    upsert<T extends PermissionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>
    ): Prisma__PermissionClient<$Types.GetResult<PermissionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Permission base type for findUnique actions
   */
  export type PermissionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUnique
   */
  export interface PermissionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PermissionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }


  /**
   * Permission base type for findFirst actions
   */
  export type PermissionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: Enumerable<PermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: Enumerable<PermissionScalarFieldEnum>
  }

  /**
   * Permission findFirst
   */
  export interface PermissionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PermissionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: Enumerable<PermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: Enumerable<PermissionScalarFieldEnum>
  }


  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: Enumerable<PermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: Enumerable<PermissionScalarFieldEnum>
  }


  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }


  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: Enumerable<PermissionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }


  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
  }


  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }


  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }


  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
  }


  /**
   * Permission without action
   */
  export type PermissionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
  }



  /**
   * Model Doctor
   */


  export type AggregateDoctor = {
    _count: DoctorCountAggregateOutputType | null
    _avg: DoctorAvgAggregateOutputType | null
    _sum: DoctorSumAggregateOutputType | null
    _min: DoctorMinAggregateOutputType | null
    _max: DoctorMaxAggregateOutputType | null
  }

  export type DoctorAvgAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type DoctorSumAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type DoctorMinAggregateOutputType = {
    id: number | null
    userid: number | null
    licenseno: string | null
    hospital: string | null
  }

  export type DoctorMaxAggregateOutputType = {
    id: number | null
    userid: number | null
    licenseno: string | null
    hospital: string | null
  }

  export type DoctorCountAggregateOutputType = {
    id: number
    userid: number
    licenseno: number
    hospital: number
    _all: number
  }


  export type DoctorAvgAggregateInputType = {
    id?: true
    userid?: true
  }

  export type DoctorSumAggregateInputType = {
    id?: true
    userid?: true
  }

  export type DoctorMinAggregateInputType = {
    id?: true
    userid?: true
    licenseno?: true
    hospital?: true
  }

  export type DoctorMaxAggregateInputType = {
    id?: true
    userid?: true
    licenseno?: true
    hospital?: true
  }

  export type DoctorCountAggregateInputType = {
    id?: true
    userid?: true
    licenseno?: true
    hospital?: true
    _all?: true
  }

  export type DoctorAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Doctor to aggregate.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: Enumerable<DoctorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Doctors
    **/
    _count?: true | DoctorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DoctorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DoctorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DoctorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DoctorMaxAggregateInputType
  }

  export type GetDoctorAggregateType<T extends DoctorAggregateArgs> = {
        [P in keyof T & keyof AggregateDoctor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoctor[P]>
      : GetScalarType<T[P], AggregateDoctor[P]>
  }




  export type DoctorGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DoctorWhereInput
    orderBy?: Enumerable<DoctorOrderByWithAggregationInput>
    by: DoctorScalarFieldEnum[]
    having?: DoctorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DoctorCountAggregateInputType | true
    _avg?: DoctorAvgAggregateInputType
    _sum?: DoctorSumAggregateInputType
    _min?: DoctorMinAggregateInputType
    _max?: DoctorMaxAggregateInputType
  }


  export type DoctorGroupByOutputType = {
    id: number
    userid: number | null
    licenseno: string
    hospital: string
    _count: DoctorCountAggregateOutputType | null
    _avg: DoctorAvgAggregateOutputType | null
    _sum: DoctorSumAggregateOutputType | null
    _min: DoctorMinAggregateOutputType | null
    _max: DoctorMaxAggregateOutputType | null
  }

  type GetDoctorGroupByPayload<T extends DoctorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DoctorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DoctorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DoctorGroupByOutputType[P]>
            : GetScalarType<T[P], DoctorGroupByOutputType[P]>
        }
      >
    >


  export type DoctorSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    licenseno?: boolean
    hospital?: boolean
    users?: boolean | UserArgs<ExtArgs>
    prescription?: boolean | Doctor$prescriptionArgs<ExtArgs>
    _count?: boolean | DoctorCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["doctor"]>

  export type DoctorSelectScalar = {
    id?: boolean
    userid?: boolean
    licenseno?: boolean
    hospital?: boolean
  }

  export type DoctorInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    users?: boolean | UserArgs<ExtArgs>
    prescription?: boolean | Doctor$prescriptionArgs<ExtArgs>
    _count?: boolean | DoctorCountOutputTypeArgs<ExtArgs>
  }


  type DoctorGetPayload<S extends boolean | null | undefined | DoctorArgs> = $Types.GetResult<DoctorPayload, S>

  type DoctorCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DoctorFindManyArgs, 'select' | 'include'> & {
      select?: DoctorCountAggregateInputType | true
    }

  export interface DoctorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Doctor'], meta: { name: 'Doctor' } }
    /**
     * Find zero or one Doctor that matches the filter.
     * @param {DoctorFindUniqueArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DoctorFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DoctorFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Doctor'> extends True ? Prisma__DoctorClient<$Types.GetResult<DoctorPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__DoctorClient<$Types.GetResult<DoctorPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Doctor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DoctorFindUniqueOrThrowArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DoctorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DoctorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DoctorClient<$Types.GetResult<DoctorPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Doctor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorFindFirstArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DoctorFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DoctorFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Doctor'> extends True ? Prisma__DoctorClient<$Types.GetResult<DoctorPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__DoctorClient<$Types.GetResult<DoctorPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Doctor that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorFindFirstOrThrowArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DoctorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DoctorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DoctorClient<$Types.GetResult<DoctorPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Doctors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Doctors
     * const doctors = await prisma.doctor.findMany()
     * 
     * // Get first 10 Doctors
     * const doctors = await prisma.doctor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const doctorWithIdOnly = await prisma.doctor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DoctorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DoctorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<DoctorPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Doctor.
     * @param {DoctorCreateArgs} args - Arguments to create a Doctor.
     * @example
     * // Create one Doctor
     * const Doctor = await prisma.doctor.create({
     *   data: {
     *     // ... data to create a Doctor
     *   }
     * })
     * 
    **/
    create<T extends DoctorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DoctorCreateArgs<ExtArgs>>
    ): Prisma__DoctorClient<$Types.GetResult<DoctorPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Doctors.
     *     @param {DoctorCreateManyArgs} args - Arguments to create many Doctors.
     *     @example
     *     // Create many Doctors
     *     const doctor = await prisma.doctor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DoctorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DoctorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Doctor.
     * @param {DoctorDeleteArgs} args - Arguments to delete one Doctor.
     * @example
     * // Delete one Doctor
     * const Doctor = await prisma.doctor.delete({
     *   where: {
     *     // ... filter to delete one Doctor
     *   }
     * })
     * 
    **/
    delete<T extends DoctorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DoctorDeleteArgs<ExtArgs>>
    ): Prisma__DoctorClient<$Types.GetResult<DoctorPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Doctor.
     * @param {DoctorUpdateArgs} args - Arguments to update one Doctor.
     * @example
     * // Update one Doctor
     * const doctor = await prisma.doctor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DoctorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DoctorUpdateArgs<ExtArgs>>
    ): Prisma__DoctorClient<$Types.GetResult<DoctorPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Doctors.
     * @param {DoctorDeleteManyArgs} args - Arguments to filter Doctors to delete.
     * @example
     * // Delete a few Doctors
     * const { count } = await prisma.doctor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DoctorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DoctorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Doctors
     * const doctor = await prisma.doctor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DoctorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DoctorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Doctor.
     * @param {DoctorUpsertArgs} args - Arguments to update or create a Doctor.
     * @example
     * // Update or create a Doctor
     * const doctor = await prisma.doctor.upsert({
     *   create: {
     *     // ... data to create a Doctor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Doctor we want to update
     *   }
     * })
    **/
    upsert<T extends DoctorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DoctorUpsertArgs<ExtArgs>>
    ): Prisma__DoctorClient<$Types.GetResult<DoctorPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorCountArgs} args - Arguments to filter Doctors to count.
     * @example
     * // Count the number of Doctors
     * const count = await prisma.doctor.count({
     *   where: {
     *     // ... the filter for the Doctors we want to count
     *   }
     * })
    **/
    count<T extends DoctorCountArgs>(
      args?: Subset<T, DoctorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DoctorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Doctor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoctorAggregateArgs>(args: Subset<T, DoctorAggregateArgs>): Prisma.PrismaPromise<GetDoctorAggregateType<T>>

    /**
     * Group by Doctor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DoctorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DoctorGroupByArgs['orderBy'] }
        : { orderBy?: DoctorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DoctorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoctorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Doctor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DoctorClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    users<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    prescription<T extends Doctor$prescriptionArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$prescriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PrescriptionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Doctor base type for findUnique actions
   */
  export type DoctorFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where: DoctorWhereUniqueInput
  }

  /**
   * Doctor findUnique
   */
  export interface DoctorFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DoctorFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Doctor findUniqueOrThrow
   */
  export type DoctorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where: DoctorWhereUniqueInput
  }


  /**
   * Doctor base type for findFirst actions
   */
  export type DoctorFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: Enumerable<DoctorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Doctors.
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Doctors.
     */
    distinct?: Enumerable<DoctorScalarFieldEnum>
  }

  /**
   * Doctor findFirst
   */
  export interface DoctorFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DoctorFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Doctor findFirstOrThrow
   */
  export type DoctorFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: Enumerable<DoctorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Doctors.
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Doctors.
     */
    distinct?: Enumerable<DoctorScalarFieldEnum>
  }


  /**
   * Doctor findMany
   */
  export type DoctorFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctors to fetch.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: Enumerable<DoctorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Doctors.
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    distinct?: Enumerable<DoctorScalarFieldEnum>
  }


  /**
   * Doctor create
   */
  export type DoctorCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * The data needed to create a Doctor.
     */
    data: XOR<DoctorCreateInput, DoctorUncheckedCreateInput>
  }


  /**
   * Doctor createMany
   */
  export type DoctorCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Doctors.
     */
    data: Enumerable<DoctorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Doctor update
   */
  export type DoctorUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * The data needed to update a Doctor.
     */
    data: XOR<DoctorUpdateInput, DoctorUncheckedUpdateInput>
    /**
     * Choose, which Doctor to update.
     */
    where: DoctorWhereUniqueInput
  }


  /**
   * Doctor updateMany
   */
  export type DoctorUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Doctors.
     */
    data: XOR<DoctorUpdateManyMutationInput, DoctorUncheckedUpdateManyInput>
    /**
     * Filter which Doctors to update
     */
    where?: DoctorWhereInput
  }


  /**
   * Doctor upsert
   */
  export type DoctorUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * The filter to search for the Doctor to update in case it exists.
     */
    where: DoctorWhereUniqueInput
    /**
     * In case the Doctor found by the `where` argument doesn't exist, create a new Doctor with this data.
     */
    create: XOR<DoctorCreateInput, DoctorUncheckedCreateInput>
    /**
     * In case the Doctor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoctorUpdateInput, DoctorUncheckedUpdateInput>
  }


  /**
   * Doctor delete
   */
  export type DoctorDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter which Doctor to delete.
     */
    where: DoctorWhereUniqueInput
  }


  /**
   * Doctor deleteMany
   */
  export type DoctorDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Doctors to delete
     */
    where?: DoctorWhereInput
  }


  /**
   * Doctor.prescription
   */
  export type Doctor$prescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PrescriptionInclude<ExtArgs> | null
    where?: PrescriptionWhereInput
    orderBy?: Enumerable<PrescriptionOrderByWithRelationInput>
    cursor?: PrescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PrescriptionScalarFieldEnum>
  }


  /**
   * Doctor without action
   */
  export type DoctorArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorInclude<ExtArgs> | null
  }



  /**
   * Model Patient
   */


  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientAvgAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type PatientSumAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type PatientMinAggregateOutputType = {
    id: number | null
    userid: number | null
    dateofbirth: Date | null
  }

  export type PatientMaxAggregateOutputType = {
    id: number | null
    userid: number | null
    dateofbirth: Date | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    userid: number
    dateofbirth: number
    _all: number
  }


  export type PatientAvgAggregateInputType = {
    id?: true
    userid?: true
  }

  export type PatientSumAggregateInputType = {
    id?: true
    userid?: true
  }

  export type PatientMinAggregateInputType = {
    id?: true
    userid?: true
    dateofbirth?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    userid?: true
    dateofbirth?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    userid?: true
    dateofbirth?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patient to aggregate.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: Enumerable<PatientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type PatientGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
    orderBy?: Enumerable<PatientOrderByWithAggregationInput>
    by: PatientScalarFieldEnum[]
    having?: PatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _avg?: PatientAvgAggregateInputType
    _sum?: PatientSumAggregateInputType
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }


  export type PatientGroupByOutputType = {
    id: number
    userid: number | null
    dateofbirth: Date
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends PatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type PatientSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    dateofbirth?: boolean
    users?: boolean | UserArgs<ExtArgs>
    prescription?: boolean | Patient$prescriptionArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectScalar = {
    id?: boolean
    userid?: boolean
    dateofbirth?: boolean
  }

  export type PatientInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    users?: boolean | UserArgs<ExtArgs>
    prescription?: boolean | Patient$prescriptionArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeArgs<ExtArgs>
  }


  type PatientGetPayload<S extends boolean | null | undefined | PatientArgs> = $Types.GetResult<PatientPayload, S>

  type PatientCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PatientFindManyArgs, 'select' | 'include'> & {
      select?: PatientCountAggregateInputType | true
    }

  export interface PatientDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patient'], meta: { name: 'Patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {PatientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PatientFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PatientFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Patient'> extends True ? Prisma__PatientClient<$Types.GetResult<PatientPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__PatientClient<$Types.GetResult<PatientPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Patient that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PatientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PatientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PatientClient<$Types.GetResult<PatientPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PatientFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PatientFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Patient'> extends True ? Prisma__PatientClient<$Types.GetResult<PatientPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__PatientClient<$Types.GetResult<PatientPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Patient that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PatientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PatientClient<$Types.GetResult<PatientPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PatientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PatientPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Patient.
     * @param {PatientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
    **/
    create<T extends PatientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PatientCreateArgs<ExtArgs>>
    ): Prisma__PatientClient<$Types.GetResult<PatientPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Patients.
     *     @param {PatientCreateManyArgs} args - Arguments to create many Patients.
     *     @example
     *     // Create many Patients
     *     const patient = await prisma.patient.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PatientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Patient.
     * @param {PatientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
    **/
    delete<T extends PatientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PatientDeleteArgs<ExtArgs>>
    ): Prisma__PatientClient<$Types.GetResult<PatientPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Patient.
     * @param {PatientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PatientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PatientUpdateArgs<ExtArgs>>
    ): Prisma__PatientClient<$Types.GetResult<PatientPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Patients.
     * @param {PatientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PatientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PatientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PatientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Patient.
     * @param {PatientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
    **/
    upsert<T extends PatientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PatientUpsertArgs<ExtArgs>>
    ): Prisma__PatientClient<$Types.GetResult<PatientPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientCountArgs>(
      args?: Subset<T, PatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientGroupByArgs['orderBy'] }
        : { orderBy?: PatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PatientClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    users<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    prescription<T extends Patient$prescriptionArgs<ExtArgs> = {}>(args?: Subset<T, Patient$prescriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PrescriptionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Patient base type for findUnique actions
   */
  export type PatientFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findUnique
   */
  export interface PatientFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PatientFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Patient findUniqueOrThrow
   */
  export type PatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }


  /**
   * Patient base type for findFirst actions
   */
  export type PatientFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: Enumerable<PatientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: Enumerable<PatientScalarFieldEnum>
  }

  /**
   * Patient findFirst
   */
  export interface PatientFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PatientFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Patient findFirstOrThrow
   */
  export type PatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: Enumerable<PatientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: Enumerable<PatientScalarFieldEnum>
  }


  /**
   * Patient findMany
   */
  export type PatientFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: Enumerable<PatientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: Enumerable<PatientScalarFieldEnum>
  }


  /**
   * Patient create
   */
  export type PatientCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to create a Patient.
     */
    data: XOR<PatientCreateInput, PatientUncheckedCreateInput>
  }


  /**
   * Patient createMany
   */
  export type PatientCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: Enumerable<PatientCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Patient update
   */
  export type PatientUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to update a Patient.
     */
    data: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
    /**
     * Choose, which Patient to update.
     */
    where: PatientWhereUniqueInput
  }


  /**
   * Patient updateMany
   */
  export type PatientUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
  }


  /**
   * Patient upsert
   */
  export type PatientUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The filter to search for the Patient to update in case it exists.
     */
    where: PatientWhereUniqueInput
    /**
     * In case the Patient found by the `where` argument doesn't exist, create a new Patient with this data.
     */
    create: XOR<PatientCreateInput, PatientUncheckedCreateInput>
    /**
     * In case the Patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
  }


  /**
   * Patient delete
   */
  export type PatientDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter which Patient to delete.
     */
    where: PatientWhereUniqueInput
  }


  /**
   * Patient deleteMany
   */
  export type PatientDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientWhereInput
  }


  /**
   * Patient.prescription
   */
  export type Patient$prescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PrescriptionInclude<ExtArgs> | null
    where?: PrescriptionWhereInput
    orderBy?: Enumerable<PrescriptionOrderByWithRelationInput>
    cursor?: PrescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PrescriptionScalarFieldEnum>
  }


  /**
   * Patient without action
   */
  export type PatientArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatientInclude<ExtArgs> | null
  }



  /**
   * Model Pharmacist
   */


  export type AggregatePharmacist = {
    _count: PharmacistCountAggregateOutputType | null
    _avg: PharmacistAvgAggregateOutputType | null
    _sum: PharmacistSumAggregateOutputType | null
    _min: PharmacistMinAggregateOutputType | null
    _max: PharmacistMaxAggregateOutputType | null
  }

  export type PharmacistAvgAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type PharmacistSumAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type PharmacistMinAggregateOutputType = {
    id: number | null
    userid: number | null
    licenseno: string | null
    pharmacy: string | null
  }

  export type PharmacistMaxAggregateOutputType = {
    id: number | null
    userid: number | null
    licenseno: string | null
    pharmacy: string | null
  }

  export type PharmacistCountAggregateOutputType = {
    id: number
    userid: number
    licenseno: number
    pharmacy: number
    _all: number
  }


  export type PharmacistAvgAggregateInputType = {
    id?: true
    userid?: true
  }

  export type PharmacistSumAggregateInputType = {
    id?: true
    userid?: true
  }

  export type PharmacistMinAggregateInputType = {
    id?: true
    userid?: true
    licenseno?: true
    pharmacy?: true
  }

  export type PharmacistMaxAggregateInputType = {
    id?: true
    userid?: true
    licenseno?: true
    pharmacy?: true
  }

  export type PharmacistCountAggregateInputType = {
    id?: true
    userid?: true
    licenseno?: true
    pharmacy?: true
    _all?: true
  }

  export type PharmacistAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pharmacist to aggregate.
     */
    where?: PharmacistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pharmacists to fetch.
     */
    orderBy?: Enumerable<PharmacistOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PharmacistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pharmacists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pharmacists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pharmacists
    **/
    _count?: true | PharmacistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PharmacistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PharmacistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PharmacistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PharmacistMaxAggregateInputType
  }

  export type GetPharmacistAggregateType<T extends PharmacistAggregateArgs> = {
        [P in keyof T & keyof AggregatePharmacist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePharmacist[P]>
      : GetScalarType<T[P], AggregatePharmacist[P]>
  }




  export type PharmacistGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PharmacistWhereInput
    orderBy?: Enumerable<PharmacistOrderByWithAggregationInput>
    by: PharmacistScalarFieldEnum[]
    having?: PharmacistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PharmacistCountAggregateInputType | true
    _avg?: PharmacistAvgAggregateInputType
    _sum?: PharmacistSumAggregateInputType
    _min?: PharmacistMinAggregateInputType
    _max?: PharmacistMaxAggregateInputType
  }


  export type PharmacistGroupByOutputType = {
    id: number
    userid: number | null
    licenseno: string
    pharmacy: string
    _count: PharmacistCountAggregateOutputType | null
    _avg: PharmacistAvgAggregateOutputType | null
    _sum: PharmacistSumAggregateOutputType | null
    _min: PharmacistMinAggregateOutputType | null
    _max: PharmacistMaxAggregateOutputType | null
  }

  type GetPharmacistGroupByPayload<T extends PharmacistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PharmacistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PharmacistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PharmacistGroupByOutputType[P]>
            : GetScalarType<T[P], PharmacistGroupByOutputType[P]>
        }
      >
    >


  export type PharmacistSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    licenseno?: boolean
    pharmacy?: boolean
    dispenserecord?: boolean | Pharmacist$dispenserecordArgs<ExtArgs>
    users?: boolean | UserArgs<ExtArgs>
    _count?: boolean | PharmacistCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["pharmacist"]>

  export type PharmacistSelectScalar = {
    id?: boolean
    userid?: boolean
    licenseno?: boolean
    pharmacy?: boolean
  }

  export type PharmacistInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    dispenserecord?: boolean | Pharmacist$dispenserecordArgs<ExtArgs>
    users?: boolean | UserArgs<ExtArgs>
    _count?: boolean | PharmacistCountOutputTypeArgs<ExtArgs>
  }


  type PharmacistGetPayload<S extends boolean | null | undefined | PharmacistArgs> = $Types.GetResult<PharmacistPayload, S>

  type PharmacistCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PharmacistFindManyArgs, 'select' | 'include'> & {
      select?: PharmacistCountAggregateInputType | true
    }

  export interface PharmacistDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pharmacist'], meta: { name: 'Pharmacist' } }
    /**
     * Find zero or one Pharmacist that matches the filter.
     * @param {PharmacistFindUniqueArgs} args - Arguments to find a Pharmacist
     * @example
     * // Get one Pharmacist
     * const pharmacist = await prisma.pharmacist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PharmacistFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PharmacistFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Pharmacist'> extends True ? Prisma__PharmacistClient<$Types.GetResult<PharmacistPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__PharmacistClient<$Types.GetResult<PharmacistPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Pharmacist that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PharmacistFindUniqueOrThrowArgs} args - Arguments to find a Pharmacist
     * @example
     * // Get one Pharmacist
     * const pharmacist = await prisma.pharmacist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PharmacistFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PharmacistFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PharmacistClient<$Types.GetResult<PharmacistPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Pharmacist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PharmacistFindFirstArgs} args - Arguments to find a Pharmacist
     * @example
     * // Get one Pharmacist
     * const pharmacist = await prisma.pharmacist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PharmacistFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PharmacistFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Pharmacist'> extends True ? Prisma__PharmacistClient<$Types.GetResult<PharmacistPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__PharmacistClient<$Types.GetResult<PharmacistPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Pharmacist that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PharmacistFindFirstOrThrowArgs} args - Arguments to find a Pharmacist
     * @example
     * // Get one Pharmacist
     * const pharmacist = await prisma.pharmacist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PharmacistFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PharmacistFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PharmacistClient<$Types.GetResult<PharmacistPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Pharmacists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PharmacistFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pharmacists
     * const pharmacists = await prisma.pharmacist.findMany()
     * 
     * // Get first 10 Pharmacists
     * const pharmacists = await prisma.pharmacist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pharmacistWithIdOnly = await prisma.pharmacist.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PharmacistFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PharmacistFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PharmacistPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Pharmacist.
     * @param {PharmacistCreateArgs} args - Arguments to create a Pharmacist.
     * @example
     * // Create one Pharmacist
     * const Pharmacist = await prisma.pharmacist.create({
     *   data: {
     *     // ... data to create a Pharmacist
     *   }
     * })
     * 
    **/
    create<T extends PharmacistCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PharmacistCreateArgs<ExtArgs>>
    ): Prisma__PharmacistClient<$Types.GetResult<PharmacistPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Pharmacists.
     *     @param {PharmacistCreateManyArgs} args - Arguments to create many Pharmacists.
     *     @example
     *     // Create many Pharmacists
     *     const pharmacist = await prisma.pharmacist.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PharmacistCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PharmacistCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pharmacist.
     * @param {PharmacistDeleteArgs} args - Arguments to delete one Pharmacist.
     * @example
     * // Delete one Pharmacist
     * const Pharmacist = await prisma.pharmacist.delete({
     *   where: {
     *     // ... filter to delete one Pharmacist
     *   }
     * })
     * 
    **/
    delete<T extends PharmacistDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PharmacistDeleteArgs<ExtArgs>>
    ): Prisma__PharmacistClient<$Types.GetResult<PharmacistPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Pharmacist.
     * @param {PharmacistUpdateArgs} args - Arguments to update one Pharmacist.
     * @example
     * // Update one Pharmacist
     * const pharmacist = await prisma.pharmacist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PharmacistUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PharmacistUpdateArgs<ExtArgs>>
    ): Prisma__PharmacistClient<$Types.GetResult<PharmacistPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Pharmacists.
     * @param {PharmacistDeleteManyArgs} args - Arguments to filter Pharmacists to delete.
     * @example
     * // Delete a few Pharmacists
     * const { count } = await prisma.pharmacist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PharmacistDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PharmacistDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pharmacists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PharmacistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pharmacists
     * const pharmacist = await prisma.pharmacist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PharmacistUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PharmacistUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pharmacist.
     * @param {PharmacistUpsertArgs} args - Arguments to update or create a Pharmacist.
     * @example
     * // Update or create a Pharmacist
     * const pharmacist = await prisma.pharmacist.upsert({
     *   create: {
     *     // ... data to create a Pharmacist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pharmacist we want to update
     *   }
     * })
    **/
    upsert<T extends PharmacistUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PharmacistUpsertArgs<ExtArgs>>
    ): Prisma__PharmacistClient<$Types.GetResult<PharmacistPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Pharmacists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PharmacistCountArgs} args - Arguments to filter Pharmacists to count.
     * @example
     * // Count the number of Pharmacists
     * const count = await prisma.pharmacist.count({
     *   where: {
     *     // ... the filter for the Pharmacists we want to count
     *   }
     * })
    **/
    count<T extends PharmacistCountArgs>(
      args?: Subset<T, PharmacistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PharmacistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pharmacist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PharmacistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PharmacistAggregateArgs>(args: Subset<T, PharmacistAggregateArgs>): Prisma.PrismaPromise<GetPharmacistAggregateType<T>>

    /**
     * Group by Pharmacist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PharmacistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PharmacistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PharmacistGroupByArgs['orderBy'] }
        : { orderBy?: PharmacistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PharmacistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPharmacistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Pharmacist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PharmacistClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    dispenserecord<T extends Pharmacist$dispenserecordArgs<ExtArgs> = {}>(args?: Subset<T, Pharmacist$dispenserecordArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DispenseRecordPayload<ExtArgs>, T, 'findMany', never>| Null>;

    users<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Pharmacist base type for findUnique actions
   */
  export type PharmacistFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pharmacist
     */
    select?: PharmacistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PharmacistInclude<ExtArgs> | null
    /**
     * Filter, which Pharmacist to fetch.
     */
    where: PharmacistWhereUniqueInput
  }

  /**
   * Pharmacist findUnique
   */
  export interface PharmacistFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PharmacistFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Pharmacist findUniqueOrThrow
   */
  export type PharmacistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pharmacist
     */
    select?: PharmacistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PharmacistInclude<ExtArgs> | null
    /**
     * Filter, which Pharmacist to fetch.
     */
    where: PharmacistWhereUniqueInput
  }


  /**
   * Pharmacist base type for findFirst actions
   */
  export type PharmacistFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pharmacist
     */
    select?: PharmacistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PharmacistInclude<ExtArgs> | null
    /**
     * Filter, which Pharmacist to fetch.
     */
    where?: PharmacistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pharmacists to fetch.
     */
    orderBy?: Enumerable<PharmacistOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pharmacists.
     */
    cursor?: PharmacistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pharmacists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pharmacists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pharmacists.
     */
    distinct?: Enumerable<PharmacistScalarFieldEnum>
  }

  /**
   * Pharmacist findFirst
   */
  export interface PharmacistFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PharmacistFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Pharmacist findFirstOrThrow
   */
  export type PharmacistFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pharmacist
     */
    select?: PharmacistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PharmacistInclude<ExtArgs> | null
    /**
     * Filter, which Pharmacist to fetch.
     */
    where?: PharmacistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pharmacists to fetch.
     */
    orderBy?: Enumerable<PharmacistOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pharmacists.
     */
    cursor?: PharmacistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pharmacists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pharmacists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pharmacists.
     */
    distinct?: Enumerable<PharmacistScalarFieldEnum>
  }


  /**
   * Pharmacist findMany
   */
  export type PharmacistFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pharmacist
     */
    select?: PharmacistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PharmacistInclude<ExtArgs> | null
    /**
     * Filter, which Pharmacists to fetch.
     */
    where?: PharmacistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pharmacists to fetch.
     */
    orderBy?: Enumerable<PharmacistOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pharmacists.
     */
    cursor?: PharmacistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pharmacists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pharmacists.
     */
    skip?: number
    distinct?: Enumerable<PharmacistScalarFieldEnum>
  }


  /**
   * Pharmacist create
   */
  export type PharmacistCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pharmacist
     */
    select?: PharmacistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PharmacistInclude<ExtArgs> | null
    /**
     * The data needed to create a Pharmacist.
     */
    data: XOR<PharmacistCreateInput, PharmacistUncheckedCreateInput>
  }


  /**
   * Pharmacist createMany
   */
  export type PharmacistCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pharmacists.
     */
    data: Enumerable<PharmacistCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Pharmacist update
   */
  export type PharmacistUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pharmacist
     */
    select?: PharmacistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PharmacistInclude<ExtArgs> | null
    /**
     * The data needed to update a Pharmacist.
     */
    data: XOR<PharmacistUpdateInput, PharmacistUncheckedUpdateInput>
    /**
     * Choose, which Pharmacist to update.
     */
    where: PharmacistWhereUniqueInput
  }


  /**
   * Pharmacist updateMany
   */
  export type PharmacistUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pharmacists.
     */
    data: XOR<PharmacistUpdateManyMutationInput, PharmacistUncheckedUpdateManyInput>
    /**
     * Filter which Pharmacists to update
     */
    where?: PharmacistWhereInput
  }


  /**
   * Pharmacist upsert
   */
  export type PharmacistUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pharmacist
     */
    select?: PharmacistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PharmacistInclude<ExtArgs> | null
    /**
     * The filter to search for the Pharmacist to update in case it exists.
     */
    where: PharmacistWhereUniqueInput
    /**
     * In case the Pharmacist found by the `where` argument doesn't exist, create a new Pharmacist with this data.
     */
    create: XOR<PharmacistCreateInput, PharmacistUncheckedCreateInput>
    /**
     * In case the Pharmacist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PharmacistUpdateInput, PharmacistUncheckedUpdateInput>
  }


  /**
   * Pharmacist delete
   */
  export type PharmacistDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pharmacist
     */
    select?: PharmacistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PharmacistInclude<ExtArgs> | null
    /**
     * Filter which Pharmacist to delete.
     */
    where: PharmacistWhereUniqueInput
  }


  /**
   * Pharmacist deleteMany
   */
  export type PharmacistDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pharmacists to delete
     */
    where?: PharmacistWhereInput
  }


  /**
   * Pharmacist.dispenserecord
   */
  export type Pharmacist$dispenserecordArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispenseRecord
     */
    select?: DispenseRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DispenseRecordInclude<ExtArgs> | null
    where?: DispenseRecordWhereInput
    orderBy?: Enumerable<DispenseRecordOrderByWithRelationInput>
    cursor?: DispenseRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DispenseRecordScalarFieldEnum>
  }


  /**
   * Pharmacist without action
   */
  export type PharmacistArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pharmacist
     */
    select?: PharmacistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PharmacistInclude<ExtArgs> | null
  }



  /**
   * Model Manufacturer
   */


  export type AggregateManufacturer = {
    _count: ManufacturerCountAggregateOutputType | null
    _avg: ManufacturerAvgAggregateOutputType | null
    _sum: ManufacturerSumAggregateOutputType | null
    _min: ManufacturerMinAggregateOutputType | null
    _max: ManufacturerMaxAggregateOutputType | null
  }

  export type ManufacturerAvgAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type ManufacturerSumAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type ManufacturerMinAggregateOutputType = {
    id: number | null
    userid: number | null
    companyname: string | null
  }

  export type ManufacturerMaxAggregateOutputType = {
    id: number | null
    userid: number | null
    companyname: string | null
  }

  export type ManufacturerCountAggregateOutputType = {
    id: number
    userid: number
    companyname: number
    _all: number
  }


  export type ManufacturerAvgAggregateInputType = {
    id?: true
    userid?: true
  }

  export type ManufacturerSumAggregateInputType = {
    id?: true
    userid?: true
  }

  export type ManufacturerMinAggregateInputType = {
    id?: true
    userid?: true
    companyname?: true
  }

  export type ManufacturerMaxAggregateInputType = {
    id?: true
    userid?: true
    companyname?: true
  }

  export type ManufacturerCountAggregateInputType = {
    id?: true
    userid?: true
    companyname?: true
    _all?: true
  }

  export type ManufacturerAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Manufacturer to aggregate.
     */
    where?: ManufacturerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Manufacturers to fetch.
     */
    orderBy?: Enumerable<ManufacturerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ManufacturerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Manufacturers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Manufacturers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Manufacturers
    **/
    _count?: true | ManufacturerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ManufacturerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ManufacturerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ManufacturerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ManufacturerMaxAggregateInputType
  }

  export type GetManufacturerAggregateType<T extends ManufacturerAggregateArgs> = {
        [P in keyof T & keyof AggregateManufacturer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManufacturer[P]>
      : GetScalarType<T[P], AggregateManufacturer[P]>
  }




  export type ManufacturerGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ManufacturerWhereInput
    orderBy?: Enumerable<ManufacturerOrderByWithAggregationInput>
    by: ManufacturerScalarFieldEnum[]
    having?: ManufacturerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ManufacturerCountAggregateInputType | true
    _avg?: ManufacturerAvgAggregateInputType
    _sum?: ManufacturerSumAggregateInputType
    _min?: ManufacturerMinAggregateInputType
    _max?: ManufacturerMaxAggregateInputType
  }


  export type ManufacturerGroupByOutputType = {
    id: number
    userid: number | null
    companyname: string
    _count: ManufacturerCountAggregateOutputType | null
    _avg: ManufacturerAvgAggregateOutputType | null
    _sum: ManufacturerSumAggregateOutputType | null
    _min: ManufacturerMinAggregateOutputType | null
    _max: ManufacturerMaxAggregateOutputType | null
  }

  type GetManufacturerGroupByPayload<T extends ManufacturerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ManufacturerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ManufacturerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ManufacturerGroupByOutputType[P]>
            : GetScalarType<T[P], ManufacturerGroupByOutputType[P]>
        }
      >
    >


  export type ManufacturerSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    companyname?: boolean
    drugbatch?: boolean | Manufacturer$drugbatchArgs<ExtArgs>
    users?: boolean | UserArgs<ExtArgs>
    _count?: boolean | ManufacturerCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["manufacturer"]>

  export type ManufacturerSelectScalar = {
    id?: boolean
    userid?: boolean
    companyname?: boolean
  }

  export type ManufacturerInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    drugbatch?: boolean | Manufacturer$drugbatchArgs<ExtArgs>
    users?: boolean | UserArgs<ExtArgs>
    _count?: boolean | ManufacturerCountOutputTypeArgs<ExtArgs>
  }


  type ManufacturerGetPayload<S extends boolean | null | undefined | ManufacturerArgs> = $Types.GetResult<ManufacturerPayload, S>

  type ManufacturerCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ManufacturerFindManyArgs, 'select' | 'include'> & {
      select?: ManufacturerCountAggregateInputType | true
    }

  export interface ManufacturerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Manufacturer'], meta: { name: 'Manufacturer' } }
    /**
     * Find zero or one Manufacturer that matches the filter.
     * @param {ManufacturerFindUniqueArgs} args - Arguments to find a Manufacturer
     * @example
     * // Get one Manufacturer
     * const manufacturer = await prisma.manufacturer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ManufacturerFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ManufacturerFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Manufacturer'> extends True ? Prisma__ManufacturerClient<$Types.GetResult<ManufacturerPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ManufacturerClient<$Types.GetResult<ManufacturerPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Manufacturer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ManufacturerFindUniqueOrThrowArgs} args - Arguments to find a Manufacturer
     * @example
     * // Get one Manufacturer
     * const manufacturer = await prisma.manufacturer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ManufacturerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ManufacturerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ManufacturerClient<$Types.GetResult<ManufacturerPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Manufacturer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManufacturerFindFirstArgs} args - Arguments to find a Manufacturer
     * @example
     * // Get one Manufacturer
     * const manufacturer = await prisma.manufacturer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ManufacturerFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ManufacturerFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Manufacturer'> extends True ? Prisma__ManufacturerClient<$Types.GetResult<ManufacturerPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ManufacturerClient<$Types.GetResult<ManufacturerPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Manufacturer that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManufacturerFindFirstOrThrowArgs} args - Arguments to find a Manufacturer
     * @example
     * // Get one Manufacturer
     * const manufacturer = await prisma.manufacturer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ManufacturerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ManufacturerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ManufacturerClient<$Types.GetResult<ManufacturerPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Manufacturers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManufacturerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Manufacturers
     * const manufacturers = await prisma.manufacturer.findMany()
     * 
     * // Get first 10 Manufacturers
     * const manufacturers = await prisma.manufacturer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const manufacturerWithIdOnly = await prisma.manufacturer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ManufacturerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ManufacturerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ManufacturerPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Manufacturer.
     * @param {ManufacturerCreateArgs} args - Arguments to create a Manufacturer.
     * @example
     * // Create one Manufacturer
     * const Manufacturer = await prisma.manufacturer.create({
     *   data: {
     *     // ... data to create a Manufacturer
     *   }
     * })
     * 
    **/
    create<T extends ManufacturerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ManufacturerCreateArgs<ExtArgs>>
    ): Prisma__ManufacturerClient<$Types.GetResult<ManufacturerPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Manufacturers.
     *     @param {ManufacturerCreateManyArgs} args - Arguments to create many Manufacturers.
     *     @example
     *     // Create many Manufacturers
     *     const manufacturer = await prisma.manufacturer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ManufacturerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ManufacturerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Manufacturer.
     * @param {ManufacturerDeleteArgs} args - Arguments to delete one Manufacturer.
     * @example
     * // Delete one Manufacturer
     * const Manufacturer = await prisma.manufacturer.delete({
     *   where: {
     *     // ... filter to delete one Manufacturer
     *   }
     * })
     * 
    **/
    delete<T extends ManufacturerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ManufacturerDeleteArgs<ExtArgs>>
    ): Prisma__ManufacturerClient<$Types.GetResult<ManufacturerPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Manufacturer.
     * @param {ManufacturerUpdateArgs} args - Arguments to update one Manufacturer.
     * @example
     * // Update one Manufacturer
     * const manufacturer = await prisma.manufacturer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ManufacturerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ManufacturerUpdateArgs<ExtArgs>>
    ): Prisma__ManufacturerClient<$Types.GetResult<ManufacturerPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Manufacturers.
     * @param {ManufacturerDeleteManyArgs} args - Arguments to filter Manufacturers to delete.
     * @example
     * // Delete a few Manufacturers
     * const { count } = await prisma.manufacturer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ManufacturerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ManufacturerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Manufacturers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManufacturerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Manufacturers
     * const manufacturer = await prisma.manufacturer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ManufacturerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ManufacturerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Manufacturer.
     * @param {ManufacturerUpsertArgs} args - Arguments to update or create a Manufacturer.
     * @example
     * // Update or create a Manufacturer
     * const manufacturer = await prisma.manufacturer.upsert({
     *   create: {
     *     // ... data to create a Manufacturer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Manufacturer we want to update
     *   }
     * })
    **/
    upsert<T extends ManufacturerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ManufacturerUpsertArgs<ExtArgs>>
    ): Prisma__ManufacturerClient<$Types.GetResult<ManufacturerPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Manufacturers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManufacturerCountArgs} args - Arguments to filter Manufacturers to count.
     * @example
     * // Count the number of Manufacturers
     * const count = await prisma.manufacturer.count({
     *   where: {
     *     // ... the filter for the Manufacturers we want to count
     *   }
     * })
    **/
    count<T extends ManufacturerCountArgs>(
      args?: Subset<T, ManufacturerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ManufacturerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Manufacturer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManufacturerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ManufacturerAggregateArgs>(args: Subset<T, ManufacturerAggregateArgs>): Prisma.PrismaPromise<GetManufacturerAggregateType<T>>

    /**
     * Group by Manufacturer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManufacturerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ManufacturerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ManufacturerGroupByArgs['orderBy'] }
        : { orderBy?: ManufacturerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ManufacturerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManufacturerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Manufacturer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ManufacturerClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    drugbatch<T extends Manufacturer$drugbatchArgs<ExtArgs> = {}>(args?: Subset<T, Manufacturer$drugbatchArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DrugBatchPayload<ExtArgs>, T, 'findMany', never>| Null>;

    users<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Manufacturer base type for findUnique actions
   */
  export type ManufacturerFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manufacturer
     */
    select?: ManufacturerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ManufacturerInclude<ExtArgs> | null
    /**
     * Filter, which Manufacturer to fetch.
     */
    where: ManufacturerWhereUniqueInput
  }

  /**
   * Manufacturer findUnique
   */
  export interface ManufacturerFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ManufacturerFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Manufacturer findUniqueOrThrow
   */
  export type ManufacturerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manufacturer
     */
    select?: ManufacturerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ManufacturerInclude<ExtArgs> | null
    /**
     * Filter, which Manufacturer to fetch.
     */
    where: ManufacturerWhereUniqueInput
  }


  /**
   * Manufacturer base type for findFirst actions
   */
  export type ManufacturerFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manufacturer
     */
    select?: ManufacturerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ManufacturerInclude<ExtArgs> | null
    /**
     * Filter, which Manufacturer to fetch.
     */
    where?: ManufacturerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Manufacturers to fetch.
     */
    orderBy?: Enumerable<ManufacturerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Manufacturers.
     */
    cursor?: ManufacturerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Manufacturers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Manufacturers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Manufacturers.
     */
    distinct?: Enumerable<ManufacturerScalarFieldEnum>
  }

  /**
   * Manufacturer findFirst
   */
  export interface ManufacturerFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ManufacturerFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Manufacturer findFirstOrThrow
   */
  export type ManufacturerFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manufacturer
     */
    select?: ManufacturerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ManufacturerInclude<ExtArgs> | null
    /**
     * Filter, which Manufacturer to fetch.
     */
    where?: ManufacturerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Manufacturers to fetch.
     */
    orderBy?: Enumerable<ManufacturerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Manufacturers.
     */
    cursor?: ManufacturerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Manufacturers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Manufacturers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Manufacturers.
     */
    distinct?: Enumerable<ManufacturerScalarFieldEnum>
  }


  /**
   * Manufacturer findMany
   */
  export type ManufacturerFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manufacturer
     */
    select?: ManufacturerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ManufacturerInclude<ExtArgs> | null
    /**
     * Filter, which Manufacturers to fetch.
     */
    where?: ManufacturerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Manufacturers to fetch.
     */
    orderBy?: Enumerable<ManufacturerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Manufacturers.
     */
    cursor?: ManufacturerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Manufacturers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Manufacturers.
     */
    skip?: number
    distinct?: Enumerable<ManufacturerScalarFieldEnum>
  }


  /**
   * Manufacturer create
   */
  export type ManufacturerCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manufacturer
     */
    select?: ManufacturerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ManufacturerInclude<ExtArgs> | null
    /**
     * The data needed to create a Manufacturer.
     */
    data: XOR<ManufacturerCreateInput, ManufacturerUncheckedCreateInput>
  }


  /**
   * Manufacturer createMany
   */
  export type ManufacturerCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Manufacturers.
     */
    data: Enumerable<ManufacturerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Manufacturer update
   */
  export type ManufacturerUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manufacturer
     */
    select?: ManufacturerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ManufacturerInclude<ExtArgs> | null
    /**
     * The data needed to update a Manufacturer.
     */
    data: XOR<ManufacturerUpdateInput, ManufacturerUncheckedUpdateInput>
    /**
     * Choose, which Manufacturer to update.
     */
    where: ManufacturerWhereUniqueInput
  }


  /**
   * Manufacturer updateMany
   */
  export type ManufacturerUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Manufacturers.
     */
    data: XOR<ManufacturerUpdateManyMutationInput, ManufacturerUncheckedUpdateManyInput>
    /**
     * Filter which Manufacturers to update
     */
    where?: ManufacturerWhereInput
  }


  /**
   * Manufacturer upsert
   */
  export type ManufacturerUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manufacturer
     */
    select?: ManufacturerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ManufacturerInclude<ExtArgs> | null
    /**
     * The filter to search for the Manufacturer to update in case it exists.
     */
    where: ManufacturerWhereUniqueInput
    /**
     * In case the Manufacturer found by the `where` argument doesn't exist, create a new Manufacturer with this data.
     */
    create: XOR<ManufacturerCreateInput, ManufacturerUncheckedCreateInput>
    /**
     * In case the Manufacturer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ManufacturerUpdateInput, ManufacturerUncheckedUpdateInput>
  }


  /**
   * Manufacturer delete
   */
  export type ManufacturerDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manufacturer
     */
    select?: ManufacturerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ManufacturerInclude<ExtArgs> | null
    /**
     * Filter which Manufacturer to delete.
     */
    where: ManufacturerWhereUniqueInput
  }


  /**
   * Manufacturer deleteMany
   */
  export type ManufacturerDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Manufacturers to delete
     */
    where?: ManufacturerWhereInput
  }


  /**
   * Manufacturer.drugbatch
   */
  export type Manufacturer$drugbatchArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugBatch
     */
    select?: DrugBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DrugBatchInclude<ExtArgs> | null
    where?: DrugBatchWhereInput
    orderBy?: Enumerable<DrugBatchOrderByWithRelationInput>
    cursor?: DrugBatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DrugBatchScalarFieldEnum>
  }


  /**
   * Manufacturer without action
   */
  export type ManufacturerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manufacturer
     */
    select?: ManufacturerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ManufacturerInclude<ExtArgs> | null
  }



  /**
   * Model Distributor
   */


  export type AggregateDistributor = {
    _count: DistributorCountAggregateOutputType | null
    _avg: DistributorAvgAggregateOutputType | null
    _sum: DistributorSumAggregateOutputType | null
    _min: DistributorMinAggregateOutputType | null
    _max: DistributorMaxAggregateOutputType | null
  }

  export type DistributorAvgAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type DistributorSumAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type DistributorMinAggregateOutputType = {
    id: number | null
    userid: number | null
    companyname: string | null
  }

  export type DistributorMaxAggregateOutputType = {
    id: number | null
    userid: number | null
    companyname: string | null
  }

  export type DistributorCountAggregateOutputType = {
    id: number
    userid: number
    companyname: number
    _all: number
  }


  export type DistributorAvgAggregateInputType = {
    id?: true
    userid?: true
  }

  export type DistributorSumAggregateInputType = {
    id?: true
    userid?: true
  }

  export type DistributorMinAggregateInputType = {
    id?: true
    userid?: true
    companyname?: true
  }

  export type DistributorMaxAggregateInputType = {
    id?: true
    userid?: true
    companyname?: true
  }

  export type DistributorCountAggregateInputType = {
    id?: true
    userid?: true
    companyname?: true
    _all?: true
  }

  export type DistributorAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Distributor to aggregate.
     */
    where?: DistributorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Distributors to fetch.
     */
    orderBy?: Enumerable<DistributorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DistributorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Distributors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Distributors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Distributors
    **/
    _count?: true | DistributorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DistributorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DistributorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DistributorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DistributorMaxAggregateInputType
  }

  export type GetDistributorAggregateType<T extends DistributorAggregateArgs> = {
        [P in keyof T & keyof AggregateDistributor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDistributor[P]>
      : GetScalarType<T[P], AggregateDistributor[P]>
  }




  export type DistributorGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DistributorWhereInput
    orderBy?: Enumerable<DistributorOrderByWithAggregationInput>
    by: DistributorScalarFieldEnum[]
    having?: DistributorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DistributorCountAggregateInputType | true
    _avg?: DistributorAvgAggregateInputType
    _sum?: DistributorSumAggregateInputType
    _min?: DistributorMinAggregateInputType
    _max?: DistributorMaxAggregateInputType
  }


  export type DistributorGroupByOutputType = {
    id: number
    userid: number | null
    companyname: string
    _count: DistributorCountAggregateOutputType | null
    _avg: DistributorAvgAggregateOutputType | null
    _sum: DistributorSumAggregateOutputType | null
    _min: DistributorMinAggregateOutputType | null
    _max: DistributorMaxAggregateOutputType | null
  }

  type GetDistributorGroupByPayload<T extends DistributorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DistributorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DistributorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DistributorGroupByOutputType[P]>
            : GetScalarType<T[P], DistributorGroupByOutputType[P]>
        }
      >
    >


  export type DistributorSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    companyname?: boolean
    users?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["distributor"]>

  export type DistributorSelectScalar = {
    id?: boolean
    userid?: boolean
    companyname?: boolean
  }

  export type DistributorInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    users?: boolean | UserArgs<ExtArgs>
  }


  type DistributorGetPayload<S extends boolean | null | undefined | DistributorArgs> = $Types.GetResult<DistributorPayload, S>

  type DistributorCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DistributorFindManyArgs, 'select' | 'include'> & {
      select?: DistributorCountAggregateInputType | true
    }

  export interface DistributorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Distributor'], meta: { name: 'Distributor' } }
    /**
     * Find zero or one Distributor that matches the filter.
     * @param {DistributorFindUniqueArgs} args - Arguments to find a Distributor
     * @example
     * // Get one Distributor
     * const distributor = await prisma.distributor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DistributorFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DistributorFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Distributor'> extends True ? Prisma__DistributorClient<$Types.GetResult<DistributorPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__DistributorClient<$Types.GetResult<DistributorPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Distributor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DistributorFindUniqueOrThrowArgs} args - Arguments to find a Distributor
     * @example
     * // Get one Distributor
     * const distributor = await prisma.distributor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DistributorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DistributorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DistributorClient<$Types.GetResult<DistributorPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Distributor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributorFindFirstArgs} args - Arguments to find a Distributor
     * @example
     * // Get one Distributor
     * const distributor = await prisma.distributor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DistributorFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DistributorFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Distributor'> extends True ? Prisma__DistributorClient<$Types.GetResult<DistributorPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__DistributorClient<$Types.GetResult<DistributorPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Distributor that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributorFindFirstOrThrowArgs} args - Arguments to find a Distributor
     * @example
     * // Get one Distributor
     * const distributor = await prisma.distributor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DistributorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DistributorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DistributorClient<$Types.GetResult<DistributorPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Distributors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Distributors
     * const distributors = await prisma.distributor.findMany()
     * 
     * // Get first 10 Distributors
     * const distributors = await prisma.distributor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const distributorWithIdOnly = await prisma.distributor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DistributorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DistributorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<DistributorPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Distributor.
     * @param {DistributorCreateArgs} args - Arguments to create a Distributor.
     * @example
     * // Create one Distributor
     * const Distributor = await prisma.distributor.create({
     *   data: {
     *     // ... data to create a Distributor
     *   }
     * })
     * 
    **/
    create<T extends DistributorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DistributorCreateArgs<ExtArgs>>
    ): Prisma__DistributorClient<$Types.GetResult<DistributorPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Distributors.
     *     @param {DistributorCreateManyArgs} args - Arguments to create many Distributors.
     *     @example
     *     // Create many Distributors
     *     const distributor = await prisma.distributor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DistributorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DistributorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Distributor.
     * @param {DistributorDeleteArgs} args - Arguments to delete one Distributor.
     * @example
     * // Delete one Distributor
     * const Distributor = await prisma.distributor.delete({
     *   where: {
     *     // ... filter to delete one Distributor
     *   }
     * })
     * 
    **/
    delete<T extends DistributorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DistributorDeleteArgs<ExtArgs>>
    ): Prisma__DistributorClient<$Types.GetResult<DistributorPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Distributor.
     * @param {DistributorUpdateArgs} args - Arguments to update one Distributor.
     * @example
     * // Update one Distributor
     * const distributor = await prisma.distributor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DistributorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DistributorUpdateArgs<ExtArgs>>
    ): Prisma__DistributorClient<$Types.GetResult<DistributorPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Distributors.
     * @param {DistributorDeleteManyArgs} args - Arguments to filter Distributors to delete.
     * @example
     * // Delete a few Distributors
     * const { count } = await prisma.distributor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DistributorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DistributorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Distributors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Distributors
     * const distributor = await prisma.distributor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DistributorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DistributorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Distributor.
     * @param {DistributorUpsertArgs} args - Arguments to update or create a Distributor.
     * @example
     * // Update or create a Distributor
     * const distributor = await prisma.distributor.upsert({
     *   create: {
     *     // ... data to create a Distributor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Distributor we want to update
     *   }
     * })
    **/
    upsert<T extends DistributorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DistributorUpsertArgs<ExtArgs>>
    ): Prisma__DistributorClient<$Types.GetResult<DistributorPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Distributors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributorCountArgs} args - Arguments to filter Distributors to count.
     * @example
     * // Count the number of Distributors
     * const count = await prisma.distributor.count({
     *   where: {
     *     // ... the filter for the Distributors we want to count
     *   }
     * })
    **/
    count<T extends DistributorCountArgs>(
      args?: Subset<T, DistributorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DistributorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Distributor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DistributorAggregateArgs>(args: Subset<T, DistributorAggregateArgs>): Prisma.PrismaPromise<GetDistributorAggregateType<T>>

    /**
     * Group by Distributor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistributorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DistributorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DistributorGroupByArgs['orderBy'] }
        : { orderBy?: DistributorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DistributorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDistributorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Distributor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DistributorClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    users<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Distributor base type for findUnique actions
   */
  export type DistributorFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DistributorInclude<ExtArgs> | null
    /**
     * Filter, which Distributor to fetch.
     */
    where: DistributorWhereUniqueInput
  }

  /**
   * Distributor findUnique
   */
  export interface DistributorFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DistributorFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Distributor findUniqueOrThrow
   */
  export type DistributorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DistributorInclude<ExtArgs> | null
    /**
     * Filter, which Distributor to fetch.
     */
    where: DistributorWhereUniqueInput
  }


  /**
   * Distributor base type for findFirst actions
   */
  export type DistributorFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DistributorInclude<ExtArgs> | null
    /**
     * Filter, which Distributor to fetch.
     */
    where?: DistributorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Distributors to fetch.
     */
    orderBy?: Enumerable<DistributorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Distributors.
     */
    cursor?: DistributorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Distributors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Distributors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Distributors.
     */
    distinct?: Enumerable<DistributorScalarFieldEnum>
  }

  /**
   * Distributor findFirst
   */
  export interface DistributorFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DistributorFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Distributor findFirstOrThrow
   */
  export type DistributorFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DistributorInclude<ExtArgs> | null
    /**
     * Filter, which Distributor to fetch.
     */
    where?: DistributorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Distributors to fetch.
     */
    orderBy?: Enumerable<DistributorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Distributors.
     */
    cursor?: DistributorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Distributors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Distributors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Distributors.
     */
    distinct?: Enumerable<DistributorScalarFieldEnum>
  }


  /**
   * Distributor findMany
   */
  export type DistributorFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DistributorInclude<ExtArgs> | null
    /**
     * Filter, which Distributors to fetch.
     */
    where?: DistributorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Distributors to fetch.
     */
    orderBy?: Enumerable<DistributorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Distributors.
     */
    cursor?: DistributorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Distributors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Distributors.
     */
    skip?: number
    distinct?: Enumerable<DistributorScalarFieldEnum>
  }


  /**
   * Distributor create
   */
  export type DistributorCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DistributorInclude<ExtArgs> | null
    /**
     * The data needed to create a Distributor.
     */
    data: XOR<DistributorCreateInput, DistributorUncheckedCreateInput>
  }


  /**
   * Distributor createMany
   */
  export type DistributorCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Distributors.
     */
    data: Enumerable<DistributorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Distributor update
   */
  export type DistributorUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DistributorInclude<ExtArgs> | null
    /**
     * The data needed to update a Distributor.
     */
    data: XOR<DistributorUpdateInput, DistributorUncheckedUpdateInput>
    /**
     * Choose, which Distributor to update.
     */
    where: DistributorWhereUniqueInput
  }


  /**
   * Distributor updateMany
   */
  export type DistributorUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Distributors.
     */
    data: XOR<DistributorUpdateManyMutationInput, DistributorUncheckedUpdateManyInput>
    /**
     * Filter which Distributors to update
     */
    where?: DistributorWhereInput
  }


  /**
   * Distributor upsert
   */
  export type DistributorUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DistributorInclude<ExtArgs> | null
    /**
     * The filter to search for the Distributor to update in case it exists.
     */
    where: DistributorWhereUniqueInput
    /**
     * In case the Distributor found by the `where` argument doesn't exist, create a new Distributor with this data.
     */
    create: XOR<DistributorCreateInput, DistributorUncheckedCreateInput>
    /**
     * In case the Distributor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DistributorUpdateInput, DistributorUncheckedUpdateInput>
  }


  /**
   * Distributor delete
   */
  export type DistributorDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DistributorInclude<ExtArgs> | null
    /**
     * Filter which Distributor to delete.
     */
    where: DistributorWhereUniqueInput
  }


  /**
   * Distributor deleteMany
   */
  export type DistributorDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Distributors to delete
     */
    where?: DistributorWhereInput
  }


  /**
   * Distributor without action
   */
  export type DistributorArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Distributor
     */
    select?: DistributorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DistributorInclude<ExtArgs> | null
  }



  /**
   * Model Regulator
   */


  export type AggregateRegulator = {
    _count: RegulatorCountAggregateOutputType | null
    _avg: RegulatorAvgAggregateOutputType | null
    _sum: RegulatorSumAggregateOutputType | null
    _min: RegulatorMinAggregateOutputType | null
    _max: RegulatorMaxAggregateOutputType | null
  }

  export type RegulatorAvgAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type RegulatorSumAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type RegulatorMinAggregateOutputType = {
    id: number | null
    userid: number | null
    agencyname: string | null
  }

  export type RegulatorMaxAggregateOutputType = {
    id: number | null
    userid: number | null
    agencyname: string | null
  }

  export type RegulatorCountAggregateOutputType = {
    id: number
    userid: number
    agencyname: number
    _all: number
  }


  export type RegulatorAvgAggregateInputType = {
    id?: true
    userid?: true
  }

  export type RegulatorSumAggregateInputType = {
    id?: true
    userid?: true
  }

  export type RegulatorMinAggregateInputType = {
    id?: true
    userid?: true
    agencyname?: true
  }

  export type RegulatorMaxAggregateInputType = {
    id?: true
    userid?: true
    agencyname?: true
  }

  export type RegulatorCountAggregateInputType = {
    id?: true
    userid?: true
    agencyname?: true
    _all?: true
  }

  export type RegulatorAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Regulator to aggregate.
     */
    where?: RegulatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regulators to fetch.
     */
    orderBy?: Enumerable<RegulatorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegulatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regulators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regulators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Regulators
    **/
    _count?: true | RegulatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegulatorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegulatorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegulatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegulatorMaxAggregateInputType
  }

  export type GetRegulatorAggregateType<T extends RegulatorAggregateArgs> = {
        [P in keyof T & keyof AggregateRegulator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegulator[P]>
      : GetScalarType<T[P], AggregateRegulator[P]>
  }




  export type RegulatorGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: RegulatorWhereInput
    orderBy?: Enumerable<RegulatorOrderByWithAggregationInput>
    by: RegulatorScalarFieldEnum[]
    having?: RegulatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegulatorCountAggregateInputType | true
    _avg?: RegulatorAvgAggregateInputType
    _sum?: RegulatorSumAggregateInputType
    _min?: RegulatorMinAggregateInputType
    _max?: RegulatorMaxAggregateInputType
  }


  export type RegulatorGroupByOutputType = {
    id: number
    userid: number | null
    agencyname: string
    _count: RegulatorCountAggregateOutputType | null
    _avg: RegulatorAvgAggregateOutputType | null
    _sum: RegulatorSumAggregateOutputType | null
    _min: RegulatorMinAggregateOutputType | null
    _max: RegulatorMaxAggregateOutputType | null
  }

  type GetRegulatorGroupByPayload<T extends RegulatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RegulatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegulatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegulatorGroupByOutputType[P]>
            : GetScalarType<T[P], RegulatorGroupByOutputType[P]>
        }
      >
    >


  export type RegulatorSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    agencyname?: boolean
    users?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["regulator"]>

  export type RegulatorSelectScalar = {
    id?: boolean
    userid?: boolean
    agencyname?: boolean
  }

  export type RegulatorInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    users?: boolean | UserArgs<ExtArgs>
  }


  type RegulatorGetPayload<S extends boolean | null | undefined | RegulatorArgs> = $Types.GetResult<RegulatorPayload, S>

  type RegulatorCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<RegulatorFindManyArgs, 'select' | 'include'> & {
      select?: RegulatorCountAggregateInputType | true
    }

  export interface RegulatorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Regulator'], meta: { name: 'Regulator' } }
    /**
     * Find zero or one Regulator that matches the filter.
     * @param {RegulatorFindUniqueArgs} args - Arguments to find a Regulator
     * @example
     * // Get one Regulator
     * const regulator = await prisma.regulator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RegulatorFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RegulatorFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Regulator'> extends True ? Prisma__RegulatorClient<$Types.GetResult<RegulatorPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__RegulatorClient<$Types.GetResult<RegulatorPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Regulator that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RegulatorFindUniqueOrThrowArgs} args - Arguments to find a Regulator
     * @example
     * // Get one Regulator
     * const regulator = await prisma.regulator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RegulatorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RegulatorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RegulatorClient<$Types.GetResult<RegulatorPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Regulator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegulatorFindFirstArgs} args - Arguments to find a Regulator
     * @example
     * // Get one Regulator
     * const regulator = await prisma.regulator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RegulatorFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RegulatorFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Regulator'> extends True ? Prisma__RegulatorClient<$Types.GetResult<RegulatorPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__RegulatorClient<$Types.GetResult<RegulatorPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Regulator that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegulatorFindFirstOrThrowArgs} args - Arguments to find a Regulator
     * @example
     * // Get one Regulator
     * const regulator = await prisma.regulator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RegulatorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RegulatorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RegulatorClient<$Types.GetResult<RegulatorPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Regulators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegulatorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Regulators
     * const regulators = await prisma.regulator.findMany()
     * 
     * // Get first 10 Regulators
     * const regulators = await prisma.regulator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regulatorWithIdOnly = await prisma.regulator.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RegulatorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RegulatorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<RegulatorPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Regulator.
     * @param {RegulatorCreateArgs} args - Arguments to create a Regulator.
     * @example
     * // Create one Regulator
     * const Regulator = await prisma.regulator.create({
     *   data: {
     *     // ... data to create a Regulator
     *   }
     * })
     * 
    **/
    create<T extends RegulatorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RegulatorCreateArgs<ExtArgs>>
    ): Prisma__RegulatorClient<$Types.GetResult<RegulatorPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Regulators.
     *     @param {RegulatorCreateManyArgs} args - Arguments to create many Regulators.
     *     @example
     *     // Create many Regulators
     *     const regulator = await prisma.regulator.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RegulatorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RegulatorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Regulator.
     * @param {RegulatorDeleteArgs} args - Arguments to delete one Regulator.
     * @example
     * // Delete one Regulator
     * const Regulator = await prisma.regulator.delete({
     *   where: {
     *     // ... filter to delete one Regulator
     *   }
     * })
     * 
    **/
    delete<T extends RegulatorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RegulatorDeleteArgs<ExtArgs>>
    ): Prisma__RegulatorClient<$Types.GetResult<RegulatorPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Regulator.
     * @param {RegulatorUpdateArgs} args - Arguments to update one Regulator.
     * @example
     * // Update one Regulator
     * const regulator = await prisma.regulator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RegulatorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RegulatorUpdateArgs<ExtArgs>>
    ): Prisma__RegulatorClient<$Types.GetResult<RegulatorPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Regulators.
     * @param {RegulatorDeleteManyArgs} args - Arguments to filter Regulators to delete.
     * @example
     * // Delete a few Regulators
     * const { count } = await prisma.regulator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RegulatorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RegulatorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regulators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegulatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Regulators
     * const regulator = await prisma.regulator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RegulatorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RegulatorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Regulator.
     * @param {RegulatorUpsertArgs} args - Arguments to update or create a Regulator.
     * @example
     * // Update or create a Regulator
     * const regulator = await prisma.regulator.upsert({
     *   create: {
     *     // ... data to create a Regulator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Regulator we want to update
     *   }
     * })
    **/
    upsert<T extends RegulatorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RegulatorUpsertArgs<ExtArgs>>
    ): Prisma__RegulatorClient<$Types.GetResult<RegulatorPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Regulators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegulatorCountArgs} args - Arguments to filter Regulators to count.
     * @example
     * // Count the number of Regulators
     * const count = await prisma.regulator.count({
     *   where: {
     *     // ... the filter for the Regulators we want to count
     *   }
     * })
    **/
    count<T extends RegulatorCountArgs>(
      args?: Subset<T, RegulatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegulatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Regulator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegulatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegulatorAggregateArgs>(args: Subset<T, RegulatorAggregateArgs>): Prisma.PrismaPromise<GetRegulatorAggregateType<T>>

    /**
     * Group by Regulator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegulatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegulatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegulatorGroupByArgs['orderBy'] }
        : { orderBy?: RegulatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegulatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegulatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Regulator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RegulatorClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    users<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Regulator base type for findUnique actions
   */
  export type RegulatorFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regulator
     */
    select?: RegulatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegulatorInclude<ExtArgs> | null
    /**
     * Filter, which Regulator to fetch.
     */
    where: RegulatorWhereUniqueInput
  }

  /**
   * Regulator findUnique
   */
  export interface RegulatorFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends RegulatorFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Regulator findUniqueOrThrow
   */
  export type RegulatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regulator
     */
    select?: RegulatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegulatorInclude<ExtArgs> | null
    /**
     * Filter, which Regulator to fetch.
     */
    where: RegulatorWhereUniqueInput
  }


  /**
   * Regulator base type for findFirst actions
   */
  export type RegulatorFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regulator
     */
    select?: RegulatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegulatorInclude<ExtArgs> | null
    /**
     * Filter, which Regulator to fetch.
     */
    where?: RegulatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regulators to fetch.
     */
    orderBy?: Enumerable<RegulatorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regulators.
     */
    cursor?: RegulatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regulators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regulators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regulators.
     */
    distinct?: Enumerable<RegulatorScalarFieldEnum>
  }

  /**
   * Regulator findFirst
   */
  export interface RegulatorFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends RegulatorFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Regulator findFirstOrThrow
   */
  export type RegulatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regulator
     */
    select?: RegulatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegulatorInclude<ExtArgs> | null
    /**
     * Filter, which Regulator to fetch.
     */
    where?: RegulatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regulators to fetch.
     */
    orderBy?: Enumerable<RegulatorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regulators.
     */
    cursor?: RegulatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regulators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regulators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regulators.
     */
    distinct?: Enumerable<RegulatorScalarFieldEnum>
  }


  /**
   * Regulator findMany
   */
  export type RegulatorFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regulator
     */
    select?: RegulatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegulatorInclude<ExtArgs> | null
    /**
     * Filter, which Regulators to fetch.
     */
    where?: RegulatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regulators to fetch.
     */
    orderBy?: Enumerable<RegulatorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Regulators.
     */
    cursor?: RegulatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regulators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regulators.
     */
    skip?: number
    distinct?: Enumerable<RegulatorScalarFieldEnum>
  }


  /**
   * Regulator create
   */
  export type RegulatorCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regulator
     */
    select?: RegulatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegulatorInclude<ExtArgs> | null
    /**
     * The data needed to create a Regulator.
     */
    data: XOR<RegulatorCreateInput, RegulatorUncheckedCreateInput>
  }


  /**
   * Regulator createMany
   */
  export type RegulatorCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Regulators.
     */
    data: Enumerable<RegulatorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Regulator update
   */
  export type RegulatorUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regulator
     */
    select?: RegulatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegulatorInclude<ExtArgs> | null
    /**
     * The data needed to update a Regulator.
     */
    data: XOR<RegulatorUpdateInput, RegulatorUncheckedUpdateInput>
    /**
     * Choose, which Regulator to update.
     */
    where: RegulatorWhereUniqueInput
  }


  /**
   * Regulator updateMany
   */
  export type RegulatorUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Regulators.
     */
    data: XOR<RegulatorUpdateManyMutationInput, RegulatorUncheckedUpdateManyInput>
    /**
     * Filter which Regulators to update
     */
    where?: RegulatorWhereInput
  }


  /**
   * Regulator upsert
   */
  export type RegulatorUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regulator
     */
    select?: RegulatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegulatorInclude<ExtArgs> | null
    /**
     * The filter to search for the Regulator to update in case it exists.
     */
    where: RegulatorWhereUniqueInput
    /**
     * In case the Regulator found by the `where` argument doesn't exist, create a new Regulator with this data.
     */
    create: XOR<RegulatorCreateInput, RegulatorUncheckedCreateInput>
    /**
     * In case the Regulator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegulatorUpdateInput, RegulatorUncheckedUpdateInput>
  }


  /**
   * Regulator delete
   */
  export type RegulatorDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regulator
     */
    select?: RegulatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegulatorInclude<ExtArgs> | null
    /**
     * Filter which Regulator to delete.
     */
    where: RegulatorWhereUniqueInput
  }


  /**
   * Regulator deleteMany
   */
  export type RegulatorDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Regulators to delete
     */
    where?: RegulatorWhereInput
  }


  /**
   * Regulator without action
   */
  export type RegulatorArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regulator
     */
    select?: RegulatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegulatorInclude<ExtArgs> | null
  }



  /**
   * Model Admin
   */


  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type AdminSumAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type AdminMaxAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    userid: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    id?: true
    userid?: true
  }

  export type AdminSumAggregateInputType = {
    id?: true
    userid?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    userid?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    userid?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    userid?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: Enumerable<AdminOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: Enumerable<AdminOrderByWithAggregationInput>
    by: AdminScalarFieldEnum[]
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }


  export type AdminGroupByOutputType = {
    id: number
    userid: number | null
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    users?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    userid?: boolean
  }

  export type AdminInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    users?: boolean | UserArgs<ExtArgs>
  }


  type AdminGetPayload<S extends boolean | null | undefined | AdminArgs> = $Types.GetResult<AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AdminFindManyArgs, 'select' | 'include'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdminFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Admin'> extends True ? Prisma__AdminClient<$Types.GetResult<AdminPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__AdminClient<$Types.GetResult<AdminPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Admin that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AdminClient<$Types.GetResult<AdminPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdminFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Admin'> extends True ? Prisma__AdminClient<$Types.GetResult<AdminPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__AdminClient<$Types.GetResult<AdminPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Admin that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AdminClient<$Types.GetResult<AdminPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdminFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<AdminPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
    **/
    create<T extends AdminCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminCreateArgs<ExtArgs>>
    ): Prisma__AdminClient<$Types.GetResult<AdminPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Admins.
     *     @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     *     @example
     *     // Create many Admins
     *     const admin = await prisma.admin.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdminCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
    **/
    delete<T extends AdminDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>
    ): Prisma__AdminClient<$Types.GetResult<AdminPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdminUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>
    ): Prisma__AdminClient<$Types.GetResult<AdminPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdminDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdminUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
    **/
    upsert<T extends AdminUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>
    ): Prisma__AdminClient<$Types.GetResult<AdminPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    users<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Admin base type for findUnique actions
   */
  export type AdminFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUnique
   */
  export interface AdminFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AdminFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin base type for findFirst actions
   */
  export type AdminFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: Enumerable<AdminOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: Enumerable<AdminScalarFieldEnum>
  }

  /**
   * Admin findFirst
   */
  export interface AdminFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AdminFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: Enumerable<AdminOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: Enumerable<AdminScalarFieldEnum>
  }


  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: Enumerable<AdminOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: Enumerable<AdminScalarFieldEnum>
  }


  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data?: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }


  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: Enumerable<AdminCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
  }


  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }


  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
  }


  /**
   * Admin without action
   */
  export type AdminArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdminInclude<ExtArgs> | null
  }



  /**
   * Model Drug
   */


  export type AggregateDrug = {
    _count: DrugCountAggregateOutputType | null
    _avg: DrugAvgAggregateOutputType | null
    _sum: DrugSumAggregateOutputType | null
    _min: DrugMinAggregateOutputType | null
    _max: DrugMaxAggregateOutputType | null
  }

  export type DrugAvgAggregateOutputType = {
    id: number | null
  }

  export type DrugSumAggregateOutputType = {
    id: number | null
  }

  export type DrugMinAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    formulation: string | null
    dosageunit: string | null
  }

  export type DrugMaxAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    formulation: string | null
    dosageunit: string | null
  }

  export type DrugCountAggregateOutputType = {
    id: number
    name: number
    code: number
    formulation: number
    dosageunit: number
    _all: number
  }


  export type DrugAvgAggregateInputType = {
    id?: true
  }

  export type DrugSumAggregateInputType = {
    id?: true
  }

  export type DrugMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    formulation?: true
    dosageunit?: true
  }

  export type DrugMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    formulation?: true
    dosageunit?: true
  }

  export type DrugCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    formulation?: true
    dosageunit?: true
    _all?: true
  }

  export type DrugAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Drug to aggregate.
     */
    where?: DrugWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drugs to fetch.
     */
    orderBy?: Enumerable<DrugOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DrugWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drugs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drugs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Drugs
    **/
    _count?: true | DrugCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DrugAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DrugSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DrugMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DrugMaxAggregateInputType
  }

  export type GetDrugAggregateType<T extends DrugAggregateArgs> = {
        [P in keyof T & keyof AggregateDrug]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDrug[P]>
      : GetScalarType<T[P], AggregateDrug[P]>
  }




  export type DrugGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DrugWhereInput
    orderBy?: Enumerable<DrugOrderByWithAggregationInput>
    by: DrugScalarFieldEnum[]
    having?: DrugScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DrugCountAggregateInputType | true
    _avg?: DrugAvgAggregateInputType
    _sum?: DrugSumAggregateInputType
    _min?: DrugMinAggregateInputType
    _max?: DrugMaxAggregateInputType
  }


  export type DrugGroupByOutputType = {
    id: number
    name: string
    code: string
    formulation: string
    dosageunit: string
    _count: DrugCountAggregateOutputType | null
    _avg: DrugAvgAggregateOutputType | null
    _sum: DrugSumAggregateOutputType | null
    _min: DrugMinAggregateOutputType | null
    _max: DrugMaxAggregateOutputType | null
  }

  type GetDrugGroupByPayload<T extends DrugGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DrugGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DrugGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DrugGroupByOutputType[P]>
            : GetScalarType<T[P], DrugGroupByOutputType[P]>
        }
      >
    >


  export type DrugSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    formulation?: boolean
    dosageunit?: boolean
    drugbatch?: boolean | Drug$drugbatchArgs<ExtArgs>
    prescription?: boolean | Drug$prescriptionArgs<ExtArgs>
    _count?: boolean | DrugCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["drug"]>

  export type DrugSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    formulation?: boolean
    dosageunit?: boolean
  }

  export type DrugInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    drugbatch?: boolean | Drug$drugbatchArgs<ExtArgs>
    prescription?: boolean | Drug$prescriptionArgs<ExtArgs>
    _count?: boolean | DrugCountOutputTypeArgs<ExtArgs>
  }


  type DrugGetPayload<S extends boolean | null | undefined | DrugArgs> = $Types.GetResult<DrugPayload, S>

  type DrugCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DrugFindManyArgs, 'select' | 'include'> & {
      select?: DrugCountAggregateInputType | true
    }

  export interface DrugDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Drug'], meta: { name: 'Drug' } }
    /**
     * Find zero or one Drug that matches the filter.
     * @param {DrugFindUniqueArgs} args - Arguments to find a Drug
     * @example
     * // Get one Drug
     * const drug = await prisma.drug.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DrugFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DrugFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Drug'> extends True ? Prisma__DrugClient<$Types.GetResult<DrugPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__DrugClient<$Types.GetResult<DrugPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Drug that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DrugFindUniqueOrThrowArgs} args - Arguments to find a Drug
     * @example
     * // Get one Drug
     * const drug = await prisma.drug.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DrugFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DrugFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DrugClient<$Types.GetResult<DrugPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Drug that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugFindFirstArgs} args - Arguments to find a Drug
     * @example
     * // Get one Drug
     * const drug = await prisma.drug.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DrugFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DrugFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Drug'> extends True ? Prisma__DrugClient<$Types.GetResult<DrugPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__DrugClient<$Types.GetResult<DrugPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Drug that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugFindFirstOrThrowArgs} args - Arguments to find a Drug
     * @example
     * // Get one Drug
     * const drug = await prisma.drug.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DrugFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DrugFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DrugClient<$Types.GetResult<DrugPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Drugs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drugs
     * const drugs = await prisma.drug.findMany()
     * 
     * // Get first 10 Drugs
     * const drugs = await prisma.drug.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const drugWithIdOnly = await prisma.drug.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DrugFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DrugFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<DrugPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Drug.
     * @param {DrugCreateArgs} args - Arguments to create a Drug.
     * @example
     * // Create one Drug
     * const Drug = await prisma.drug.create({
     *   data: {
     *     // ... data to create a Drug
     *   }
     * })
     * 
    **/
    create<T extends DrugCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DrugCreateArgs<ExtArgs>>
    ): Prisma__DrugClient<$Types.GetResult<DrugPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Drugs.
     *     @param {DrugCreateManyArgs} args - Arguments to create many Drugs.
     *     @example
     *     // Create many Drugs
     *     const drug = await prisma.drug.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DrugCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DrugCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Drug.
     * @param {DrugDeleteArgs} args - Arguments to delete one Drug.
     * @example
     * // Delete one Drug
     * const Drug = await prisma.drug.delete({
     *   where: {
     *     // ... filter to delete one Drug
     *   }
     * })
     * 
    **/
    delete<T extends DrugDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DrugDeleteArgs<ExtArgs>>
    ): Prisma__DrugClient<$Types.GetResult<DrugPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Drug.
     * @param {DrugUpdateArgs} args - Arguments to update one Drug.
     * @example
     * // Update one Drug
     * const drug = await prisma.drug.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DrugUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DrugUpdateArgs<ExtArgs>>
    ): Prisma__DrugClient<$Types.GetResult<DrugPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Drugs.
     * @param {DrugDeleteManyArgs} args - Arguments to filter Drugs to delete.
     * @example
     * // Delete a few Drugs
     * const { count } = await prisma.drug.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DrugDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DrugDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drugs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drugs
     * const drug = await prisma.drug.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DrugUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DrugUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Drug.
     * @param {DrugUpsertArgs} args - Arguments to update or create a Drug.
     * @example
     * // Update or create a Drug
     * const drug = await prisma.drug.upsert({
     *   create: {
     *     // ... data to create a Drug
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Drug we want to update
     *   }
     * })
    **/
    upsert<T extends DrugUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DrugUpsertArgs<ExtArgs>>
    ): Prisma__DrugClient<$Types.GetResult<DrugPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Drugs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugCountArgs} args - Arguments to filter Drugs to count.
     * @example
     * // Count the number of Drugs
     * const count = await prisma.drug.count({
     *   where: {
     *     // ... the filter for the Drugs we want to count
     *   }
     * })
    **/
    count<T extends DrugCountArgs>(
      args?: Subset<T, DrugCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DrugCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Drug.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DrugAggregateArgs>(args: Subset<T, DrugAggregateArgs>): Prisma.PrismaPromise<GetDrugAggregateType<T>>

    /**
     * Group by Drug.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DrugGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DrugGroupByArgs['orderBy'] }
        : { orderBy?: DrugGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DrugGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDrugGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Drug.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DrugClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    drugbatch<T extends Drug$drugbatchArgs<ExtArgs> = {}>(args?: Subset<T, Drug$drugbatchArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DrugBatchPayload<ExtArgs>, T, 'findMany', never>| Null>;

    prescription<T extends Drug$prescriptionArgs<ExtArgs> = {}>(args?: Subset<T, Drug$prescriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PrescriptionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Drug base type for findUnique actions
   */
  export type DrugFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drug
     */
    select?: DrugSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DrugInclude<ExtArgs> | null
    /**
     * Filter, which Drug to fetch.
     */
    where: DrugWhereUniqueInput
  }

  /**
   * Drug findUnique
   */
  export interface DrugFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DrugFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Drug findUniqueOrThrow
   */
  export type DrugFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drug
     */
    select?: DrugSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DrugInclude<ExtArgs> | null
    /**
     * Filter, which Drug to fetch.
     */
    where: DrugWhereUniqueInput
  }


  /**
   * Drug base type for findFirst actions
   */
  export type DrugFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drug
     */
    select?: DrugSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DrugInclude<ExtArgs> | null
    /**
     * Filter, which Drug to fetch.
     */
    where?: DrugWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drugs to fetch.
     */
    orderBy?: Enumerable<DrugOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drugs.
     */
    cursor?: DrugWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drugs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drugs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drugs.
     */
    distinct?: Enumerable<DrugScalarFieldEnum>
  }

  /**
   * Drug findFirst
   */
  export interface DrugFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DrugFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Drug findFirstOrThrow
   */
  export type DrugFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drug
     */
    select?: DrugSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DrugInclude<ExtArgs> | null
    /**
     * Filter, which Drug to fetch.
     */
    where?: DrugWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drugs to fetch.
     */
    orderBy?: Enumerable<DrugOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drugs.
     */
    cursor?: DrugWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drugs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drugs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drugs.
     */
    distinct?: Enumerable<DrugScalarFieldEnum>
  }


  /**
   * Drug findMany
   */
  export type DrugFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drug
     */
    select?: DrugSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DrugInclude<ExtArgs> | null
    /**
     * Filter, which Drugs to fetch.
     */
    where?: DrugWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drugs to fetch.
     */
    orderBy?: Enumerable<DrugOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Drugs.
     */
    cursor?: DrugWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drugs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drugs.
     */
    skip?: number
    distinct?: Enumerable<DrugScalarFieldEnum>
  }


  /**
   * Drug create
   */
  export type DrugCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drug
     */
    select?: DrugSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DrugInclude<ExtArgs> | null
    /**
     * The data needed to create a Drug.
     */
    data: XOR<DrugCreateInput, DrugUncheckedCreateInput>
  }


  /**
   * Drug createMany
   */
  export type DrugCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Drugs.
     */
    data: Enumerable<DrugCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Drug update
   */
  export type DrugUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drug
     */
    select?: DrugSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DrugInclude<ExtArgs> | null
    /**
     * The data needed to update a Drug.
     */
    data: XOR<DrugUpdateInput, DrugUncheckedUpdateInput>
    /**
     * Choose, which Drug to update.
     */
    where: DrugWhereUniqueInput
  }


  /**
   * Drug updateMany
   */
  export type DrugUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Drugs.
     */
    data: XOR<DrugUpdateManyMutationInput, DrugUncheckedUpdateManyInput>
    /**
     * Filter which Drugs to update
     */
    where?: DrugWhereInput
  }


  /**
   * Drug upsert
   */
  export type DrugUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drug
     */
    select?: DrugSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DrugInclude<ExtArgs> | null
    /**
     * The filter to search for the Drug to update in case it exists.
     */
    where: DrugWhereUniqueInput
    /**
     * In case the Drug found by the `where` argument doesn't exist, create a new Drug with this data.
     */
    create: XOR<DrugCreateInput, DrugUncheckedCreateInput>
    /**
     * In case the Drug was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DrugUpdateInput, DrugUncheckedUpdateInput>
  }


  /**
   * Drug delete
   */
  export type DrugDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drug
     */
    select?: DrugSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DrugInclude<ExtArgs> | null
    /**
     * Filter which Drug to delete.
     */
    where: DrugWhereUniqueInput
  }


  /**
   * Drug deleteMany
   */
  export type DrugDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Drugs to delete
     */
    where?: DrugWhereInput
  }


  /**
   * Drug.drugbatch
   */
  export type Drug$drugbatchArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugBatch
     */
    select?: DrugBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DrugBatchInclude<ExtArgs> | null
    where?: DrugBatchWhereInput
    orderBy?: Enumerable<DrugBatchOrderByWithRelationInput>
    cursor?: DrugBatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DrugBatchScalarFieldEnum>
  }


  /**
   * Drug.prescription
   */
  export type Drug$prescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PrescriptionInclude<ExtArgs> | null
    where?: PrescriptionWhereInput
    orderBy?: Enumerable<PrescriptionOrderByWithRelationInput>
    cursor?: PrescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PrescriptionScalarFieldEnum>
  }


  /**
   * Drug without action
   */
  export type DrugArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drug
     */
    select?: DrugSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DrugInclude<ExtArgs> | null
  }



  /**
   * Model Prescription
   */


  export type AggregatePrescription = {
    _count: PrescriptionCountAggregateOutputType | null
    _avg: PrescriptionAvgAggregateOutputType | null
    _sum: PrescriptionSumAggregateOutputType | null
    _min: PrescriptionMinAggregateOutputType | null
    _max: PrescriptionMaxAggregateOutputType | null
  }

  export type PrescriptionAvgAggregateOutputType = {
    id: number | null
    patientid: number | null
    doctorid: number | null
    drugid: number | null
  }

  export type PrescriptionSumAggregateOutputType = {
    id: number | null
    patientid: number | null
    doctorid: number | null
    drugid: number | null
  }

  export type PrescriptionMinAggregateOutputType = {
    id: number | null
    patientid: number | null
    doctorid: number | null
    drugid: number | null
    dosage: string | null
    issuedat: Date | null
    expiresat: Date | null
    blockchaintx: string | null
    qrcode: string | null
    ipfshash: string | null
    status: string | null
  }

  export type PrescriptionMaxAggregateOutputType = {
    id: number | null
    patientid: number | null
    doctorid: number | null
    drugid: number | null
    dosage: string | null
    issuedat: Date | null
    expiresat: Date | null
    blockchaintx: string | null
    qrcode: string | null
    ipfshash: string | null
    status: string | null
  }

  export type PrescriptionCountAggregateOutputType = {
    id: number
    patientid: number
    doctorid: number
    drugid: number
    dosage: number
    issuedat: number
    expiresat: number
    blockchaintx: number
    qrcode: number
    ipfshash: number
    status: number
    _all: number
  }


  export type PrescriptionAvgAggregateInputType = {
    id?: true
    patientid?: true
    doctorid?: true
    drugid?: true
  }

  export type PrescriptionSumAggregateInputType = {
    id?: true
    patientid?: true
    doctorid?: true
    drugid?: true
  }

  export type PrescriptionMinAggregateInputType = {
    id?: true
    patientid?: true
    doctorid?: true
    drugid?: true
    dosage?: true
    issuedat?: true
    expiresat?: true
    blockchaintx?: true
    qrcode?: true
    ipfshash?: true
    status?: true
  }

  export type PrescriptionMaxAggregateInputType = {
    id?: true
    patientid?: true
    doctorid?: true
    drugid?: true
    dosage?: true
    issuedat?: true
    expiresat?: true
    blockchaintx?: true
    qrcode?: true
    ipfshash?: true
    status?: true
  }

  export type PrescriptionCountAggregateInputType = {
    id?: true
    patientid?: true
    doctorid?: true
    drugid?: true
    dosage?: true
    issuedat?: true
    expiresat?: true
    blockchaintx?: true
    qrcode?: true
    ipfshash?: true
    status?: true
    _all?: true
  }

  export type PrescriptionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prescription to aggregate.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: Enumerable<PrescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prescriptions
    **/
    _count?: true | PrescriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrescriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrescriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrescriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrescriptionMaxAggregateInputType
  }

  export type GetPrescriptionAggregateType<T extends PrescriptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePrescription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrescription[P]>
      : GetScalarType<T[P], AggregatePrescription[P]>
  }




  export type PrescriptionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
    orderBy?: Enumerable<PrescriptionOrderByWithAggregationInput>
    by: PrescriptionScalarFieldEnum[]
    having?: PrescriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrescriptionCountAggregateInputType | true
    _avg?: PrescriptionAvgAggregateInputType
    _sum?: PrescriptionSumAggregateInputType
    _min?: PrescriptionMinAggregateInputType
    _max?: PrescriptionMaxAggregateInputType
  }


  export type PrescriptionGroupByOutputType = {
    id: number
    patientid: number | null
    doctorid: number | null
    drugid: number | null
    dosage: string
    issuedat: Date | null
    expiresat: Date
    blockchaintx: string | null
    qrcode: string
    ipfshash: string | null
    status: string
    _count: PrescriptionCountAggregateOutputType | null
    _avg: PrescriptionAvgAggregateOutputType | null
    _sum: PrescriptionSumAggregateOutputType | null
    _min: PrescriptionMinAggregateOutputType | null
    _max: PrescriptionMaxAggregateOutputType | null
  }

  type GetPrescriptionGroupByPayload<T extends PrescriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PrescriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrescriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrescriptionGroupByOutputType[P]>
            : GetScalarType<T[P], PrescriptionGroupByOutputType[P]>
        }
      >
    >


  export type PrescriptionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientid?: boolean
    doctorid?: boolean
    drugid?: boolean
    dosage?: boolean
    issuedat?: boolean
    expiresat?: boolean
    blockchaintx?: boolean
    qrcode?: boolean
    ipfshash?: boolean
    status?: boolean
    blockchaineventlog?: boolean | Prescription$blockchaineventlogArgs<ExtArgs>
    dispenserecord?: boolean | Prescription$dispenserecordArgs<ExtArgs>
    doctor?: boolean | DoctorArgs<ExtArgs>
    drug?: boolean | DrugArgs<ExtArgs>
    patient?: boolean | PatientArgs<ExtArgs>
    _count?: boolean | PrescriptionCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectScalar = {
    id?: boolean
    patientid?: boolean
    doctorid?: boolean
    drugid?: boolean
    dosage?: boolean
    issuedat?: boolean
    expiresat?: boolean
    blockchaintx?: boolean
    qrcode?: boolean
    ipfshash?: boolean
    status?: boolean
  }

  export type PrescriptionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    blockchaineventlog?: boolean | Prescription$blockchaineventlogArgs<ExtArgs>
    dispenserecord?: boolean | Prescription$dispenserecordArgs<ExtArgs>
    doctor?: boolean | DoctorArgs<ExtArgs>
    drug?: boolean | DrugArgs<ExtArgs>
    patient?: boolean | PatientArgs<ExtArgs>
    _count?: boolean | PrescriptionCountOutputTypeArgs<ExtArgs>
  }


  type PrescriptionGetPayload<S extends boolean | null | undefined | PrescriptionArgs> = $Types.GetResult<PrescriptionPayload, S>

  type PrescriptionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PrescriptionFindManyArgs, 'select' | 'include'> & {
      select?: PrescriptionCountAggregateInputType | true
    }

  export interface PrescriptionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prescription'], meta: { name: 'Prescription' } }
    /**
     * Find zero or one Prescription that matches the filter.
     * @param {PrescriptionFindUniqueArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PrescriptionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PrescriptionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Prescription'> extends True ? Prisma__PrescriptionClient<$Types.GetResult<PrescriptionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__PrescriptionClient<$Types.GetResult<PrescriptionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Prescription that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PrescriptionFindUniqueOrThrowArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PrescriptionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PrescriptionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PrescriptionClient<$Types.GetResult<PrescriptionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Prescription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindFirstArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PrescriptionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PrescriptionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Prescription'> extends True ? Prisma__PrescriptionClient<$Types.GetResult<PrescriptionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__PrescriptionClient<$Types.GetResult<PrescriptionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Prescription that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindFirstOrThrowArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PrescriptionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PrescriptionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PrescriptionClient<$Types.GetResult<PrescriptionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Prescriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prescriptions
     * const prescriptions = await prisma.prescription.findMany()
     * 
     * // Get first 10 Prescriptions
     * const prescriptions = await prisma.prescription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PrescriptionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PrescriptionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PrescriptionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Prescription.
     * @param {PrescriptionCreateArgs} args - Arguments to create a Prescription.
     * @example
     * // Create one Prescription
     * const Prescription = await prisma.prescription.create({
     *   data: {
     *     // ... data to create a Prescription
     *   }
     * })
     * 
    **/
    create<T extends PrescriptionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PrescriptionCreateArgs<ExtArgs>>
    ): Prisma__PrescriptionClient<$Types.GetResult<PrescriptionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Prescriptions.
     *     @param {PrescriptionCreateManyArgs} args - Arguments to create many Prescriptions.
     *     @example
     *     // Create many Prescriptions
     *     const prescription = await prisma.prescription.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PrescriptionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PrescriptionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Prescription.
     * @param {PrescriptionDeleteArgs} args - Arguments to delete one Prescription.
     * @example
     * // Delete one Prescription
     * const Prescription = await prisma.prescription.delete({
     *   where: {
     *     // ... filter to delete one Prescription
     *   }
     * })
     * 
    **/
    delete<T extends PrescriptionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PrescriptionDeleteArgs<ExtArgs>>
    ): Prisma__PrescriptionClient<$Types.GetResult<PrescriptionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Prescription.
     * @param {PrescriptionUpdateArgs} args - Arguments to update one Prescription.
     * @example
     * // Update one Prescription
     * const prescription = await prisma.prescription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PrescriptionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PrescriptionUpdateArgs<ExtArgs>>
    ): Prisma__PrescriptionClient<$Types.GetResult<PrescriptionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Prescriptions.
     * @param {PrescriptionDeleteManyArgs} args - Arguments to filter Prescriptions to delete.
     * @example
     * // Delete a few Prescriptions
     * const { count } = await prisma.prescription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PrescriptionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PrescriptionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prescriptions
     * const prescription = await prisma.prescription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PrescriptionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PrescriptionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prescription.
     * @param {PrescriptionUpsertArgs} args - Arguments to update or create a Prescription.
     * @example
     * // Update or create a Prescription
     * const prescription = await prisma.prescription.upsert({
     *   create: {
     *     // ... data to create a Prescription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prescription we want to update
     *   }
     * })
    **/
    upsert<T extends PrescriptionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PrescriptionUpsertArgs<ExtArgs>>
    ): Prisma__PrescriptionClient<$Types.GetResult<PrescriptionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionCountArgs} args - Arguments to filter Prescriptions to count.
     * @example
     * // Count the number of Prescriptions
     * const count = await prisma.prescription.count({
     *   where: {
     *     // ... the filter for the Prescriptions we want to count
     *   }
     * })
    **/
    count<T extends PrescriptionCountArgs>(
      args?: Subset<T, PrescriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrescriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrescriptionAggregateArgs>(args: Subset<T, PrescriptionAggregateArgs>): Prisma.PrismaPromise<GetPrescriptionAggregateType<T>>

    /**
     * Group by Prescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrescriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrescriptionGroupByArgs['orderBy'] }
        : { orderBy?: PrescriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrescriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrescriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Prescription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PrescriptionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    blockchaineventlog<T extends Prescription$blockchaineventlogArgs<ExtArgs> = {}>(args?: Subset<T, Prescription$blockchaineventlogArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<BlockchainEventLogPayload<ExtArgs>, T, 'findMany', never>| Null>;

    dispenserecord<T extends Prescription$dispenserecordArgs<ExtArgs> = {}>(args?: Subset<T, Prescription$dispenserecordArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DispenseRecordPayload<ExtArgs>, T, 'findMany', never>| Null>;

    doctor<T extends DoctorArgs<ExtArgs> = {}>(args?: Subset<T, DoctorArgs<ExtArgs>>): Prisma__DoctorClient<$Types.GetResult<DoctorPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    drug<T extends DrugArgs<ExtArgs> = {}>(args?: Subset<T, DrugArgs<ExtArgs>>): Prisma__DrugClient<$Types.GetResult<DrugPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    patient<T extends PatientArgs<ExtArgs> = {}>(args?: Subset<T, PatientArgs<ExtArgs>>): Prisma__PatientClient<$Types.GetResult<PatientPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Prescription base type for findUnique actions
   */
  export type PrescriptionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription findUnique
   */
  export interface PrescriptionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PrescriptionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Prescription findUniqueOrThrow
   */
  export type PrescriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where: PrescriptionWhereUniqueInput
  }


  /**
   * Prescription base type for findFirst actions
   */
  export type PrescriptionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: Enumerable<PrescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prescriptions.
     */
    distinct?: Enumerable<PrescriptionScalarFieldEnum>
  }

  /**
   * Prescription findFirst
   */
  export interface PrescriptionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PrescriptionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Prescription findFirstOrThrow
   */
  export type PrescriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: Enumerable<PrescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prescriptions.
     */
    distinct?: Enumerable<PrescriptionScalarFieldEnum>
  }


  /**
   * Prescription findMany
   */
  export type PrescriptionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescriptions to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: Enumerable<PrescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    distinct?: Enumerable<PrescriptionScalarFieldEnum>
  }


  /**
   * Prescription create
   */
  export type PrescriptionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Prescription.
     */
    data: XOR<PrescriptionCreateInput, PrescriptionUncheckedCreateInput>
  }


  /**
   * Prescription createMany
   */
  export type PrescriptionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prescriptions.
     */
    data: Enumerable<PrescriptionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Prescription update
   */
  export type PrescriptionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Prescription.
     */
    data: XOR<PrescriptionUpdateInput, PrescriptionUncheckedUpdateInput>
    /**
     * Choose, which Prescription to update.
     */
    where: PrescriptionWhereUniqueInput
  }


  /**
   * Prescription updateMany
   */
  export type PrescriptionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prescriptions.
     */
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyInput>
    /**
     * Filter which Prescriptions to update
     */
    where?: PrescriptionWhereInput
  }


  /**
   * Prescription upsert
   */
  export type PrescriptionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Prescription to update in case it exists.
     */
    where: PrescriptionWhereUniqueInput
    /**
     * In case the Prescription found by the `where` argument doesn't exist, create a new Prescription with this data.
     */
    create: XOR<PrescriptionCreateInput, PrescriptionUncheckedCreateInput>
    /**
     * In case the Prescription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrescriptionUpdateInput, PrescriptionUncheckedUpdateInput>
  }


  /**
   * Prescription delete
   */
  export type PrescriptionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter which Prescription to delete.
     */
    where: PrescriptionWhereUniqueInput
  }


  /**
   * Prescription deleteMany
   */
  export type PrescriptionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prescriptions to delete
     */
    where?: PrescriptionWhereInput
  }


  /**
   * Prescription.blockchaineventlog
   */
  export type Prescription$blockchaineventlogArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainEventLog
     */
    select?: BlockchainEventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockchainEventLogInclude<ExtArgs> | null
    where?: BlockchainEventLogWhereInput
    orderBy?: Enumerable<BlockchainEventLogOrderByWithRelationInput>
    cursor?: BlockchainEventLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BlockchainEventLogScalarFieldEnum>
  }


  /**
   * Prescription.dispenserecord
   */
  export type Prescription$dispenserecordArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispenseRecord
     */
    select?: DispenseRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DispenseRecordInclude<ExtArgs> | null
    where?: DispenseRecordWhereInput
    orderBy?: Enumerable<DispenseRecordOrderByWithRelationInput>
    cursor?: DispenseRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DispenseRecordScalarFieldEnum>
  }


  /**
   * Prescription without action
   */
  export type PrescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PrescriptionInclude<ExtArgs> | null
  }



  /**
   * Model DrugBatch
   */


  export type AggregateDrugBatch = {
    _count: DrugBatchCountAggregateOutputType | null
    _avg: DrugBatchAvgAggregateOutputType | null
    _sum: DrugBatchSumAggregateOutputType | null
    _min: DrugBatchMinAggregateOutputType | null
    _max: DrugBatchMaxAggregateOutputType | null
  }

  export type DrugBatchAvgAggregateOutputType = {
    id: number | null
    manufacturerid: number | null
    drugid: number | null
  }

  export type DrugBatchSumAggregateOutputType = {
    id: number | null
    manufacturerid: number | null
    drugid: number | null
  }

  export type DrugBatchMinAggregateOutputType = {
    id: number | null
    manufacturerid: number | null
    drugid: number | null
    batchnumber: string | null
    manufacturedate: Date | null
    expirydate: Date | null
    blockchaintx: string | null
    qrcode: string | null
    ipfshash: string | null
  }

  export type DrugBatchMaxAggregateOutputType = {
    id: number | null
    manufacturerid: number | null
    drugid: number | null
    batchnumber: string | null
    manufacturedate: Date | null
    expirydate: Date | null
    blockchaintx: string | null
    qrcode: string | null
    ipfshash: string | null
  }

  export type DrugBatchCountAggregateOutputType = {
    id: number
    manufacturerid: number
    drugid: number
    batchnumber: number
    manufacturedate: number
    expirydate: number
    blockchaintx: number
    qrcode: number
    ipfshash: number
    _all: number
  }


  export type DrugBatchAvgAggregateInputType = {
    id?: true
    manufacturerid?: true
    drugid?: true
  }

  export type DrugBatchSumAggregateInputType = {
    id?: true
    manufacturerid?: true
    drugid?: true
  }

  export type DrugBatchMinAggregateInputType = {
    id?: true
    manufacturerid?: true
    drugid?: true
    batchnumber?: true
    manufacturedate?: true
    expirydate?: true
    blockchaintx?: true
    qrcode?: true
    ipfshash?: true
  }

  export type DrugBatchMaxAggregateInputType = {
    id?: true
    manufacturerid?: true
    drugid?: true
    batchnumber?: true
    manufacturedate?: true
    expirydate?: true
    blockchaintx?: true
    qrcode?: true
    ipfshash?: true
  }

  export type DrugBatchCountAggregateInputType = {
    id?: true
    manufacturerid?: true
    drugid?: true
    batchnumber?: true
    manufacturedate?: true
    expirydate?: true
    blockchaintx?: true
    qrcode?: true
    ipfshash?: true
    _all?: true
  }

  export type DrugBatchAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DrugBatch to aggregate.
     */
    where?: DrugBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DrugBatches to fetch.
     */
    orderBy?: Enumerable<DrugBatchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DrugBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DrugBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DrugBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DrugBatches
    **/
    _count?: true | DrugBatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DrugBatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DrugBatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DrugBatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DrugBatchMaxAggregateInputType
  }

  export type GetDrugBatchAggregateType<T extends DrugBatchAggregateArgs> = {
        [P in keyof T & keyof AggregateDrugBatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDrugBatch[P]>
      : GetScalarType<T[P], AggregateDrugBatch[P]>
  }




  export type DrugBatchGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DrugBatchWhereInput
    orderBy?: Enumerable<DrugBatchOrderByWithAggregationInput>
    by: DrugBatchScalarFieldEnum[]
    having?: DrugBatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DrugBatchCountAggregateInputType | true
    _avg?: DrugBatchAvgAggregateInputType
    _sum?: DrugBatchSumAggregateInputType
    _min?: DrugBatchMinAggregateInputType
    _max?: DrugBatchMaxAggregateInputType
  }


  export type DrugBatchGroupByOutputType = {
    id: number
    manufacturerid: number | null
    drugid: number | null
    batchnumber: string
    manufacturedate: Date
    expirydate: Date
    blockchaintx: string | null
    qrcode: string
    ipfshash: string | null
    _count: DrugBatchCountAggregateOutputType | null
    _avg: DrugBatchAvgAggregateOutputType | null
    _sum: DrugBatchSumAggregateOutputType | null
    _min: DrugBatchMinAggregateOutputType | null
    _max: DrugBatchMaxAggregateOutputType | null
  }

  type GetDrugBatchGroupByPayload<T extends DrugBatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DrugBatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DrugBatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DrugBatchGroupByOutputType[P]>
            : GetScalarType<T[P], DrugBatchGroupByOutputType[P]>
        }
      >
    >


  export type DrugBatchSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    manufacturerid?: boolean
    drugid?: boolean
    batchnumber?: boolean
    manufacturedate?: boolean
    expirydate?: boolean
    blockchaintx?: boolean
    qrcode?: boolean
    ipfshash?: boolean
    blockchaineventlog?: boolean | DrugBatch$blockchaineventlogArgs<ExtArgs>
    dispenserecord?: boolean | DrugBatch$dispenserecordArgs<ExtArgs>
    drug?: boolean | DrugArgs<ExtArgs>
    manufacturer?: boolean | ManufacturerArgs<ExtArgs>
    supplychainrecord?: boolean | DrugBatch$supplychainrecordArgs<ExtArgs>
    _count?: boolean | DrugBatchCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["drugBatch"]>

  export type DrugBatchSelectScalar = {
    id?: boolean
    manufacturerid?: boolean
    drugid?: boolean
    batchnumber?: boolean
    manufacturedate?: boolean
    expirydate?: boolean
    blockchaintx?: boolean
    qrcode?: boolean
    ipfshash?: boolean
  }

  export type DrugBatchInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    blockchaineventlog?: boolean | DrugBatch$blockchaineventlogArgs<ExtArgs>
    dispenserecord?: boolean | DrugBatch$dispenserecordArgs<ExtArgs>
    drug?: boolean | DrugArgs<ExtArgs>
    manufacturer?: boolean | ManufacturerArgs<ExtArgs>
    supplychainrecord?: boolean | DrugBatch$supplychainrecordArgs<ExtArgs>
    _count?: boolean | DrugBatchCountOutputTypeArgs<ExtArgs>
  }


  type DrugBatchGetPayload<S extends boolean | null | undefined | DrugBatchArgs> = $Types.GetResult<DrugBatchPayload, S>

  type DrugBatchCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DrugBatchFindManyArgs, 'select' | 'include'> & {
      select?: DrugBatchCountAggregateInputType | true
    }

  export interface DrugBatchDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DrugBatch'], meta: { name: 'DrugBatch' } }
    /**
     * Find zero or one DrugBatch that matches the filter.
     * @param {DrugBatchFindUniqueArgs} args - Arguments to find a DrugBatch
     * @example
     * // Get one DrugBatch
     * const drugBatch = await prisma.drugBatch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DrugBatchFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DrugBatchFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DrugBatch'> extends True ? Prisma__DrugBatchClient<$Types.GetResult<DrugBatchPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__DrugBatchClient<$Types.GetResult<DrugBatchPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one DrugBatch that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DrugBatchFindUniqueOrThrowArgs} args - Arguments to find a DrugBatch
     * @example
     * // Get one DrugBatch
     * const drugBatch = await prisma.drugBatch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DrugBatchFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DrugBatchFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DrugBatchClient<$Types.GetResult<DrugBatchPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first DrugBatch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugBatchFindFirstArgs} args - Arguments to find a DrugBatch
     * @example
     * // Get one DrugBatch
     * const drugBatch = await prisma.drugBatch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DrugBatchFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DrugBatchFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DrugBatch'> extends True ? Prisma__DrugBatchClient<$Types.GetResult<DrugBatchPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__DrugBatchClient<$Types.GetResult<DrugBatchPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first DrugBatch that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugBatchFindFirstOrThrowArgs} args - Arguments to find a DrugBatch
     * @example
     * // Get one DrugBatch
     * const drugBatch = await prisma.drugBatch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DrugBatchFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DrugBatchFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DrugBatchClient<$Types.GetResult<DrugBatchPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more DrugBatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugBatchFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DrugBatches
     * const drugBatches = await prisma.drugBatch.findMany()
     * 
     * // Get first 10 DrugBatches
     * const drugBatches = await prisma.drugBatch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const drugBatchWithIdOnly = await prisma.drugBatch.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DrugBatchFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DrugBatchFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<DrugBatchPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a DrugBatch.
     * @param {DrugBatchCreateArgs} args - Arguments to create a DrugBatch.
     * @example
     * // Create one DrugBatch
     * const DrugBatch = await prisma.drugBatch.create({
     *   data: {
     *     // ... data to create a DrugBatch
     *   }
     * })
     * 
    **/
    create<T extends DrugBatchCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DrugBatchCreateArgs<ExtArgs>>
    ): Prisma__DrugBatchClient<$Types.GetResult<DrugBatchPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many DrugBatches.
     *     @param {DrugBatchCreateManyArgs} args - Arguments to create many DrugBatches.
     *     @example
     *     // Create many DrugBatches
     *     const drugBatch = await prisma.drugBatch.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DrugBatchCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DrugBatchCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DrugBatch.
     * @param {DrugBatchDeleteArgs} args - Arguments to delete one DrugBatch.
     * @example
     * // Delete one DrugBatch
     * const DrugBatch = await prisma.drugBatch.delete({
     *   where: {
     *     // ... filter to delete one DrugBatch
     *   }
     * })
     * 
    **/
    delete<T extends DrugBatchDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DrugBatchDeleteArgs<ExtArgs>>
    ): Prisma__DrugBatchClient<$Types.GetResult<DrugBatchPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one DrugBatch.
     * @param {DrugBatchUpdateArgs} args - Arguments to update one DrugBatch.
     * @example
     * // Update one DrugBatch
     * const drugBatch = await prisma.drugBatch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DrugBatchUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DrugBatchUpdateArgs<ExtArgs>>
    ): Prisma__DrugBatchClient<$Types.GetResult<DrugBatchPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more DrugBatches.
     * @param {DrugBatchDeleteManyArgs} args - Arguments to filter DrugBatches to delete.
     * @example
     * // Delete a few DrugBatches
     * const { count } = await prisma.drugBatch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DrugBatchDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DrugBatchDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DrugBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugBatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DrugBatches
     * const drugBatch = await prisma.drugBatch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DrugBatchUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DrugBatchUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DrugBatch.
     * @param {DrugBatchUpsertArgs} args - Arguments to update or create a DrugBatch.
     * @example
     * // Update or create a DrugBatch
     * const drugBatch = await prisma.drugBatch.upsert({
     *   create: {
     *     // ... data to create a DrugBatch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DrugBatch we want to update
     *   }
     * })
    **/
    upsert<T extends DrugBatchUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DrugBatchUpsertArgs<ExtArgs>>
    ): Prisma__DrugBatchClient<$Types.GetResult<DrugBatchPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of DrugBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugBatchCountArgs} args - Arguments to filter DrugBatches to count.
     * @example
     * // Count the number of DrugBatches
     * const count = await prisma.drugBatch.count({
     *   where: {
     *     // ... the filter for the DrugBatches we want to count
     *   }
     * })
    **/
    count<T extends DrugBatchCountArgs>(
      args?: Subset<T, DrugBatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DrugBatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DrugBatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugBatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DrugBatchAggregateArgs>(args: Subset<T, DrugBatchAggregateArgs>): Prisma.PrismaPromise<GetDrugBatchAggregateType<T>>

    /**
     * Group by DrugBatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugBatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DrugBatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DrugBatchGroupByArgs['orderBy'] }
        : { orderBy?: DrugBatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DrugBatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDrugBatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DrugBatch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DrugBatchClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    blockchaineventlog<T extends DrugBatch$blockchaineventlogArgs<ExtArgs> = {}>(args?: Subset<T, DrugBatch$blockchaineventlogArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<BlockchainEventLogPayload<ExtArgs>, T, 'findMany', never>| Null>;

    dispenserecord<T extends DrugBatch$dispenserecordArgs<ExtArgs> = {}>(args?: Subset<T, DrugBatch$dispenserecordArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DispenseRecordPayload<ExtArgs>, T, 'findMany', never>| Null>;

    drug<T extends DrugArgs<ExtArgs> = {}>(args?: Subset<T, DrugArgs<ExtArgs>>): Prisma__DrugClient<$Types.GetResult<DrugPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    manufacturer<T extends ManufacturerArgs<ExtArgs> = {}>(args?: Subset<T, ManufacturerArgs<ExtArgs>>): Prisma__ManufacturerClient<$Types.GetResult<ManufacturerPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    supplychainrecord<T extends DrugBatch$supplychainrecordArgs<ExtArgs> = {}>(args?: Subset<T, DrugBatch$supplychainrecordArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<SupplyChainRecordPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DrugBatch base type for findUnique actions
   */
  export type DrugBatchFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugBatch
     */
    select?: DrugBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DrugBatchInclude<ExtArgs> | null
    /**
     * Filter, which DrugBatch to fetch.
     */
    where: DrugBatchWhereUniqueInput
  }

  /**
   * DrugBatch findUnique
   */
  export interface DrugBatchFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DrugBatchFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DrugBatch findUniqueOrThrow
   */
  export type DrugBatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugBatch
     */
    select?: DrugBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DrugBatchInclude<ExtArgs> | null
    /**
     * Filter, which DrugBatch to fetch.
     */
    where: DrugBatchWhereUniqueInput
  }


  /**
   * DrugBatch base type for findFirst actions
   */
  export type DrugBatchFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugBatch
     */
    select?: DrugBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DrugBatchInclude<ExtArgs> | null
    /**
     * Filter, which DrugBatch to fetch.
     */
    where?: DrugBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DrugBatches to fetch.
     */
    orderBy?: Enumerable<DrugBatchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DrugBatches.
     */
    cursor?: DrugBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DrugBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DrugBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DrugBatches.
     */
    distinct?: Enumerable<DrugBatchScalarFieldEnum>
  }

  /**
   * DrugBatch findFirst
   */
  export interface DrugBatchFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DrugBatchFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DrugBatch findFirstOrThrow
   */
  export type DrugBatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugBatch
     */
    select?: DrugBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DrugBatchInclude<ExtArgs> | null
    /**
     * Filter, which DrugBatch to fetch.
     */
    where?: DrugBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DrugBatches to fetch.
     */
    orderBy?: Enumerable<DrugBatchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DrugBatches.
     */
    cursor?: DrugBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DrugBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DrugBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DrugBatches.
     */
    distinct?: Enumerable<DrugBatchScalarFieldEnum>
  }


  /**
   * DrugBatch findMany
   */
  export type DrugBatchFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugBatch
     */
    select?: DrugBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DrugBatchInclude<ExtArgs> | null
    /**
     * Filter, which DrugBatches to fetch.
     */
    where?: DrugBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DrugBatches to fetch.
     */
    orderBy?: Enumerable<DrugBatchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DrugBatches.
     */
    cursor?: DrugBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DrugBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DrugBatches.
     */
    skip?: number
    distinct?: Enumerable<DrugBatchScalarFieldEnum>
  }


  /**
   * DrugBatch create
   */
  export type DrugBatchCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugBatch
     */
    select?: DrugBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DrugBatchInclude<ExtArgs> | null
    /**
     * The data needed to create a DrugBatch.
     */
    data: XOR<DrugBatchCreateInput, DrugBatchUncheckedCreateInput>
  }


  /**
   * DrugBatch createMany
   */
  export type DrugBatchCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DrugBatches.
     */
    data: Enumerable<DrugBatchCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DrugBatch update
   */
  export type DrugBatchUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugBatch
     */
    select?: DrugBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DrugBatchInclude<ExtArgs> | null
    /**
     * The data needed to update a DrugBatch.
     */
    data: XOR<DrugBatchUpdateInput, DrugBatchUncheckedUpdateInput>
    /**
     * Choose, which DrugBatch to update.
     */
    where: DrugBatchWhereUniqueInput
  }


  /**
   * DrugBatch updateMany
   */
  export type DrugBatchUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DrugBatches.
     */
    data: XOR<DrugBatchUpdateManyMutationInput, DrugBatchUncheckedUpdateManyInput>
    /**
     * Filter which DrugBatches to update
     */
    where?: DrugBatchWhereInput
  }


  /**
   * DrugBatch upsert
   */
  export type DrugBatchUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugBatch
     */
    select?: DrugBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DrugBatchInclude<ExtArgs> | null
    /**
     * The filter to search for the DrugBatch to update in case it exists.
     */
    where: DrugBatchWhereUniqueInput
    /**
     * In case the DrugBatch found by the `where` argument doesn't exist, create a new DrugBatch with this data.
     */
    create: XOR<DrugBatchCreateInput, DrugBatchUncheckedCreateInput>
    /**
     * In case the DrugBatch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DrugBatchUpdateInput, DrugBatchUncheckedUpdateInput>
  }


  /**
   * DrugBatch delete
   */
  export type DrugBatchDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugBatch
     */
    select?: DrugBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DrugBatchInclude<ExtArgs> | null
    /**
     * Filter which DrugBatch to delete.
     */
    where: DrugBatchWhereUniqueInput
  }


  /**
   * DrugBatch deleteMany
   */
  export type DrugBatchDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DrugBatches to delete
     */
    where?: DrugBatchWhereInput
  }


  /**
   * DrugBatch.blockchaineventlog
   */
  export type DrugBatch$blockchaineventlogArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainEventLog
     */
    select?: BlockchainEventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockchainEventLogInclude<ExtArgs> | null
    where?: BlockchainEventLogWhereInput
    orderBy?: Enumerable<BlockchainEventLogOrderByWithRelationInput>
    cursor?: BlockchainEventLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BlockchainEventLogScalarFieldEnum>
  }


  /**
   * DrugBatch.dispenserecord
   */
  export type DrugBatch$dispenserecordArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispenseRecord
     */
    select?: DispenseRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DispenseRecordInclude<ExtArgs> | null
    where?: DispenseRecordWhereInput
    orderBy?: Enumerable<DispenseRecordOrderByWithRelationInput>
    cursor?: DispenseRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DispenseRecordScalarFieldEnum>
  }


  /**
   * DrugBatch.supplychainrecord
   */
  export type DrugBatch$supplychainrecordArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplyChainRecord
     */
    select?: SupplyChainRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplyChainRecordInclude<ExtArgs> | null
    where?: SupplyChainRecordWhereInput
    orderBy?: Enumerable<SupplyChainRecordOrderByWithRelationInput>
    cursor?: SupplyChainRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SupplyChainRecordScalarFieldEnum>
  }


  /**
   * DrugBatch without action
   */
  export type DrugBatchArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugBatch
     */
    select?: DrugBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DrugBatchInclude<ExtArgs> | null
  }



  /**
   * Model SupplyChainRecord
   */


  export type AggregateSupplyChainRecord = {
    _count: SupplyChainRecordCountAggregateOutputType | null
    _avg: SupplyChainRecordAvgAggregateOutputType | null
    _sum: SupplyChainRecordSumAggregateOutputType | null
    _min: SupplyChainRecordMinAggregateOutputType | null
    _max: SupplyChainRecordMaxAggregateOutputType | null
  }

  export type SupplyChainRecordAvgAggregateOutputType = {
    id: number | null
    drugbatchid: number | null
    fromentityid: number | null
    toentityid: number | null
  }

  export type SupplyChainRecordSumAggregateOutputType = {
    id: number | null
    drugbatchid: number | null
    fromentityid: number | null
    toentityid: number | null
  }

  export type SupplyChainRecordMinAggregateOutputType = {
    id: number | null
    drugbatchid: number | null
    fromentityid: number | null
    toentityid: number | null
    action: string | null
    timestamp: Date | null
    blockchaintx: string | null
  }

  export type SupplyChainRecordMaxAggregateOutputType = {
    id: number | null
    drugbatchid: number | null
    fromentityid: number | null
    toentityid: number | null
    action: string | null
    timestamp: Date | null
    blockchaintx: string | null
  }

  export type SupplyChainRecordCountAggregateOutputType = {
    id: number
    drugbatchid: number
    fromentityid: number
    toentityid: number
    action: number
    timestamp: number
    blockchaintx: number
    _all: number
  }


  export type SupplyChainRecordAvgAggregateInputType = {
    id?: true
    drugbatchid?: true
    fromentityid?: true
    toentityid?: true
  }

  export type SupplyChainRecordSumAggregateInputType = {
    id?: true
    drugbatchid?: true
    fromentityid?: true
    toentityid?: true
  }

  export type SupplyChainRecordMinAggregateInputType = {
    id?: true
    drugbatchid?: true
    fromentityid?: true
    toentityid?: true
    action?: true
    timestamp?: true
    blockchaintx?: true
  }

  export type SupplyChainRecordMaxAggregateInputType = {
    id?: true
    drugbatchid?: true
    fromentityid?: true
    toentityid?: true
    action?: true
    timestamp?: true
    blockchaintx?: true
  }

  export type SupplyChainRecordCountAggregateInputType = {
    id?: true
    drugbatchid?: true
    fromentityid?: true
    toentityid?: true
    action?: true
    timestamp?: true
    blockchaintx?: true
    _all?: true
  }

  export type SupplyChainRecordAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplyChainRecord to aggregate.
     */
    where?: SupplyChainRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplyChainRecords to fetch.
     */
    orderBy?: Enumerable<SupplyChainRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplyChainRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplyChainRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplyChainRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupplyChainRecords
    **/
    _count?: true | SupplyChainRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplyChainRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplyChainRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplyChainRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplyChainRecordMaxAggregateInputType
  }

  export type GetSupplyChainRecordAggregateType<T extends SupplyChainRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplyChainRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplyChainRecord[P]>
      : GetScalarType<T[P], AggregateSupplyChainRecord[P]>
  }




  export type SupplyChainRecordGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SupplyChainRecordWhereInput
    orderBy?: Enumerable<SupplyChainRecordOrderByWithAggregationInput>
    by: SupplyChainRecordScalarFieldEnum[]
    having?: SupplyChainRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplyChainRecordCountAggregateInputType | true
    _avg?: SupplyChainRecordAvgAggregateInputType
    _sum?: SupplyChainRecordSumAggregateInputType
    _min?: SupplyChainRecordMinAggregateInputType
    _max?: SupplyChainRecordMaxAggregateInputType
  }


  export type SupplyChainRecordGroupByOutputType = {
    id: number
    drugbatchid: number | null
    fromentityid: number | null
    toentityid: number | null
    action: string
    timestamp: Date | null
    blockchaintx: string | null
    _count: SupplyChainRecordCountAggregateOutputType | null
    _avg: SupplyChainRecordAvgAggregateOutputType | null
    _sum: SupplyChainRecordSumAggregateOutputType | null
    _min: SupplyChainRecordMinAggregateOutputType | null
    _max: SupplyChainRecordMaxAggregateOutputType | null
  }

  type GetSupplyChainRecordGroupByPayload<T extends SupplyChainRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SupplyChainRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplyChainRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplyChainRecordGroupByOutputType[P]>
            : GetScalarType<T[P], SupplyChainRecordGroupByOutputType[P]>
        }
      >
    >


  export type SupplyChainRecordSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    drugbatchid?: boolean
    fromentityid?: boolean
    toentityid?: boolean
    action?: boolean
    timestamp?: boolean
    blockchaintx?: boolean
    blockchaineventlog?: boolean | SupplyChainRecord$blockchaineventlogArgs<ExtArgs>
    drugbatch?: boolean | DrugBatchArgs<ExtArgs>
    users_supplychainrecord_fromentityidTousers?: boolean | UserArgs<ExtArgs>
    users_supplychainrecord_toentityidTousers?: boolean | UserArgs<ExtArgs>
    _count?: boolean | SupplyChainRecordCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["supplyChainRecord"]>

  export type SupplyChainRecordSelectScalar = {
    id?: boolean
    drugbatchid?: boolean
    fromentityid?: boolean
    toentityid?: boolean
    action?: boolean
    timestamp?: boolean
    blockchaintx?: boolean
  }

  export type SupplyChainRecordInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    blockchaineventlog?: boolean | SupplyChainRecord$blockchaineventlogArgs<ExtArgs>
    drugbatch?: boolean | DrugBatchArgs<ExtArgs>
    users_supplychainrecord_fromentityidTousers?: boolean | UserArgs<ExtArgs>
    users_supplychainrecord_toentityidTousers?: boolean | UserArgs<ExtArgs>
    _count?: boolean | SupplyChainRecordCountOutputTypeArgs<ExtArgs>
  }


  type SupplyChainRecordGetPayload<S extends boolean | null | undefined | SupplyChainRecordArgs> = $Types.GetResult<SupplyChainRecordPayload, S>

  type SupplyChainRecordCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<SupplyChainRecordFindManyArgs, 'select' | 'include'> & {
      select?: SupplyChainRecordCountAggregateInputType | true
    }

  export interface SupplyChainRecordDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupplyChainRecord'], meta: { name: 'SupplyChainRecord' } }
    /**
     * Find zero or one SupplyChainRecord that matches the filter.
     * @param {SupplyChainRecordFindUniqueArgs} args - Arguments to find a SupplyChainRecord
     * @example
     * // Get one SupplyChainRecord
     * const supplyChainRecord = await prisma.supplyChainRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SupplyChainRecordFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SupplyChainRecordFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SupplyChainRecord'> extends True ? Prisma__SupplyChainRecordClient<$Types.GetResult<SupplyChainRecordPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__SupplyChainRecordClient<$Types.GetResult<SupplyChainRecordPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one SupplyChainRecord that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SupplyChainRecordFindUniqueOrThrowArgs} args - Arguments to find a SupplyChainRecord
     * @example
     * // Get one SupplyChainRecord
     * const supplyChainRecord = await prisma.supplyChainRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SupplyChainRecordFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplyChainRecordFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SupplyChainRecordClient<$Types.GetResult<SupplyChainRecordPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first SupplyChainRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplyChainRecordFindFirstArgs} args - Arguments to find a SupplyChainRecord
     * @example
     * // Get one SupplyChainRecord
     * const supplyChainRecord = await prisma.supplyChainRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SupplyChainRecordFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SupplyChainRecordFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SupplyChainRecord'> extends True ? Prisma__SupplyChainRecordClient<$Types.GetResult<SupplyChainRecordPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__SupplyChainRecordClient<$Types.GetResult<SupplyChainRecordPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first SupplyChainRecord that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplyChainRecordFindFirstOrThrowArgs} args - Arguments to find a SupplyChainRecord
     * @example
     * // Get one SupplyChainRecord
     * const supplyChainRecord = await prisma.supplyChainRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SupplyChainRecordFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplyChainRecordFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SupplyChainRecordClient<$Types.GetResult<SupplyChainRecordPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more SupplyChainRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplyChainRecordFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupplyChainRecords
     * const supplyChainRecords = await prisma.supplyChainRecord.findMany()
     * 
     * // Get first 10 SupplyChainRecords
     * const supplyChainRecords = await prisma.supplyChainRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplyChainRecordWithIdOnly = await prisma.supplyChainRecord.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SupplyChainRecordFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplyChainRecordFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<SupplyChainRecordPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a SupplyChainRecord.
     * @param {SupplyChainRecordCreateArgs} args - Arguments to create a SupplyChainRecord.
     * @example
     * // Create one SupplyChainRecord
     * const SupplyChainRecord = await prisma.supplyChainRecord.create({
     *   data: {
     *     // ... data to create a SupplyChainRecord
     *   }
     * })
     * 
    **/
    create<T extends SupplyChainRecordCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SupplyChainRecordCreateArgs<ExtArgs>>
    ): Prisma__SupplyChainRecordClient<$Types.GetResult<SupplyChainRecordPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many SupplyChainRecords.
     *     @param {SupplyChainRecordCreateManyArgs} args - Arguments to create many SupplyChainRecords.
     *     @example
     *     // Create many SupplyChainRecords
     *     const supplyChainRecord = await prisma.supplyChainRecord.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SupplyChainRecordCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplyChainRecordCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SupplyChainRecord.
     * @param {SupplyChainRecordDeleteArgs} args - Arguments to delete one SupplyChainRecord.
     * @example
     * // Delete one SupplyChainRecord
     * const SupplyChainRecord = await prisma.supplyChainRecord.delete({
     *   where: {
     *     // ... filter to delete one SupplyChainRecord
     *   }
     * })
     * 
    **/
    delete<T extends SupplyChainRecordDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SupplyChainRecordDeleteArgs<ExtArgs>>
    ): Prisma__SupplyChainRecordClient<$Types.GetResult<SupplyChainRecordPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one SupplyChainRecord.
     * @param {SupplyChainRecordUpdateArgs} args - Arguments to update one SupplyChainRecord.
     * @example
     * // Update one SupplyChainRecord
     * const supplyChainRecord = await prisma.supplyChainRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SupplyChainRecordUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SupplyChainRecordUpdateArgs<ExtArgs>>
    ): Prisma__SupplyChainRecordClient<$Types.GetResult<SupplyChainRecordPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more SupplyChainRecords.
     * @param {SupplyChainRecordDeleteManyArgs} args - Arguments to filter SupplyChainRecords to delete.
     * @example
     * // Delete a few SupplyChainRecords
     * const { count } = await prisma.supplyChainRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SupplyChainRecordDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplyChainRecordDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplyChainRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplyChainRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupplyChainRecords
     * const supplyChainRecord = await prisma.supplyChainRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SupplyChainRecordUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SupplyChainRecordUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SupplyChainRecord.
     * @param {SupplyChainRecordUpsertArgs} args - Arguments to update or create a SupplyChainRecord.
     * @example
     * // Update or create a SupplyChainRecord
     * const supplyChainRecord = await prisma.supplyChainRecord.upsert({
     *   create: {
     *     // ... data to create a SupplyChainRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupplyChainRecord we want to update
     *   }
     * })
    **/
    upsert<T extends SupplyChainRecordUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SupplyChainRecordUpsertArgs<ExtArgs>>
    ): Prisma__SupplyChainRecordClient<$Types.GetResult<SupplyChainRecordPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of SupplyChainRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplyChainRecordCountArgs} args - Arguments to filter SupplyChainRecords to count.
     * @example
     * // Count the number of SupplyChainRecords
     * const count = await prisma.supplyChainRecord.count({
     *   where: {
     *     // ... the filter for the SupplyChainRecords we want to count
     *   }
     * })
    **/
    count<T extends SupplyChainRecordCountArgs>(
      args?: Subset<T, SupplyChainRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplyChainRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupplyChainRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplyChainRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplyChainRecordAggregateArgs>(args: Subset<T, SupplyChainRecordAggregateArgs>): Prisma.PrismaPromise<GetSupplyChainRecordAggregateType<T>>

    /**
     * Group by SupplyChainRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplyChainRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplyChainRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplyChainRecordGroupByArgs['orderBy'] }
        : { orderBy?: SupplyChainRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplyChainRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplyChainRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SupplyChainRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SupplyChainRecordClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    blockchaineventlog<T extends SupplyChainRecord$blockchaineventlogArgs<ExtArgs> = {}>(args?: Subset<T, SupplyChainRecord$blockchaineventlogArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<BlockchainEventLogPayload<ExtArgs>, T, 'findMany', never>| Null>;

    drugbatch<T extends DrugBatchArgs<ExtArgs> = {}>(args?: Subset<T, DrugBatchArgs<ExtArgs>>): Prisma__DrugBatchClient<$Types.GetResult<DrugBatchPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    users_supplychainrecord_fromentityidTousers<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    users_supplychainrecord_toentityidTousers<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SupplyChainRecord base type for findUnique actions
   */
  export type SupplyChainRecordFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplyChainRecord
     */
    select?: SupplyChainRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplyChainRecordInclude<ExtArgs> | null
    /**
     * Filter, which SupplyChainRecord to fetch.
     */
    where: SupplyChainRecordWhereUniqueInput
  }

  /**
   * SupplyChainRecord findUnique
   */
  export interface SupplyChainRecordFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends SupplyChainRecordFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SupplyChainRecord findUniqueOrThrow
   */
  export type SupplyChainRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplyChainRecord
     */
    select?: SupplyChainRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplyChainRecordInclude<ExtArgs> | null
    /**
     * Filter, which SupplyChainRecord to fetch.
     */
    where: SupplyChainRecordWhereUniqueInput
  }


  /**
   * SupplyChainRecord base type for findFirst actions
   */
  export type SupplyChainRecordFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplyChainRecord
     */
    select?: SupplyChainRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplyChainRecordInclude<ExtArgs> | null
    /**
     * Filter, which SupplyChainRecord to fetch.
     */
    where?: SupplyChainRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplyChainRecords to fetch.
     */
    orderBy?: Enumerable<SupplyChainRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplyChainRecords.
     */
    cursor?: SupplyChainRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplyChainRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplyChainRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplyChainRecords.
     */
    distinct?: Enumerable<SupplyChainRecordScalarFieldEnum>
  }

  /**
   * SupplyChainRecord findFirst
   */
  export interface SupplyChainRecordFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends SupplyChainRecordFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SupplyChainRecord findFirstOrThrow
   */
  export type SupplyChainRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplyChainRecord
     */
    select?: SupplyChainRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplyChainRecordInclude<ExtArgs> | null
    /**
     * Filter, which SupplyChainRecord to fetch.
     */
    where?: SupplyChainRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplyChainRecords to fetch.
     */
    orderBy?: Enumerable<SupplyChainRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplyChainRecords.
     */
    cursor?: SupplyChainRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplyChainRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplyChainRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplyChainRecords.
     */
    distinct?: Enumerable<SupplyChainRecordScalarFieldEnum>
  }


  /**
   * SupplyChainRecord findMany
   */
  export type SupplyChainRecordFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplyChainRecord
     */
    select?: SupplyChainRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplyChainRecordInclude<ExtArgs> | null
    /**
     * Filter, which SupplyChainRecords to fetch.
     */
    where?: SupplyChainRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplyChainRecords to fetch.
     */
    orderBy?: Enumerable<SupplyChainRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupplyChainRecords.
     */
    cursor?: SupplyChainRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplyChainRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplyChainRecords.
     */
    skip?: number
    distinct?: Enumerable<SupplyChainRecordScalarFieldEnum>
  }


  /**
   * SupplyChainRecord create
   */
  export type SupplyChainRecordCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplyChainRecord
     */
    select?: SupplyChainRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplyChainRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a SupplyChainRecord.
     */
    data: XOR<SupplyChainRecordCreateInput, SupplyChainRecordUncheckedCreateInput>
  }


  /**
   * SupplyChainRecord createMany
   */
  export type SupplyChainRecordCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupplyChainRecords.
     */
    data: Enumerable<SupplyChainRecordCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SupplyChainRecord update
   */
  export type SupplyChainRecordUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplyChainRecord
     */
    select?: SupplyChainRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplyChainRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a SupplyChainRecord.
     */
    data: XOR<SupplyChainRecordUpdateInput, SupplyChainRecordUncheckedUpdateInput>
    /**
     * Choose, which SupplyChainRecord to update.
     */
    where: SupplyChainRecordWhereUniqueInput
  }


  /**
   * SupplyChainRecord updateMany
   */
  export type SupplyChainRecordUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupplyChainRecords.
     */
    data: XOR<SupplyChainRecordUpdateManyMutationInput, SupplyChainRecordUncheckedUpdateManyInput>
    /**
     * Filter which SupplyChainRecords to update
     */
    where?: SupplyChainRecordWhereInput
  }


  /**
   * SupplyChainRecord upsert
   */
  export type SupplyChainRecordUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplyChainRecord
     */
    select?: SupplyChainRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplyChainRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the SupplyChainRecord to update in case it exists.
     */
    where: SupplyChainRecordWhereUniqueInput
    /**
     * In case the SupplyChainRecord found by the `where` argument doesn't exist, create a new SupplyChainRecord with this data.
     */
    create: XOR<SupplyChainRecordCreateInput, SupplyChainRecordUncheckedCreateInput>
    /**
     * In case the SupplyChainRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplyChainRecordUpdateInput, SupplyChainRecordUncheckedUpdateInput>
  }


  /**
   * SupplyChainRecord delete
   */
  export type SupplyChainRecordDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplyChainRecord
     */
    select?: SupplyChainRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplyChainRecordInclude<ExtArgs> | null
    /**
     * Filter which SupplyChainRecord to delete.
     */
    where: SupplyChainRecordWhereUniqueInput
  }


  /**
   * SupplyChainRecord deleteMany
   */
  export type SupplyChainRecordDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplyChainRecords to delete
     */
    where?: SupplyChainRecordWhereInput
  }


  /**
   * SupplyChainRecord.blockchaineventlog
   */
  export type SupplyChainRecord$blockchaineventlogArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainEventLog
     */
    select?: BlockchainEventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockchainEventLogInclude<ExtArgs> | null
    where?: BlockchainEventLogWhereInput
    orderBy?: Enumerable<BlockchainEventLogOrderByWithRelationInput>
    cursor?: BlockchainEventLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BlockchainEventLogScalarFieldEnum>
  }


  /**
   * SupplyChainRecord without action
   */
  export type SupplyChainRecordArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplyChainRecord
     */
    select?: SupplyChainRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplyChainRecordInclude<ExtArgs> | null
  }



  /**
   * Model RevocationRecord
   */


  export type AggregateRevocationRecord = {
    _count: RevocationRecordCountAggregateOutputType | null
    _avg: RevocationRecordAvgAggregateOutputType | null
    _sum: RevocationRecordSumAggregateOutputType | null
    _min: RevocationRecordMinAggregateOutputType | null
    _max: RevocationRecordMaxAggregateOutputType | null
  }

  export type RevocationRecordAvgAggregateOutputType = {
    id: number | null
    refid: number | null
    revokedbyid: number | null
  }

  export type RevocationRecordSumAggregateOutputType = {
    id: number | null
    refid: number | null
    revokedbyid: number | null
  }

  export type RevocationRecordMinAggregateOutputType = {
    id: number | null
    type: string | null
    refid: number | null
    reason: string | null
    revokedbyid: number | null
    timestamp: Date | null
    blockchaintx: string | null
  }

  export type RevocationRecordMaxAggregateOutputType = {
    id: number | null
    type: string | null
    refid: number | null
    reason: string | null
    revokedbyid: number | null
    timestamp: Date | null
    blockchaintx: string | null
  }

  export type RevocationRecordCountAggregateOutputType = {
    id: number
    type: number
    refid: number
    reason: number
    revokedbyid: number
    timestamp: number
    blockchaintx: number
    _all: number
  }


  export type RevocationRecordAvgAggregateInputType = {
    id?: true
    refid?: true
    revokedbyid?: true
  }

  export type RevocationRecordSumAggregateInputType = {
    id?: true
    refid?: true
    revokedbyid?: true
  }

  export type RevocationRecordMinAggregateInputType = {
    id?: true
    type?: true
    refid?: true
    reason?: true
    revokedbyid?: true
    timestamp?: true
    blockchaintx?: true
  }

  export type RevocationRecordMaxAggregateInputType = {
    id?: true
    type?: true
    refid?: true
    reason?: true
    revokedbyid?: true
    timestamp?: true
    blockchaintx?: true
  }

  export type RevocationRecordCountAggregateInputType = {
    id?: true
    type?: true
    refid?: true
    reason?: true
    revokedbyid?: true
    timestamp?: true
    blockchaintx?: true
    _all?: true
  }

  export type RevocationRecordAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which RevocationRecord to aggregate.
     */
    where?: RevocationRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevocationRecords to fetch.
     */
    orderBy?: Enumerable<RevocationRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RevocationRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevocationRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevocationRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RevocationRecords
    **/
    _count?: true | RevocationRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RevocationRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RevocationRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RevocationRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RevocationRecordMaxAggregateInputType
  }

  export type GetRevocationRecordAggregateType<T extends RevocationRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateRevocationRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRevocationRecord[P]>
      : GetScalarType<T[P], AggregateRevocationRecord[P]>
  }




  export type RevocationRecordGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: RevocationRecordWhereInput
    orderBy?: Enumerable<RevocationRecordOrderByWithAggregationInput>
    by: RevocationRecordScalarFieldEnum[]
    having?: RevocationRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RevocationRecordCountAggregateInputType | true
    _avg?: RevocationRecordAvgAggregateInputType
    _sum?: RevocationRecordSumAggregateInputType
    _min?: RevocationRecordMinAggregateInputType
    _max?: RevocationRecordMaxAggregateInputType
  }


  export type RevocationRecordGroupByOutputType = {
    id: number
    type: string
    refid: number
    reason: string
    revokedbyid: number | null
    timestamp: Date | null
    blockchaintx: string | null
    _count: RevocationRecordCountAggregateOutputType | null
    _avg: RevocationRecordAvgAggregateOutputType | null
    _sum: RevocationRecordSumAggregateOutputType | null
    _min: RevocationRecordMinAggregateOutputType | null
    _max: RevocationRecordMaxAggregateOutputType | null
  }

  type GetRevocationRecordGroupByPayload<T extends RevocationRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RevocationRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RevocationRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RevocationRecordGroupByOutputType[P]>
            : GetScalarType<T[P], RevocationRecordGroupByOutputType[P]>
        }
      >
    >


  export type RevocationRecordSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    refid?: boolean
    reason?: boolean
    revokedbyid?: boolean
    timestamp?: boolean
    blockchaintx?: boolean
    users?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["revocationRecord"]>

  export type RevocationRecordSelectScalar = {
    id?: boolean
    type?: boolean
    refid?: boolean
    reason?: boolean
    revokedbyid?: boolean
    timestamp?: boolean
    blockchaintx?: boolean
  }

  export type RevocationRecordInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    users?: boolean | UserArgs<ExtArgs>
  }


  type RevocationRecordGetPayload<S extends boolean | null | undefined | RevocationRecordArgs> = $Types.GetResult<RevocationRecordPayload, S>

  type RevocationRecordCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<RevocationRecordFindManyArgs, 'select' | 'include'> & {
      select?: RevocationRecordCountAggregateInputType | true
    }

  export interface RevocationRecordDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RevocationRecord'], meta: { name: 'RevocationRecord' } }
    /**
     * Find zero or one RevocationRecord that matches the filter.
     * @param {RevocationRecordFindUniqueArgs} args - Arguments to find a RevocationRecord
     * @example
     * // Get one RevocationRecord
     * const revocationRecord = await prisma.revocationRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RevocationRecordFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RevocationRecordFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RevocationRecord'> extends True ? Prisma__RevocationRecordClient<$Types.GetResult<RevocationRecordPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__RevocationRecordClient<$Types.GetResult<RevocationRecordPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one RevocationRecord that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RevocationRecordFindUniqueOrThrowArgs} args - Arguments to find a RevocationRecord
     * @example
     * // Get one RevocationRecord
     * const revocationRecord = await prisma.revocationRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RevocationRecordFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RevocationRecordFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RevocationRecordClient<$Types.GetResult<RevocationRecordPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first RevocationRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevocationRecordFindFirstArgs} args - Arguments to find a RevocationRecord
     * @example
     * // Get one RevocationRecord
     * const revocationRecord = await prisma.revocationRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RevocationRecordFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RevocationRecordFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RevocationRecord'> extends True ? Prisma__RevocationRecordClient<$Types.GetResult<RevocationRecordPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__RevocationRecordClient<$Types.GetResult<RevocationRecordPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first RevocationRecord that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevocationRecordFindFirstOrThrowArgs} args - Arguments to find a RevocationRecord
     * @example
     * // Get one RevocationRecord
     * const revocationRecord = await prisma.revocationRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RevocationRecordFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RevocationRecordFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RevocationRecordClient<$Types.GetResult<RevocationRecordPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more RevocationRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevocationRecordFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RevocationRecords
     * const revocationRecords = await prisma.revocationRecord.findMany()
     * 
     * // Get first 10 RevocationRecords
     * const revocationRecords = await prisma.revocationRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const revocationRecordWithIdOnly = await prisma.revocationRecord.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RevocationRecordFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RevocationRecordFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<RevocationRecordPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a RevocationRecord.
     * @param {RevocationRecordCreateArgs} args - Arguments to create a RevocationRecord.
     * @example
     * // Create one RevocationRecord
     * const RevocationRecord = await prisma.revocationRecord.create({
     *   data: {
     *     // ... data to create a RevocationRecord
     *   }
     * })
     * 
    **/
    create<T extends RevocationRecordCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RevocationRecordCreateArgs<ExtArgs>>
    ): Prisma__RevocationRecordClient<$Types.GetResult<RevocationRecordPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many RevocationRecords.
     *     @param {RevocationRecordCreateManyArgs} args - Arguments to create many RevocationRecords.
     *     @example
     *     // Create many RevocationRecords
     *     const revocationRecord = await prisma.revocationRecord.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RevocationRecordCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RevocationRecordCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RevocationRecord.
     * @param {RevocationRecordDeleteArgs} args - Arguments to delete one RevocationRecord.
     * @example
     * // Delete one RevocationRecord
     * const RevocationRecord = await prisma.revocationRecord.delete({
     *   where: {
     *     // ... filter to delete one RevocationRecord
     *   }
     * })
     * 
    **/
    delete<T extends RevocationRecordDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RevocationRecordDeleteArgs<ExtArgs>>
    ): Prisma__RevocationRecordClient<$Types.GetResult<RevocationRecordPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one RevocationRecord.
     * @param {RevocationRecordUpdateArgs} args - Arguments to update one RevocationRecord.
     * @example
     * // Update one RevocationRecord
     * const revocationRecord = await prisma.revocationRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RevocationRecordUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RevocationRecordUpdateArgs<ExtArgs>>
    ): Prisma__RevocationRecordClient<$Types.GetResult<RevocationRecordPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more RevocationRecords.
     * @param {RevocationRecordDeleteManyArgs} args - Arguments to filter RevocationRecords to delete.
     * @example
     * // Delete a few RevocationRecords
     * const { count } = await prisma.revocationRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RevocationRecordDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RevocationRecordDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RevocationRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevocationRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RevocationRecords
     * const revocationRecord = await prisma.revocationRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RevocationRecordUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RevocationRecordUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RevocationRecord.
     * @param {RevocationRecordUpsertArgs} args - Arguments to update or create a RevocationRecord.
     * @example
     * // Update or create a RevocationRecord
     * const revocationRecord = await prisma.revocationRecord.upsert({
     *   create: {
     *     // ... data to create a RevocationRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RevocationRecord we want to update
     *   }
     * })
    **/
    upsert<T extends RevocationRecordUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RevocationRecordUpsertArgs<ExtArgs>>
    ): Prisma__RevocationRecordClient<$Types.GetResult<RevocationRecordPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of RevocationRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevocationRecordCountArgs} args - Arguments to filter RevocationRecords to count.
     * @example
     * // Count the number of RevocationRecords
     * const count = await prisma.revocationRecord.count({
     *   where: {
     *     // ... the filter for the RevocationRecords we want to count
     *   }
     * })
    **/
    count<T extends RevocationRecordCountArgs>(
      args?: Subset<T, RevocationRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RevocationRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RevocationRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevocationRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RevocationRecordAggregateArgs>(args: Subset<T, RevocationRecordAggregateArgs>): Prisma.PrismaPromise<GetRevocationRecordAggregateType<T>>

    /**
     * Group by RevocationRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevocationRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RevocationRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RevocationRecordGroupByArgs['orderBy'] }
        : { orderBy?: RevocationRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RevocationRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRevocationRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RevocationRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RevocationRecordClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    users<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RevocationRecord base type for findUnique actions
   */
  export type RevocationRecordFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevocationRecord
     */
    select?: RevocationRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RevocationRecordInclude<ExtArgs> | null
    /**
     * Filter, which RevocationRecord to fetch.
     */
    where: RevocationRecordWhereUniqueInput
  }

  /**
   * RevocationRecord findUnique
   */
  export interface RevocationRecordFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends RevocationRecordFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RevocationRecord findUniqueOrThrow
   */
  export type RevocationRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevocationRecord
     */
    select?: RevocationRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RevocationRecordInclude<ExtArgs> | null
    /**
     * Filter, which RevocationRecord to fetch.
     */
    where: RevocationRecordWhereUniqueInput
  }


  /**
   * RevocationRecord base type for findFirst actions
   */
  export type RevocationRecordFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevocationRecord
     */
    select?: RevocationRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RevocationRecordInclude<ExtArgs> | null
    /**
     * Filter, which RevocationRecord to fetch.
     */
    where?: RevocationRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevocationRecords to fetch.
     */
    orderBy?: Enumerable<RevocationRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RevocationRecords.
     */
    cursor?: RevocationRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevocationRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevocationRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RevocationRecords.
     */
    distinct?: Enumerable<RevocationRecordScalarFieldEnum>
  }

  /**
   * RevocationRecord findFirst
   */
  export interface RevocationRecordFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends RevocationRecordFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RevocationRecord findFirstOrThrow
   */
  export type RevocationRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevocationRecord
     */
    select?: RevocationRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RevocationRecordInclude<ExtArgs> | null
    /**
     * Filter, which RevocationRecord to fetch.
     */
    where?: RevocationRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevocationRecords to fetch.
     */
    orderBy?: Enumerable<RevocationRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RevocationRecords.
     */
    cursor?: RevocationRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevocationRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevocationRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RevocationRecords.
     */
    distinct?: Enumerable<RevocationRecordScalarFieldEnum>
  }


  /**
   * RevocationRecord findMany
   */
  export type RevocationRecordFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevocationRecord
     */
    select?: RevocationRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RevocationRecordInclude<ExtArgs> | null
    /**
     * Filter, which RevocationRecords to fetch.
     */
    where?: RevocationRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevocationRecords to fetch.
     */
    orderBy?: Enumerable<RevocationRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RevocationRecords.
     */
    cursor?: RevocationRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevocationRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevocationRecords.
     */
    skip?: number
    distinct?: Enumerable<RevocationRecordScalarFieldEnum>
  }


  /**
   * RevocationRecord create
   */
  export type RevocationRecordCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevocationRecord
     */
    select?: RevocationRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RevocationRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a RevocationRecord.
     */
    data: XOR<RevocationRecordCreateInput, RevocationRecordUncheckedCreateInput>
  }


  /**
   * RevocationRecord createMany
   */
  export type RevocationRecordCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RevocationRecords.
     */
    data: Enumerable<RevocationRecordCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RevocationRecord update
   */
  export type RevocationRecordUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevocationRecord
     */
    select?: RevocationRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RevocationRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a RevocationRecord.
     */
    data: XOR<RevocationRecordUpdateInput, RevocationRecordUncheckedUpdateInput>
    /**
     * Choose, which RevocationRecord to update.
     */
    where: RevocationRecordWhereUniqueInput
  }


  /**
   * RevocationRecord updateMany
   */
  export type RevocationRecordUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RevocationRecords.
     */
    data: XOR<RevocationRecordUpdateManyMutationInput, RevocationRecordUncheckedUpdateManyInput>
    /**
     * Filter which RevocationRecords to update
     */
    where?: RevocationRecordWhereInput
  }


  /**
   * RevocationRecord upsert
   */
  export type RevocationRecordUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevocationRecord
     */
    select?: RevocationRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RevocationRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the RevocationRecord to update in case it exists.
     */
    where: RevocationRecordWhereUniqueInput
    /**
     * In case the RevocationRecord found by the `where` argument doesn't exist, create a new RevocationRecord with this data.
     */
    create: XOR<RevocationRecordCreateInput, RevocationRecordUncheckedCreateInput>
    /**
     * In case the RevocationRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RevocationRecordUpdateInput, RevocationRecordUncheckedUpdateInput>
  }


  /**
   * RevocationRecord delete
   */
  export type RevocationRecordDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevocationRecord
     */
    select?: RevocationRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RevocationRecordInclude<ExtArgs> | null
    /**
     * Filter which RevocationRecord to delete.
     */
    where: RevocationRecordWhereUniqueInput
  }


  /**
   * RevocationRecord deleteMany
   */
  export type RevocationRecordDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which RevocationRecords to delete
     */
    where?: RevocationRecordWhereInput
  }


  /**
   * RevocationRecord without action
   */
  export type RevocationRecordArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevocationRecord
     */
    select?: RevocationRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RevocationRecordInclude<ExtArgs> | null
  }



  /**
   * Model Otp
   */


  export type AggregateOtp = {
    _count: OtpCountAggregateOutputType | null
    _avg: OtpAvgAggregateOutputType | null
    _sum: OtpSumAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  export type OtpAvgAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type OtpSumAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type OtpMinAggregateOutputType = {
    id: number | null
    userid: number | null
    code: string | null
    expiresat: Date | null
    createdat: Date | null
  }

  export type OtpMaxAggregateOutputType = {
    id: number | null
    userid: number | null
    code: string | null
    expiresat: Date | null
    createdat: Date | null
  }

  export type OtpCountAggregateOutputType = {
    id: number
    userid: number
    code: number
    expiresat: number
    createdat: number
    _all: number
  }


  export type OtpAvgAggregateInputType = {
    id?: true
    userid?: true
  }

  export type OtpSumAggregateInputType = {
    id?: true
    userid?: true
  }

  export type OtpMinAggregateInputType = {
    id?: true
    userid?: true
    code?: true
    expiresat?: true
    createdat?: true
  }

  export type OtpMaxAggregateInputType = {
    id?: true
    userid?: true
    code?: true
    expiresat?: true
    createdat?: true
  }

  export type OtpCountAggregateInputType = {
    id?: true
    userid?: true
    code?: true
    expiresat?: true
    createdat?: true
    _all?: true
  }

  export type OtpAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otp to aggregate.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: Enumerable<OtpOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Otps
    **/
    _count?: true | OtpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OtpAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OtpSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtpMaxAggregateInputType
  }

  export type GetOtpAggregateType<T extends OtpAggregateArgs> = {
        [P in keyof T & keyof AggregateOtp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtp[P]>
      : GetScalarType<T[P], AggregateOtp[P]>
  }




  export type OtpGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OtpWhereInput
    orderBy?: Enumerable<OtpOrderByWithAggregationInput>
    by: OtpScalarFieldEnum[]
    having?: OtpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtpCountAggregateInputType | true
    _avg?: OtpAvgAggregateInputType
    _sum?: OtpSumAggregateInputType
    _min?: OtpMinAggregateInputType
    _max?: OtpMaxAggregateInputType
  }


  export type OtpGroupByOutputType = {
    id: number
    userid: number | null
    code: string
    expiresat: Date
    createdat: Date | null
    _count: OtpCountAggregateOutputType | null
    _avg: OtpAvgAggregateOutputType | null
    _sum: OtpSumAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  type GetOtpGroupByPayload<T extends OtpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OtpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtpGroupByOutputType[P]>
            : GetScalarType<T[P], OtpGroupByOutputType[P]>
        }
      >
    >


  export type OtpSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    code?: boolean
    expiresat?: boolean
    createdat?: boolean
    users?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["otp"]>

  export type OtpSelectScalar = {
    id?: boolean
    userid?: boolean
    code?: boolean
    expiresat?: boolean
    createdat?: boolean
  }

  export type OtpInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    users?: boolean | UserArgs<ExtArgs>
  }


  type OtpGetPayload<S extends boolean | null | undefined | OtpArgs> = $Types.GetResult<OtpPayload, S>

  type OtpCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<OtpFindManyArgs, 'select' | 'include'> & {
      select?: OtpCountAggregateInputType | true
    }

  export interface OtpDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Otp'], meta: { name: 'Otp' } }
    /**
     * Find zero or one Otp that matches the filter.
     * @param {OtpFindUniqueArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OtpFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OtpFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Otp'> extends True ? Prisma__OtpClient<$Types.GetResult<OtpPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__OtpClient<$Types.GetResult<OtpPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Otp that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OtpFindUniqueOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OtpFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OtpFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OtpClient<$Types.GetResult<OtpPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Otp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindFirstArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OtpFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OtpFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Otp'> extends True ? Prisma__OtpClient<$Types.GetResult<OtpPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__OtpClient<$Types.GetResult<OtpPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Otp that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindFirstOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OtpFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OtpFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OtpClient<$Types.GetResult<OtpPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Otps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Otps
     * const otps = await prisma.otp.findMany()
     * 
     * // Get first 10 Otps
     * const otps = await prisma.otp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const otpWithIdOnly = await prisma.otp.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OtpFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OtpFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<OtpPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Otp.
     * @param {OtpCreateArgs} args - Arguments to create a Otp.
     * @example
     * // Create one Otp
     * const Otp = await prisma.otp.create({
     *   data: {
     *     // ... data to create a Otp
     *   }
     * })
     * 
    **/
    create<T extends OtpCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OtpCreateArgs<ExtArgs>>
    ): Prisma__OtpClient<$Types.GetResult<OtpPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Otps.
     *     @param {OtpCreateManyArgs} args - Arguments to create many Otps.
     *     @example
     *     // Create many Otps
     *     const otp = await prisma.otp.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OtpCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OtpCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Otp.
     * @param {OtpDeleteArgs} args - Arguments to delete one Otp.
     * @example
     * // Delete one Otp
     * const Otp = await prisma.otp.delete({
     *   where: {
     *     // ... filter to delete one Otp
     *   }
     * })
     * 
    **/
    delete<T extends OtpDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OtpDeleteArgs<ExtArgs>>
    ): Prisma__OtpClient<$Types.GetResult<OtpPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Otp.
     * @param {OtpUpdateArgs} args - Arguments to update one Otp.
     * @example
     * // Update one Otp
     * const otp = await prisma.otp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OtpUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OtpUpdateArgs<ExtArgs>>
    ): Prisma__OtpClient<$Types.GetResult<OtpPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Otps.
     * @param {OtpDeleteManyArgs} args - Arguments to filter Otps to delete.
     * @example
     * // Delete a few Otps
     * const { count } = await prisma.otp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OtpDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OtpDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Otps
     * const otp = await prisma.otp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OtpUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OtpUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Otp.
     * @param {OtpUpsertArgs} args - Arguments to update or create a Otp.
     * @example
     * // Update or create a Otp
     * const otp = await prisma.otp.upsert({
     *   create: {
     *     // ... data to create a Otp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Otp we want to update
     *   }
     * })
    **/
    upsert<T extends OtpUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OtpUpsertArgs<ExtArgs>>
    ): Prisma__OtpClient<$Types.GetResult<OtpPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpCountArgs} args - Arguments to filter Otps to count.
     * @example
     * // Count the number of Otps
     * const count = await prisma.otp.count({
     *   where: {
     *     // ... the filter for the Otps we want to count
     *   }
     * })
    **/
    count<T extends OtpCountArgs>(
      args?: Subset<T, OtpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtpAggregateArgs>(args: Subset<T, OtpAggregateArgs>): Prisma.PrismaPromise<GetOtpAggregateType<T>>

    /**
     * Group by Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OtpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OtpGroupByArgs['orderBy'] }
        : { orderBy?: OtpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OtpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Otp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OtpClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    users<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Otp base type for findUnique actions
   */
  export type OtpFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp findUnique
   */
  export interface OtpFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends OtpFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Otp findUniqueOrThrow
   */
  export type OtpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where: OtpWhereUniqueInput
  }


  /**
   * Otp base type for findFirst actions
   */
  export type OtpFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: Enumerable<OtpOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otps.
     */
    distinct?: Enumerable<OtpScalarFieldEnum>
  }

  /**
   * Otp findFirst
   */
  export interface OtpFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends OtpFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Otp findFirstOrThrow
   */
  export type OtpFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: Enumerable<OtpOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otps.
     */
    distinct?: Enumerable<OtpScalarFieldEnum>
  }


  /**
   * Otp findMany
   */
  export type OtpFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otps to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: Enumerable<OtpOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    distinct?: Enumerable<OtpScalarFieldEnum>
  }


  /**
   * Otp create
   */
  export type OtpCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * The data needed to create a Otp.
     */
    data: XOR<OtpCreateInput, OtpUncheckedCreateInput>
  }


  /**
   * Otp createMany
   */
  export type OtpCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Otps.
     */
    data: Enumerable<OtpCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Otp update
   */
  export type OtpUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * The data needed to update a Otp.
     */
    data: XOR<OtpUpdateInput, OtpUncheckedUpdateInput>
    /**
     * Choose, which Otp to update.
     */
    where: OtpWhereUniqueInput
  }


  /**
   * Otp updateMany
   */
  export type OtpUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Otps.
     */
    data: XOR<OtpUpdateManyMutationInput, OtpUncheckedUpdateManyInput>
    /**
     * Filter which Otps to update
     */
    where?: OtpWhereInput
  }


  /**
   * Otp upsert
   */
  export type OtpUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * The filter to search for the Otp to update in case it exists.
     */
    where: OtpWhereUniqueInput
    /**
     * In case the Otp found by the `where` argument doesn't exist, create a new Otp with this data.
     */
    create: XOR<OtpCreateInput, OtpUncheckedCreateInput>
    /**
     * In case the Otp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OtpUpdateInput, OtpUncheckedUpdateInput>
  }


  /**
   * Otp delete
   */
  export type OtpDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter which Otp to delete.
     */
    where: OtpWhereUniqueInput
  }


  /**
   * Otp deleteMany
   */
  export type OtpDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otps to delete
     */
    where?: OtpWhereInput
  }


  /**
   * Otp without action
   */
  export type OtpArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OtpInclude<ExtArgs> | null
  }



  /**
   * Model Alert
   */


  export type AggregateAlert = {
    _count: AlertCountAggregateOutputType | null
    _avg: AlertAvgAggregateOutputType | null
    _sum: AlertSumAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  export type AlertAvgAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type AlertSumAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type AlertMinAggregateOutputType = {
    id: number | null
    userid: number | null
    title: string | null
    message: string | null
    isread: boolean | null
    priority: string | null
    createdat: Date | null
  }

  export type AlertMaxAggregateOutputType = {
    id: number | null
    userid: number | null
    title: string | null
    message: string | null
    isread: boolean | null
    priority: string | null
    createdat: Date | null
  }

  export type AlertCountAggregateOutputType = {
    id: number
    userid: number
    title: number
    message: number
    isread: number
    priority: number
    createdat: number
    _all: number
  }


  export type AlertAvgAggregateInputType = {
    id?: true
    userid?: true
  }

  export type AlertSumAggregateInputType = {
    id?: true
    userid?: true
  }

  export type AlertMinAggregateInputType = {
    id?: true
    userid?: true
    title?: true
    message?: true
    isread?: true
    priority?: true
    createdat?: true
  }

  export type AlertMaxAggregateInputType = {
    id?: true
    userid?: true
    title?: true
    message?: true
    isread?: true
    priority?: true
    createdat?: true
  }

  export type AlertCountAggregateInputType = {
    id?: true
    userid?: true
    title?: true
    message?: true
    isread?: true
    priority?: true
    createdat?: true
    _all?: true
  }

  export type AlertAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alert to aggregate.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: Enumerable<AlertOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alerts
    **/
    _count?: true | AlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlertAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlertSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertMaxAggregateInputType
  }

  export type GetAlertAggregateType<T extends AlertAggregateArgs> = {
        [P in keyof T & keyof AggregateAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlert[P]>
      : GetScalarType<T[P], AggregateAlert[P]>
  }




  export type AlertGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
    orderBy?: Enumerable<AlertOrderByWithAggregationInput>
    by: AlertScalarFieldEnum[]
    having?: AlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertCountAggregateInputType | true
    _avg?: AlertAvgAggregateInputType
    _sum?: AlertSumAggregateInputType
    _min?: AlertMinAggregateInputType
    _max?: AlertMaxAggregateInputType
  }


  export type AlertGroupByOutputType = {
    id: number
    userid: number | null
    title: string
    message: string
    isread: boolean | null
    priority: string
    createdat: Date | null
    _count: AlertCountAggregateOutputType | null
    _avg: AlertAvgAggregateOutputType | null
    _sum: AlertSumAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  type GetAlertGroupByPayload<T extends AlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertGroupByOutputType[P]>
            : GetScalarType<T[P], AlertGroupByOutputType[P]>
        }
      >
    >


  export type AlertSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    title?: boolean
    message?: boolean
    isread?: boolean
    priority?: boolean
    createdat?: boolean
    users?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectScalar = {
    id?: boolean
    userid?: boolean
    title?: boolean
    message?: boolean
    isread?: boolean
    priority?: boolean
    createdat?: boolean
  }

  export type AlertInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    users?: boolean | UserArgs<ExtArgs>
  }


  type AlertGetPayload<S extends boolean | null | undefined | AlertArgs> = $Types.GetResult<AlertPayload, S>

  type AlertCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AlertFindManyArgs, 'select' | 'include'> & {
      select?: AlertCountAggregateInputType | true
    }

  export interface AlertDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Alert'], meta: { name: 'Alert' } }
    /**
     * Find zero or one Alert that matches the filter.
     * @param {AlertFindUniqueArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AlertFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AlertFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Alert'> extends True ? Prisma__AlertClient<$Types.GetResult<AlertPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__AlertClient<$Types.GetResult<AlertPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Alert that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AlertFindUniqueOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AlertFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AlertFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AlertClient<$Types.GetResult<AlertPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Alert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AlertFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AlertFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Alert'> extends True ? Prisma__AlertClient<$Types.GetResult<AlertPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__AlertClient<$Types.GetResult<AlertPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Alert that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AlertFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AlertFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AlertClient<$Types.GetResult<AlertPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Alerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alerts
     * const alerts = await prisma.alert.findMany()
     * 
     * // Get first 10 Alerts
     * const alerts = await prisma.alert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertWithIdOnly = await prisma.alert.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AlertFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AlertFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<AlertPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Alert.
     * @param {AlertCreateArgs} args - Arguments to create a Alert.
     * @example
     * // Create one Alert
     * const Alert = await prisma.alert.create({
     *   data: {
     *     // ... data to create a Alert
     *   }
     * })
     * 
    **/
    create<T extends AlertCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AlertCreateArgs<ExtArgs>>
    ): Prisma__AlertClient<$Types.GetResult<AlertPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Alerts.
     *     @param {AlertCreateManyArgs} args - Arguments to create many Alerts.
     *     @example
     *     // Create many Alerts
     *     const alert = await prisma.alert.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AlertCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AlertCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Alert.
     * @param {AlertDeleteArgs} args - Arguments to delete one Alert.
     * @example
     * // Delete one Alert
     * const Alert = await prisma.alert.delete({
     *   where: {
     *     // ... filter to delete one Alert
     *   }
     * })
     * 
    **/
    delete<T extends AlertDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AlertDeleteArgs<ExtArgs>>
    ): Prisma__AlertClient<$Types.GetResult<AlertPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Alert.
     * @param {AlertUpdateArgs} args - Arguments to update one Alert.
     * @example
     * // Update one Alert
     * const alert = await prisma.alert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AlertUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AlertUpdateArgs<ExtArgs>>
    ): Prisma__AlertClient<$Types.GetResult<AlertPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Alerts.
     * @param {AlertDeleteManyArgs} args - Arguments to filter Alerts to delete.
     * @example
     * // Delete a few Alerts
     * const { count } = await prisma.alert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AlertDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AlertDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alerts
     * const alert = await prisma.alert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AlertUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AlertUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Alert.
     * @param {AlertUpsertArgs} args - Arguments to update or create a Alert.
     * @example
     * // Update or create a Alert
     * const alert = await prisma.alert.upsert({
     *   create: {
     *     // ... data to create a Alert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alert we want to update
     *   }
     * })
    **/
    upsert<T extends AlertUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AlertUpsertArgs<ExtArgs>>
    ): Prisma__AlertClient<$Types.GetResult<AlertPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertCountArgs} args - Arguments to filter Alerts to count.
     * @example
     * // Count the number of Alerts
     * const count = await prisma.alert.count({
     *   where: {
     *     // ... the filter for the Alerts we want to count
     *   }
     * })
    **/
    count<T extends AlertCountArgs>(
      args?: Subset<T, AlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertAggregateArgs>(args: Subset<T, AlertAggregateArgs>): Prisma.PrismaPromise<GetAlertAggregateType<T>>

    /**
     * Group by Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertGroupByArgs['orderBy'] }
        : { orderBy?: AlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Alert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AlertClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    users<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Alert base type for findUnique actions
   */
  export type AlertFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findUnique
   */
  export interface AlertFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AlertFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Alert findUniqueOrThrow
   */
  export type AlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }


  /**
   * Alert base type for findFirst actions
   */
  export type AlertFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: Enumerable<AlertOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: Enumerable<AlertScalarFieldEnum>
  }

  /**
   * Alert findFirst
   */
  export interface AlertFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AlertFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Alert findFirstOrThrow
   */
  export type AlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: Enumerable<AlertOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: Enumerable<AlertScalarFieldEnum>
  }


  /**
   * Alert findMany
   */
  export type AlertFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alerts to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: Enumerable<AlertOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    distinct?: Enumerable<AlertScalarFieldEnum>
  }


  /**
   * Alert create
   */
  export type AlertCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to create a Alert.
     */
    data: XOR<AlertCreateInput, AlertUncheckedCreateInput>
  }


  /**
   * Alert createMany
   */
  export type AlertCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alerts.
     */
    data: Enumerable<AlertCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Alert update
   */
  export type AlertUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to update a Alert.
     */
    data: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
    /**
     * Choose, which Alert to update.
     */
    where: AlertWhereUniqueInput
  }


  /**
   * Alert updateMany
   */
  export type AlertUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alerts.
     */
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyInput>
    /**
     * Filter which Alerts to update
     */
    where?: AlertWhereInput
  }


  /**
   * Alert upsert
   */
  export type AlertUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The filter to search for the Alert to update in case it exists.
     */
    where: AlertWhereUniqueInput
    /**
     * In case the Alert found by the `where` argument doesn't exist, create a new Alert with this data.
     */
    create: XOR<AlertCreateInput, AlertUncheckedCreateInput>
    /**
     * In case the Alert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
  }


  /**
   * Alert delete
   */
  export type AlertDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter which Alert to delete.
     */
    where: AlertWhereUniqueInput
  }


  /**
   * Alert deleteMany
   */
  export type AlertDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alerts to delete
     */
    where?: AlertWhereInput
  }


  /**
   * Alert without action
   */
  export type AlertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude<ExtArgs> | null
  }



  /**
   * Model ActivityLog
   */


  export type AggregateActivityLog = {
    _count: ActivityLogCountAggregateOutputType | null
    _avg: ActivityLogAvgAggregateOutputType | null
    _sum: ActivityLogSumAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  export type ActivityLogAvgAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type ActivityLogSumAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type ActivityLogMinAggregateOutputType = {
    id: number | null
    userid: number | null
    action: string | null
    details: string | null
    timestamp: Date | null
  }

  export type ActivityLogMaxAggregateOutputType = {
    id: number | null
    userid: number | null
    action: string | null
    details: string | null
    timestamp: Date | null
  }

  export type ActivityLogCountAggregateOutputType = {
    id: number
    userid: number
    action: number
    details: number
    timestamp: number
    _all: number
  }


  export type ActivityLogAvgAggregateInputType = {
    id?: true
    userid?: true
  }

  export type ActivityLogSumAggregateInputType = {
    id?: true
    userid?: true
  }

  export type ActivityLogMinAggregateInputType = {
    id?: true
    userid?: true
    action?: true
    details?: true
    timestamp?: true
  }

  export type ActivityLogMaxAggregateInputType = {
    id?: true
    userid?: true
    action?: true
    details?: true
    timestamp?: true
  }

  export type ActivityLogCountAggregateInputType = {
    id?: true
    userid?: true
    action?: true
    details?: true
    timestamp?: true
    _all?: true
  }

  export type ActivityLogAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLog to aggregate.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: Enumerable<ActivityLogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityLogs
    **/
    _count?: true | ActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivityLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityLogMaxAggregateInputType
  }

  export type GetActivityLogAggregateType<T extends ActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityLog[P]>
      : GetScalarType<T[P], AggregateActivityLog[P]>
  }




  export type ActivityLogGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
    orderBy?: Enumerable<ActivityLogOrderByWithAggregationInput>
    by: ActivityLogScalarFieldEnum[]
    having?: ActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityLogCountAggregateInputType | true
    _avg?: ActivityLogAvgAggregateInputType
    _sum?: ActivityLogSumAggregateInputType
    _min?: ActivityLogMinAggregateInputType
    _max?: ActivityLogMaxAggregateInputType
  }


  export type ActivityLogGroupByOutputType = {
    id: number
    userid: number | null
    action: string
    details: string | null
    timestamp: Date | null
    _count: ActivityLogCountAggregateOutputType | null
    _avg: ActivityLogAvgAggregateOutputType | null
    _sum: ActivityLogSumAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  type GetActivityLogGroupByPayload<T extends ActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type ActivityLogSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    action?: boolean
    details?: boolean
    timestamp?: boolean
    users?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectScalar = {
    id?: boolean
    userid?: boolean
    action?: boolean
    details?: boolean
    timestamp?: boolean
  }

  export type ActivityLogInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    users?: boolean | UserArgs<ExtArgs>
  }


  type ActivityLogGetPayload<S extends boolean | null | undefined | ActivityLogArgs> = $Types.GetResult<ActivityLogPayload, S>

  type ActivityLogCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ActivityLogFindManyArgs, 'select' | 'include'> & {
      select?: ActivityLogCountAggregateInputType | true
    }

  export interface ActivityLogDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityLog'], meta: { name: 'ActivityLog' } }
    /**
     * Find zero or one ActivityLog that matches the filter.
     * @param {ActivityLogFindUniqueArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ActivityLogFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ActivityLogFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ActivityLog'> extends True ? Prisma__ActivityLogClient<$Types.GetResult<ActivityLogPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ActivityLogClient<$Types.GetResult<ActivityLogPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ActivityLog that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ActivityLogFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ActivityLogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ActivityLogClient<$Types.GetResult<ActivityLogPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ActivityLogFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ActivityLogFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ActivityLog'> extends True ? Prisma__ActivityLogClient<$Types.GetResult<ActivityLogPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ActivityLogClient<$Types.GetResult<ActivityLogPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ActivityLog that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ActivityLogFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ActivityLogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ActivityLogClient<$Types.GetResult<ActivityLogPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany()
     * 
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ActivityLogFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ActivityLogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ActivityLogPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ActivityLog.
     * @param {ActivityLogCreateArgs} args - Arguments to create a ActivityLog.
     * @example
     * // Create one ActivityLog
     * const ActivityLog = await prisma.activityLog.create({
     *   data: {
     *     // ... data to create a ActivityLog
     *   }
     * })
     * 
    **/
    create<T extends ActivityLogCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ActivityLogCreateArgs<ExtArgs>>
    ): Prisma__ActivityLogClient<$Types.GetResult<ActivityLogPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ActivityLogs.
     *     @param {ActivityLogCreateManyArgs} args - Arguments to create many ActivityLogs.
     *     @example
     *     // Create many ActivityLogs
     *     const activityLog = await prisma.activityLog.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ActivityLogCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ActivityLogCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ActivityLog.
     * @param {ActivityLogDeleteArgs} args - Arguments to delete one ActivityLog.
     * @example
     * // Delete one ActivityLog
     * const ActivityLog = await prisma.activityLog.delete({
     *   where: {
     *     // ... filter to delete one ActivityLog
     *   }
     * })
     * 
    **/
    delete<T extends ActivityLogDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ActivityLogDeleteArgs<ExtArgs>>
    ): Prisma__ActivityLogClient<$Types.GetResult<ActivityLogPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ActivityLog.
     * @param {ActivityLogUpdateArgs} args - Arguments to update one ActivityLog.
     * @example
     * // Update one ActivityLog
     * const activityLog = await prisma.activityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ActivityLogUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ActivityLogUpdateArgs<ExtArgs>>
    ): Prisma__ActivityLogClient<$Types.GetResult<ActivityLogPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ActivityLogs.
     * @param {ActivityLogDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ActivityLogDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ActivityLogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ActivityLogUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ActivityLogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ActivityLog.
     * @param {ActivityLogUpsertArgs} args - Arguments to update or create a ActivityLog.
     * @example
     * // Update or create a ActivityLog
     * const activityLog = await prisma.activityLog.upsert({
     *   create: {
     *     // ... data to create a ActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLog we want to update
     *   }
     * })
    **/
    upsert<T extends ActivityLogUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ActivityLogUpsertArgs<ExtArgs>>
    ): Prisma__ActivityLogClient<$Types.GetResult<ActivityLogPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLog.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends ActivityLogCountArgs>(
      args?: Subset<T, ActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityLogAggregateArgs>(args: Subset<T, ActivityLogAggregateArgs>): Prisma.PrismaPromise<GetActivityLogAggregateType<T>>

    /**
     * Group by ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: ActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ActivityLogClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    users<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ActivityLog base type for findUnique actions
   */
  export type ActivityLogFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findUnique
   */
  export interface ActivityLogFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ActivityLogFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ActivityLog findUniqueOrThrow
   */
  export type ActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }


  /**
   * ActivityLog base type for findFirst actions
   */
  export type ActivityLogFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: Enumerable<ActivityLogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: Enumerable<ActivityLogScalarFieldEnum>
  }

  /**
   * ActivityLog findFirst
   */
  export interface ActivityLogFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ActivityLogFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ActivityLog findFirstOrThrow
   */
  export type ActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: Enumerable<ActivityLogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: Enumerable<ActivityLogScalarFieldEnum>
  }


  /**
   * ActivityLog findMany
   */
  export type ActivityLogFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: Enumerable<ActivityLogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    distinct?: Enumerable<ActivityLogScalarFieldEnum>
  }


  /**
   * ActivityLog create
   */
  export type ActivityLogCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityLog.
     */
    data: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
  }


  /**
   * ActivityLog createMany
   */
  export type ActivityLogCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityLogs.
     */
    data: Enumerable<ActivityLogCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ActivityLog update
   */
  export type ActivityLogUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityLog.
     */
    data: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
    /**
     * Choose, which ActivityLog to update.
     */
    where: ActivityLogWhereUniqueInput
  }


  /**
   * ActivityLog updateMany
   */
  export type ActivityLogUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
  }


  /**
   * ActivityLog upsert
   */
  export type ActivityLogUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityLog to update in case it exists.
     */
    where: ActivityLogWhereUniqueInput
    /**
     * In case the ActivityLog found by the `where` argument doesn't exist, create a new ActivityLog with this data.
     */
    create: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
    /**
     * In case the ActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
  }


  /**
   * ActivityLog delete
   */
  export type ActivityLogDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter which ActivityLog to delete.
     */
    where: ActivityLogWhereUniqueInput
  }


  /**
   * ActivityLog deleteMany
   */
  export type ActivityLogDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLogs to delete
     */
    where?: ActivityLogWhereInput
  }


  /**
   * ActivityLog without action
   */
  export type ActivityLogArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityLogInclude<ExtArgs> | null
  }



  /**
   * Model Report
   */


  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportAvgAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type ReportSumAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type ReportMinAggregateOutputType = {
    id: number | null
    userid: number | null
    reporttype: string | null
    generatedat: Date | null
    ipfshash: string | null
  }

  export type ReportMaxAggregateOutputType = {
    id: number | null
    userid: number | null
    reporttype: string | null
    generatedat: Date | null
    ipfshash: string | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    userid: number
    reporttype: number
    filters: number
    generatedat: number
    ipfshash: number
    _all: number
  }


  export type ReportAvgAggregateInputType = {
    id?: true
    userid?: true
  }

  export type ReportSumAggregateInputType = {
    id?: true
    userid?: true
  }

  export type ReportMinAggregateInputType = {
    id?: true
    userid?: true
    reporttype?: true
    generatedat?: true
    ipfshash?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    userid?: true
    reporttype?: true
    generatedat?: true
    ipfshash?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    userid?: true
    reporttype?: true
    filters?: true
    generatedat?: true
    ipfshash?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: Enumerable<ReportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: Enumerable<ReportOrderByWithAggregationInput>
    by: ReportScalarFieldEnum[]
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _avg?: ReportAvgAggregateInputType
    _sum?: ReportSumAggregateInputType
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }


  export type ReportGroupByOutputType = {
    id: number
    userid: number | null
    reporttype: string
    filters: JsonValue | null
    generatedat: Date | null
    ipfshash: string | null
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    reporttype?: boolean
    filters?: boolean
    generatedat?: boolean
    ipfshash?: boolean
    users?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    id?: boolean
    userid?: boolean
    reporttype?: boolean
    filters?: boolean
    generatedat?: boolean
    ipfshash?: boolean
  }

  export type ReportInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    users?: boolean | UserArgs<ExtArgs>
  }


  type ReportGetPayload<S extends boolean | null | undefined | ReportArgs> = $Types.GetResult<ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ReportFindManyArgs, 'select' | 'include'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReportFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Report'> extends True ? Prisma__ReportClient<$Types.GetResult<ReportPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ReportClient<$Types.GetResult<ReportPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Report that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReportClient<$Types.GetResult<ReportPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReportFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Report'> extends True ? Prisma__ReportClient<$Types.GetResult<ReportPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ReportClient<$Types.GetResult<ReportPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Report that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReportClient<$Types.GetResult<ReportPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReportFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ReportPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
    **/
    create<T extends ReportCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReportCreateArgs<ExtArgs>>
    ): Prisma__ReportClient<$Types.GetResult<ReportPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Reports.
     *     @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     *     @example
     *     // Create many Reports
     *     const report = await prisma.report.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReportCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
    **/
    delete<T extends ReportDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>
    ): Prisma__ReportClient<$Types.GetResult<ReportPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReportUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>
    ): Prisma__ReportClient<$Types.GetResult<ReportPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReportDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReportUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
    **/
    upsert<T extends ReportUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>
    ): Prisma__ReportClient<$Types.GetResult<ReportPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    users<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Report base type for findUnique actions
   */
  export type ReportFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUnique
   */
  export interface ReportFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ReportFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }


  /**
   * Report base type for findFirst actions
   */
  export type ReportFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: Enumerable<ReportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: Enumerable<ReportScalarFieldEnum>
  }

  /**
   * Report findFirst
   */
  export interface ReportFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ReportFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: Enumerable<ReportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: Enumerable<ReportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }


  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: Enumerable<ReportCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }


  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
  }


  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }


  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }


  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
  }


  /**
   * Report without action
   */
  export type ReportArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
  }



  /**
   * Model DispenseRecord
   */


  export type AggregateDispenseRecord = {
    _count: DispenseRecordCountAggregateOutputType | null
    _avg: DispenseRecordAvgAggregateOutputType | null
    _sum: DispenseRecordSumAggregateOutputType | null
    _min: DispenseRecordMinAggregateOutputType | null
    _max: DispenseRecordMaxAggregateOutputType | null
  }

  export type DispenseRecordAvgAggregateOutputType = {
    id: number | null
    prescriptionid: number | null
    pharmacistid: number | null
    drugbatchid: number | null
    quantity: number | null
  }

  export type DispenseRecordSumAggregateOutputType = {
    id: number | null
    prescriptionid: number | null
    pharmacistid: number | null
    drugbatchid: number | null
    quantity: number | null
  }

  export type DispenseRecordMinAggregateOutputType = {
    id: number | null
    prescriptionid: number | null
    pharmacistid: number | null
    drugbatchid: number | null
    quantity: number | null
    dispensedat: Date | null
    blockchaintx: string | null
  }

  export type DispenseRecordMaxAggregateOutputType = {
    id: number | null
    prescriptionid: number | null
    pharmacistid: number | null
    drugbatchid: number | null
    quantity: number | null
    dispensedat: Date | null
    blockchaintx: string | null
  }

  export type DispenseRecordCountAggregateOutputType = {
    id: number
    prescriptionid: number
    pharmacistid: number
    drugbatchid: number
    quantity: number
    dispensedat: number
    blockchaintx: number
    _all: number
  }


  export type DispenseRecordAvgAggregateInputType = {
    id?: true
    prescriptionid?: true
    pharmacistid?: true
    drugbatchid?: true
    quantity?: true
  }

  export type DispenseRecordSumAggregateInputType = {
    id?: true
    prescriptionid?: true
    pharmacistid?: true
    drugbatchid?: true
    quantity?: true
  }

  export type DispenseRecordMinAggregateInputType = {
    id?: true
    prescriptionid?: true
    pharmacistid?: true
    drugbatchid?: true
    quantity?: true
    dispensedat?: true
    blockchaintx?: true
  }

  export type DispenseRecordMaxAggregateInputType = {
    id?: true
    prescriptionid?: true
    pharmacistid?: true
    drugbatchid?: true
    quantity?: true
    dispensedat?: true
    blockchaintx?: true
  }

  export type DispenseRecordCountAggregateInputType = {
    id?: true
    prescriptionid?: true
    pharmacistid?: true
    drugbatchid?: true
    quantity?: true
    dispensedat?: true
    blockchaintx?: true
    _all?: true
  }

  export type DispenseRecordAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DispenseRecord to aggregate.
     */
    where?: DispenseRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DispenseRecords to fetch.
     */
    orderBy?: Enumerable<DispenseRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DispenseRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DispenseRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DispenseRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DispenseRecords
    **/
    _count?: true | DispenseRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DispenseRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DispenseRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DispenseRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DispenseRecordMaxAggregateInputType
  }

  export type GetDispenseRecordAggregateType<T extends DispenseRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateDispenseRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDispenseRecord[P]>
      : GetScalarType<T[P], AggregateDispenseRecord[P]>
  }




  export type DispenseRecordGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DispenseRecordWhereInput
    orderBy?: Enumerable<DispenseRecordOrderByWithAggregationInput>
    by: DispenseRecordScalarFieldEnum[]
    having?: DispenseRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DispenseRecordCountAggregateInputType | true
    _avg?: DispenseRecordAvgAggregateInputType
    _sum?: DispenseRecordSumAggregateInputType
    _min?: DispenseRecordMinAggregateInputType
    _max?: DispenseRecordMaxAggregateInputType
  }


  export type DispenseRecordGroupByOutputType = {
    id: number
    prescriptionid: number | null
    pharmacistid: number | null
    drugbatchid: number | null
    quantity: number
    dispensedat: Date | null
    blockchaintx: string | null
    _count: DispenseRecordCountAggregateOutputType | null
    _avg: DispenseRecordAvgAggregateOutputType | null
    _sum: DispenseRecordSumAggregateOutputType | null
    _min: DispenseRecordMinAggregateOutputType | null
    _max: DispenseRecordMaxAggregateOutputType | null
  }

  type GetDispenseRecordGroupByPayload<T extends DispenseRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DispenseRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DispenseRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DispenseRecordGroupByOutputType[P]>
            : GetScalarType<T[P], DispenseRecordGroupByOutputType[P]>
        }
      >
    >


  export type DispenseRecordSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prescriptionid?: boolean
    pharmacistid?: boolean
    drugbatchid?: boolean
    quantity?: boolean
    dispensedat?: boolean
    blockchaintx?: boolean
    drugbatch?: boolean | DrugBatchArgs<ExtArgs>
    pharmacist?: boolean | PharmacistArgs<ExtArgs>
    prescription?: boolean | PrescriptionArgs<ExtArgs>
  }, ExtArgs["result"]["dispenseRecord"]>

  export type DispenseRecordSelectScalar = {
    id?: boolean
    prescriptionid?: boolean
    pharmacistid?: boolean
    drugbatchid?: boolean
    quantity?: boolean
    dispensedat?: boolean
    blockchaintx?: boolean
  }

  export type DispenseRecordInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    drugbatch?: boolean | DrugBatchArgs<ExtArgs>
    pharmacist?: boolean | PharmacistArgs<ExtArgs>
    prescription?: boolean | PrescriptionArgs<ExtArgs>
  }


  type DispenseRecordGetPayload<S extends boolean | null | undefined | DispenseRecordArgs> = $Types.GetResult<DispenseRecordPayload, S>

  type DispenseRecordCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DispenseRecordFindManyArgs, 'select' | 'include'> & {
      select?: DispenseRecordCountAggregateInputType | true
    }

  export interface DispenseRecordDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DispenseRecord'], meta: { name: 'DispenseRecord' } }
    /**
     * Find zero or one DispenseRecord that matches the filter.
     * @param {DispenseRecordFindUniqueArgs} args - Arguments to find a DispenseRecord
     * @example
     * // Get one DispenseRecord
     * const dispenseRecord = await prisma.dispenseRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DispenseRecordFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DispenseRecordFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DispenseRecord'> extends True ? Prisma__DispenseRecordClient<$Types.GetResult<DispenseRecordPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__DispenseRecordClient<$Types.GetResult<DispenseRecordPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one DispenseRecord that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DispenseRecordFindUniqueOrThrowArgs} args - Arguments to find a DispenseRecord
     * @example
     * // Get one DispenseRecord
     * const dispenseRecord = await prisma.dispenseRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DispenseRecordFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DispenseRecordFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DispenseRecordClient<$Types.GetResult<DispenseRecordPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first DispenseRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispenseRecordFindFirstArgs} args - Arguments to find a DispenseRecord
     * @example
     * // Get one DispenseRecord
     * const dispenseRecord = await prisma.dispenseRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DispenseRecordFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DispenseRecordFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DispenseRecord'> extends True ? Prisma__DispenseRecordClient<$Types.GetResult<DispenseRecordPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__DispenseRecordClient<$Types.GetResult<DispenseRecordPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first DispenseRecord that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispenseRecordFindFirstOrThrowArgs} args - Arguments to find a DispenseRecord
     * @example
     * // Get one DispenseRecord
     * const dispenseRecord = await prisma.dispenseRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DispenseRecordFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DispenseRecordFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DispenseRecordClient<$Types.GetResult<DispenseRecordPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more DispenseRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispenseRecordFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DispenseRecords
     * const dispenseRecords = await prisma.dispenseRecord.findMany()
     * 
     * // Get first 10 DispenseRecords
     * const dispenseRecords = await prisma.dispenseRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dispenseRecordWithIdOnly = await prisma.dispenseRecord.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DispenseRecordFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DispenseRecordFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<DispenseRecordPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a DispenseRecord.
     * @param {DispenseRecordCreateArgs} args - Arguments to create a DispenseRecord.
     * @example
     * // Create one DispenseRecord
     * const DispenseRecord = await prisma.dispenseRecord.create({
     *   data: {
     *     // ... data to create a DispenseRecord
     *   }
     * })
     * 
    **/
    create<T extends DispenseRecordCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DispenseRecordCreateArgs<ExtArgs>>
    ): Prisma__DispenseRecordClient<$Types.GetResult<DispenseRecordPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many DispenseRecords.
     *     @param {DispenseRecordCreateManyArgs} args - Arguments to create many DispenseRecords.
     *     @example
     *     // Create many DispenseRecords
     *     const dispenseRecord = await prisma.dispenseRecord.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DispenseRecordCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DispenseRecordCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DispenseRecord.
     * @param {DispenseRecordDeleteArgs} args - Arguments to delete one DispenseRecord.
     * @example
     * // Delete one DispenseRecord
     * const DispenseRecord = await prisma.dispenseRecord.delete({
     *   where: {
     *     // ... filter to delete one DispenseRecord
     *   }
     * })
     * 
    **/
    delete<T extends DispenseRecordDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DispenseRecordDeleteArgs<ExtArgs>>
    ): Prisma__DispenseRecordClient<$Types.GetResult<DispenseRecordPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one DispenseRecord.
     * @param {DispenseRecordUpdateArgs} args - Arguments to update one DispenseRecord.
     * @example
     * // Update one DispenseRecord
     * const dispenseRecord = await prisma.dispenseRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DispenseRecordUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DispenseRecordUpdateArgs<ExtArgs>>
    ): Prisma__DispenseRecordClient<$Types.GetResult<DispenseRecordPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more DispenseRecords.
     * @param {DispenseRecordDeleteManyArgs} args - Arguments to filter DispenseRecords to delete.
     * @example
     * // Delete a few DispenseRecords
     * const { count } = await prisma.dispenseRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DispenseRecordDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DispenseRecordDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DispenseRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispenseRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DispenseRecords
     * const dispenseRecord = await prisma.dispenseRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DispenseRecordUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DispenseRecordUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DispenseRecord.
     * @param {DispenseRecordUpsertArgs} args - Arguments to update or create a DispenseRecord.
     * @example
     * // Update or create a DispenseRecord
     * const dispenseRecord = await prisma.dispenseRecord.upsert({
     *   create: {
     *     // ... data to create a DispenseRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DispenseRecord we want to update
     *   }
     * })
    **/
    upsert<T extends DispenseRecordUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DispenseRecordUpsertArgs<ExtArgs>>
    ): Prisma__DispenseRecordClient<$Types.GetResult<DispenseRecordPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of DispenseRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispenseRecordCountArgs} args - Arguments to filter DispenseRecords to count.
     * @example
     * // Count the number of DispenseRecords
     * const count = await prisma.dispenseRecord.count({
     *   where: {
     *     // ... the filter for the DispenseRecords we want to count
     *   }
     * })
    **/
    count<T extends DispenseRecordCountArgs>(
      args?: Subset<T, DispenseRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DispenseRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DispenseRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispenseRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DispenseRecordAggregateArgs>(args: Subset<T, DispenseRecordAggregateArgs>): Prisma.PrismaPromise<GetDispenseRecordAggregateType<T>>

    /**
     * Group by DispenseRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispenseRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DispenseRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DispenseRecordGroupByArgs['orderBy'] }
        : { orderBy?: DispenseRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DispenseRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDispenseRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DispenseRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DispenseRecordClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    drugbatch<T extends DrugBatchArgs<ExtArgs> = {}>(args?: Subset<T, DrugBatchArgs<ExtArgs>>): Prisma__DrugBatchClient<$Types.GetResult<DrugBatchPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    pharmacist<T extends PharmacistArgs<ExtArgs> = {}>(args?: Subset<T, PharmacistArgs<ExtArgs>>): Prisma__PharmacistClient<$Types.GetResult<PharmacistPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    prescription<T extends PrescriptionArgs<ExtArgs> = {}>(args?: Subset<T, PrescriptionArgs<ExtArgs>>): Prisma__PrescriptionClient<$Types.GetResult<PrescriptionPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DispenseRecord base type for findUnique actions
   */
  export type DispenseRecordFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispenseRecord
     */
    select?: DispenseRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DispenseRecordInclude<ExtArgs> | null
    /**
     * Filter, which DispenseRecord to fetch.
     */
    where: DispenseRecordWhereUniqueInput
  }

  /**
   * DispenseRecord findUnique
   */
  export interface DispenseRecordFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DispenseRecordFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DispenseRecord findUniqueOrThrow
   */
  export type DispenseRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispenseRecord
     */
    select?: DispenseRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DispenseRecordInclude<ExtArgs> | null
    /**
     * Filter, which DispenseRecord to fetch.
     */
    where: DispenseRecordWhereUniqueInput
  }


  /**
   * DispenseRecord base type for findFirst actions
   */
  export type DispenseRecordFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispenseRecord
     */
    select?: DispenseRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DispenseRecordInclude<ExtArgs> | null
    /**
     * Filter, which DispenseRecord to fetch.
     */
    where?: DispenseRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DispenseRecords to fetch.
     */
    orderBy?: Enumerable<DispenseRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DispenseRecords.
     */
    cursor?: DispenseRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DispenseRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DispenseRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DispenseRecords.
     */
    distinct?: Enumerable<DispenseRecordScalarFieldEnum>
  }

  /**
   * DispenseRecord findFirst
   */
  export interface DispenseRecordFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DispenseRecordFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DispenseRecord findFirstOrThrow
   */
  export type DispenseRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispenseRecord
     */
    select?: DispenseRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DispenseRecordInclude<ExtArgs> | null
    /**
     * Filter, which DispenseRecord to fetch.
     */
    where?: DispenseRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DispenseRecords to fetch.
     */
    orderBy?: Enumerable<DispenseRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DispenseRecords.
     */
    cursor?: DispenseRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DispenseRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DispenseRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DispenseRecords.
     */
    distinct?: Enumerable<DispenseRecordScalarFieldEnum>
  }


  /**
   * DispenseRecord findMany
   */
  export type DispenseRecordFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispenseRecord
     */
    select?: DispenseRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DispenseRecordInclude<ExtArgs> | null
    /**
     * Filter, which DispenseRecords to fetch.
     */
    where?: DispenseRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DispenseRecords to fetch.
     */
    orderBy?: Enumerable<DispenseRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DispenseRecords.
     */
    cursor?: DispenseRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DispenseRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DispenseRecords.
     */
    skip?: number
    distinct?: Enumerable<DispenseRecordScalarFieldEnum>
  }


  /**
   * DispenseRecord create
   */
  export type DispenseRecordCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispenseRecord
     */
    select?: DispenseRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DispenseRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a DispenseRecord.
     */
    data: XOR<DispenseRecordCreateInput, DispenseRecordUncheckedCreateInput>
  }


  /**
   * DispenseRecord createMany
   */
  export type DispenseRecordCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DispenseRecords.
     */
    data: Enumerable<DispenseRecordCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DispenseRecord update
   */
  export type DispenseRecordUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispenseRecord
     */
    select?: DispenseRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DispenseRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a DispenseRecord.
     */
    data: XOR<DispenseRecordUpdateInput, DispenseRecordUncheckedUpdateInput>
    /**
     * Choose, which DispenseRecord to update.
     */
    where: DispenseRecordWhereUniqueInput
  }


  /**
   * DispenseRecord updateMany
   */
  export type DispenseRecordUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DispenseRecords.
     */
    data: XOR<DispenseRecordUpdateManyMutationInput, DispenseRecordUncheckedUpdateManyInput>
    /**
     * Filter which DispenseRecords to update
     */
    where?: DispenseRecordWhereInput
  }


  /**
   * DispenseRecord upsert
   */
  export type DispenseRecordUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispenseRecord
     */
    select?: DispenseRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DispenseRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the DispenseRecord to update in case it exists.
     */
    where: DispenseRecordWhereUniqueInput
    /**
     * In case the DispenseRecord found by the `where` argument doesn't exist, create a new DispenseRecord with this data.
     */
    create: XOR<DispenseRecordCreateInput, DispenseRecordUncheckedCreateInput>
    /**
     * In case the DispenseRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DispenseRecordUpdateInput, DispenseRecordUncheckedUpdateInput>
  }


  /**
   * DispenseRecord delete
   */
  export type DispenseRecordDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispenseRecord
     */
    select?: DispenseRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DispenseRecordInclude<ExtArgs> | null
    /**
     * Filter which DispenseRecord to delete.
     */
    where: DispenseRecordWhereUniqueInput
  }


  /**
   * DispenseRecord deleteMany
   */
  export type DispenseRecordDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DispenseRecords to delete
     */
    where?: DispenseRecordWhereInput
  }


  /**
   * DispenseRecord without action
   */
  export type DispenseRecordArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DispenseRecord
     */
    select?: DispenseRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DispenseRecordInclude<ExtArgs> | null
  }



  /**
   * Model BlockchainEventLog
   */


  export type AggregateBlockchainEventLog = {
    _count: BlockchainEventLogCountAggregateOutputType | null
    _avg: BlockchainEventLogAvgAggregateOutputType | null
    _sum: BlockchainEventLogSumAggregateOutputType | null
    _min: BlockchainEventLogMinAggregateOutputType | null
    _max: BlockchainEventLogMaxAggregateOutputType | null
  }

  export type BlockchainEventLogAvgAggregateOutputType = {
    id: number | null
    entityid: number | null
  }

  export type BlockchainEventLogSumAggregateOutputType = {
    id: number | null
    entityid: number | null
  }

  export type BlockchainEventLogMinAggregateOutputType = {
    id: number | null
    eventname: string | null
    contractname: string | null
    entityid: number | null
    entitytype: string | null
    transactionhash: string | null
    timestamp: Date | null
    processed: boolean | null
  }

  export type BlockchainEventLogMaxAggregateOutputType = {
    id: number | null
    eventname: string | null
    contractname: string | null
    entityid: number | null
    entitytype: string | null
    transactionhash: string | null
    timestamp: Date | null
    processed: boolean | null
  }

  export type BlockchainEventLogCountAggregateOutputType = {
    id: number
    eventname: number
    contractname: number
    entityid: number
    entitytype: number
    transactionhash: number
    timestamp: number
    processed: number
    _all: number
  }


  export type BlockchainEventLogAvgAggregateInputType = {
    id?: true
    entityid?: true
  }

  export type BlockchainEventLogSumAggregateInputType = {
    id?: true
    entityid?: true
  }

  export type BlockchainEventLogMinAggregateInputType = {
    id?: true
    eventname?: true
    contractname?: true
    entityid?: true
    entitytype?: true
    transactionhash?: true
    timestamp?: true
    processed?: true
  }

  export type BlockchainEventLogMaxAggregateInputType = {
    id?: true
    eventname?: true
    contractname?: true
    entityid?: true
    entitytype?: true
    transactionhash?: true
    timestamp?: true
    processed?: true
  }

  export type BlockchainEventLogCountAggregateInputType = {
    id?: true
    eventname?: true
    contractname?: true
    entityid?: true
    entitytype?: true
    transactionhash?: true
    timestamp?: true
    processed?: true
    _all?: true
  }

  export type BlockchainEventLogAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockchainEventLog to aggregate.
     */
    where?: BlockchainEventLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockchainEventLogs to fetch.
     */
    orderBy?: Enumerable<BlockchainEventLogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockchainEventLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockchainEventLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockchainEventLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlockchainEventLogs
    **/
    _count?: true | BlockchainEventLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlockchainEventLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlockchainEventLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockchainEventLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockchainEventLogMaxAggregateInputType
  }

  export type GetBlockchainEventLogAggregateType<T extends BlockchainEventLogAggregateArgs> = {
        [P in keyof T & keyof AggregateBlockchainEventLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlockchainEventLog[P]>
      : GetScalarType<T[P], AggregateBlockchainEventLog[P]>
  }




  export type BlockchainEventLogGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BlockchainEventLogWhereInput
    orderBy?: Enumerable<BlockchainEventLogOrderByWithAggregationInput>
    by: BlockchainEventLogScalarFieldEnum[]
    having?: BlockchainEventLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockchainEventLogCountAggregateInputType | true
    _avg?: BlockchainEventLogAvgAggregateInputType
    _sum?: BlockchainEventLogSumAggregateInputType
    _min?: BlockchainEventLogMinAggregateInputType
    _max?: BlockchainEventLogMaxAggregateInputType
  }


  export type BlockchainEventLogGroupByOutputType = {
    id: number
    eventname: string
    contractname: string
    entityid: number | null
    entitytype: string | null
    transactionhash: string
    timestamp: Date | null
    processed: boolean | null
    _count: BlockchainEventLogCountAggregateOutputType | null
    _avg: BlockchainEventLogAvgAggregateOutputType | null
    _sum: BlockchainEventLogSumAggregateOutputType | null
    _min: BlockchainEventLogMinAggregateOutputType | null
    _max: BlockchainEventLogMaxAggregateOutputType | null
  }

  type GetBlockchainEventLogGroupByPayload<T extends BlockchainEventLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BlockchainEventLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockchainEventLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockchainEventLogGroupByOutputType[P]>
            : GetScalarType<T[P], BlockchainEventLogGroupByOutputType[P]>
        }
      >
    >


  export type BlockchainEventLogSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventname?: boolean
    contractname?: boolean
    entityid?: boolean
    entitytype?: boolean
    transactionhash?: boolean
    timestamp?: boolean
    processed?: boolean
    drugbatch?: boolean | DrugBatchArgs<ExtArgs>
    prescription?: boolean | PrescriptionArgs<ExtArgs>
    supplychainrecord?: boolean | SupplyChainRecordArgs<ExtArgs>
  }, ExtArgs["result"]["blockchainEventLog"]>

  export type BlockchainEventLogSelectScalar = {
    id?: boolean
    eventname?: boolean
    contractname?: boolean
    entityid?: boolean
    entitytype?: boolean
    transactionhash?: boolean
    timestamp?: boolean
    processed?: boolean
  }

  export type BlockchainEventLogInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    drugbatch?: boolean | DrugBatchArgs<ExtArgs>
    prescription?: boolean | PrescriptionArgs<ExtArgs>
    supplychainrecord?: boolean | SupplyChainRecordArgs<ExtArgs>
  }


  type BlockchainEventLogGetPayload<S extends boolean | null | undefined | BlockchainEventLogArgs> = $Types.GetResult<BlockchainEventLogPayload, S>

  type BlockchainEventLogCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BlockchainEventLogFindManyArgs, 'select' | 'include'> & {
      select?: BlockchainEventLogCountAggregateInputType | true
    }

  export interface BlockchainEventLogDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlockchainEventLog'], meta: { name: 'BlockchainEventLog' } }
    /**
     * Find zero or one BlockchainEventLog that matches the filter.
     * @param {BlockchainEventLogFindUniqueArgs} args - Arguments to find a BlockchainEventLog
     * @example
     * // Get one BlockchainEventLog
     * const blockchainEventLog = await prisma.blockchainEventLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BlockchainEventLogFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BlockchainEventLogFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BlockchainEventLog'> extends True ? Prisma__BlockchainEventLogClient<$Types.GetResult<BlockchainEventLogPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__BlockchainEventLogClient<$Types.GetResult<BlockchainEventLogPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one BlockchainEventLog that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BlockchainEventLogFindUniqueOrThrowArgs} args - Arguments to find a BlockchainEventLog
     * @example
     * // Get one BlockchainEventLog
     * const blockchainEventLog = await prisma.blockchainEventLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BlockchainEventLogFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BlockchainEventLogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BlockchainEventLogClient<$Types.GetResult<BlockchainEventLogPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first BlockchainEventLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainEventLogFindFirstArgs} args - Arguments to find a BlockchainEventLog
     * @example
     * // Get one BlockchainEventLog
     * const blockchainEventLog = await prisma.blockchainEventLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BlockchainEventLogFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BlockchainEventLogFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BlockchainEventLog'> extends True ? Prisma__BlockchainEventLogClient<$Types.GetResult<BlockchainEventLogPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__BlockchainEventLogClient<$Types.GetResult<BlockchainEventLogPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first BlockchainEventLog that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainEventLogFindFirstOrThrowArgs} args - Arguments to find a BlockchainEventLog
     * @example
     * // Get one BlockchainEventLog
     * const blockchainEventLog = await prisma.blockchainEventLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BlockchainEventLogFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BlockchainEventLogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BlockchainEventLogClient<$Types.GetResult<BlockchainEventLogPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more BlockchainEventLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainEventLogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlockchainEventLogs
     * const blockchainEventLogs = await prisma.blockchainEventLog.findMany()
     * 
     * // Get first 10 BlockchainEventLogs
     * const blockchainEventLogs = await prisma.blockchainEventLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockchainEventLogWithIdOnly = await prisma.blockchainEventLog.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BlockchainEventLogFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BlockchainEventLogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<BlockchainEventLogPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a BlockchainEventLog.
     * @param {BlockchainEventLogCreateArgs} args - Arguments to create a BlockchainEventLog.
     * @example
     * // Create one BlockchainEventLog
     * const BlockchainEventLog = await prisma.blockchainEventLog.create({
     *   data: {
     *     // ... data to create a BlockchainEventLog
     *   }
     * })
     * 
    **/
    create<T extends BlockchainEventLogCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BlockchainEventLogCreateArgs<ExtArgs>>
    ): Prisma__BlockchainEventLogClient<$Types.GetResult<BlockchainEventLogPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many BlockchainEventLogs.
     *     @param {BlockchainEventLogCreateManyArgs} args - Arguments to create many BlockchainEventLogs.
     *     @example
     *     // Create many BlockchainEventLogs
     *     const blockchainEventLog = await prisma.blockchainEventLog.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BlockchainEventLogCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BlockchainEventLogCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BlockchainEventLog.
     * @param {BlockchainEventLogDeleteArgs} args - Arguments to delete one BlockchainEventLog.
     * @example
     * // Delete one BlockchainEventLog
     * const BlockchainEventLog = await prisma.blockchainEventLog.delete({
     *   where: {
     *     // ... filter to delete one BlockchainEventLog
     *   }
     * })
     * 
    **/
    delete<T extends BlockchainEventLogDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BlockchainEventLogDeleteArgs<ExtArgs>>
    ): Prisma__BlockchainEventLogClient<$Types.GetResult<BlockchainEventLogPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one BlockchainEventLog.
     * @param {BlockchainEventLogUpdateArgs} args - Arguments to update one BlockchainEventLog.
     * @example
     * // Update one BlockchainEventLog
     * const blockchainEventLog = await prisma.blockchainEventLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BlockchainEventLogUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BlockchainEventLogUpdateArgs<ExtArgs>>
    ): Prisma__BlockchainEventLogClient<$Types.GetResult<BlockchainEventLogPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more BlockchainEventLogs.
     * @param {BlockchainEventLogDeleteManyArgs} args - Arguments to filter BlockchainEventLogs to delete.
     * @example
     * // Delete a few BlockchainEventLogs
     * const { count } = await prisma.blockchainEventLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BlockchainEventLogDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BlockchainEventLogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlockchainEventLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainEventLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlockchainEventLogs
     * const blockchainEventLog = await prisma.blockchainEventLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BlockchainEventLogUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BlockchainEventLogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlockchainEventLog.
     * @param {BlockchainEventLogUpsertArgs} args - Arguments to update or create a BlockchainEventLog.
     * @example
     * // Update or create a BlockchainEventLog
     * const blockchainEventLog = await prisma.blockchainEventLog.upsert({
     *   create: {
     *     // ... data to create a BlockchainEventLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlockchainEventLog we want to update
     *   }
     * })
    **/
    upsert<T extends BlockchainEventLogUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BlockchainEventLogUpsertArgs<ExtArgs>>
    ): Prisma__BlockchainEventLogClient<$Types.GetResult<BlockchainEventLogPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of BlockchainEventLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainEventLogCountArgs} args - Arguments to filter BlockchainEventLogs to count.
     * @example
     * // Count the number of BlockchainEventLogs
     * const count = await prisma.blockchainEventLog.count({
     *   where: {
     *     // ... the filter for the BlockchainEventLogs we want to count
     *   }
     * })
    **/
    count<T extends BlockchainEventLogCountArgs>(
      args?: Subset<T, BlockchainEventLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockchainEventLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlockchainEventLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainEventLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockchainEventLogAggregateArgs>(args: Subset<T, BlockchainEventLogAggregateArgs>): Prisma.PrismaPromise<GetBlockchainEventLogAggregateType<T>>

    /**
     * Group by BlockchainEventLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockchainEventLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockchainEventLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockchainEventLogGroupByArgs['orderBy'] }
        : { orderBy?: BlockchainEventLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockchainEventLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockchainEventLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BlockchainEventLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BlockchainEventLogClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    drugbatch<T extends DrugBatchArgs<ExtArgs> = {}>(args?: Subset<T, DrugBatchArgs<ExtArgs>>): Prisma__DrugBatchClient<$Types.GetResult<DrugBatchPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    prescription<T extends PrescriptionArgs<ExtArgs> = {}>(args?: Subset<T, PrescriptionArgs<ExtArgs>>): Prisma__PrescriptionClient<$Types.GetResult<PrescriptionPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    supplychainrecord<T extends SupplyChainRecordArgs<ExtArgs> = {}>(args?: Subset<T, SupplyChainRecordArgs<ExtArgs>>): Prisma__SupplyChainRecordClient<$Types.GetResult<SupplyChainRecordPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BlockchainEventLog base type for findUnique actions
   */
  export type BlockchainEventLogFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainEventLog
     */
    select?: BlockchainEventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockchainEventLogInclude<ExtArgs> | null
    /**
     * Filter, which BlockchainEventLog to fetch.
     */
    where: BlockchainEventLogWhereUniqueInput
  }

  /**
   * BlockchainEventLog findUnique
   */
  export interface BlockchainEventLogFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BlockchainEventLogFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BlockchainEventLog findUniqueOrThrow
   */
  export type BlockchainEventLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainEventLog
     */
    select?: BlockchainEventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockchainEventLogInclude<ExtArgs> | null
    /**
     * Filter, which BlockchainEventLog to fetch.
     */
    where: BlockchainEventLogWhereUniqueInput
  }


  /**
   * BlockchainEventLog base type for findFirst actions
   */
  export type BlockchainEventLogFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainEventLog
     */
    select?: BlockchainEventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockchainEventLogInclude<ExtArgs> | null
    /**
     * Filter, which BlockchainEventLog to fetch.
     */
    where?: BlockchainEventLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockchainEventLogs to fetch.
     */
    orderBy?: Enumerable<BlockchainEventLogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockchainEventLogs.
     */
    cursor?: BlockchainEventLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockchainEventLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockchainEventLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockchainEventLogs.
     */
    distinct?: Enumerable<BlockchainEventLogScalarFieldEnum>
  }

  /**
   * BlockchainEventLog findFirst
   */
  export interface BlockchainEventLogFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BlockchainEventLogFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BlockchainEventLog findFirstOrThrow
   */
  export type BlockchainEventLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainEventLog
     */
    select?: BlockchainEventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockchainEventLogInclude<ExtArgs> | null
    /**
     * Filter, which BlockchainEventLog to fetch.
     */
    where?: BlockchainEventLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockchainEventLogs to fetch.
     */
    orderBy?: Enumerable<BlockchainEventLogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockchainEventLogs.
     */
    cursor?: BlockchainEventLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockchainEventLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockchainEventLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockchainEventLogs.
     */
    distinct?: Enumerable<BlockchainEventLogScalarFieldEnum>
  }


  /**
   * BlockchainEventLog findMany
   */
  export type BlockchainEventLogFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainEventLog
     */
    select?: BlockchainEventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockchainEventLogInclude<ExtArgs> | null
    /**
     * Filter, which BlockchainEventLogs to fetch.
     */
    where?: BlockchainEventLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockchainEventLogs to fetch.
     */
    orderBy?: Enumerable<BlockchainEventLogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlockchainEventLogs.
     */
    cursor?: BlockchainEventLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockchainEventLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockchainEventLogs.
     */
    skip?: number
    distinct?: Enumerable<BlockchainEventLogScalarFieldEnum>
  }


  /**
   * BlockchainEventLog create
   */
  export type BlockchainEventLogCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainEventLog
     */
    select?: BlockchainEventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockchainEventLogInclude<ExtArgs> | null
    /**
     * The data needed to create a BlockchainEventLog.
     */
    data: XOR<BlockchainEventLogCreateInput, BlockchainEventLogUncheckedCreateInput>
  }


  /**
   * BlockchainEventLog createMany
   */
  export type BlockchainEventLogCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlockchainEventLogs.
     */
    data: Enumerable<BlockchainEventLogCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BlockchainEventLog update
   */
  export type BlockchainEventLogUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainEventLog
     */
    select?: BlockchainEventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockchainEventLogInclude<ExtArgs> | null
    /**
     * The data needed to update a BlockchainEventLog.
     */
    data: XOR<BlockchainEventLogUpdateInput, BlockchainEventLogUncheckedUpdateInput>
    /**
     * Choose, which BlockchainEventLog to update.
     */
    where: BlockchainEventLogWhereUniqueInput
  }


  /**
   * BlockchainEventLog updateMany
   */
  export type BlockchainEventLogUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlockchainEventLogs.
     */
    data: XOR<BlockchainEventLogUpdateManyMutationInput, BlockchainEventLogUncheckedUpdateManyInput>
    /**
     * Filter which BlockchainEventLogs to update
     */
    where?: BlockchainEventLogWhereInput
  }


  /**
   * BlockchainEventLog upsert
   */
  export type BlockchainEventLogUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainEventLog
     */
    select?: BlockchainEventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockchainEventLogInclude<ExtArgs> | null
    /**
     * The filter to search for the BlockchainEventLog to update in case it exists.
     */
    where: BlockchainEventLogWhereUniqueInput
    /**
     * In case the BlockchainEventLog found by the `where` argument doesn't exist, create a new BlockchainEventLog with this data.
     */
    create: XOR<BlockchainEventLogCreateInput, BlockchainEventLogUncheckedCreateInput>
    /**
     * In case the BlockchainEventLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockchainEventLogUpdateInput, BlockchainEventLogUncheckedUpdateInput>
  }


  /**
   * BlockchainEventLog delete
   */
  export type BlockchainEventLogDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainEventLog
     */
    select?: BlockchainEventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockchainEventLogInclude<ExtArgs> | null
    /**
     * Filter which BlockchainEventLog to delete.
     */
    where: BlockchainEventLogWhereUniqueInput
  }


  /**
   * BlockchainEventLog deleteMany
   */
  export type BlockchainEventLogDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockchainEventLogs to delete
     */
    where?: BlockchainEventLogWhereInput
  }


  /**
   * BlockchainEventLog without action
   */
  export type BlockchainEventLogArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockchainEventLog
     */
    select?: BlockchainEventLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlockchainEventLogInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    wallet: 'wallet',
    email: 'email',
    passwordhash: 'passwordhash',
    roleid: 'roleid',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const DoctorScalarFieldEnum: {
    id: 'id',
    userid: 'userid',
    licenseno: 'licenseno',
    hospital: 'hospital'
  };

  export type DoctorScalarFieldEnum = (typeof DoctorScalarFieldEnum)[keyof typeof DoctorScalarFieldEnum]


  export const PatientScalarFieldEnum: {
    id: 'id',
    userid: 'userid',
    dateofbirth: 'dateofbirth'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const PharmacistScalarFieldEnum: {
    id: 'id',
    userid: 'userid',
    licenseno: 'licenseno',
    pharmacy: 'pharmacy'
  };

  export type PharmacistScalarFieldEnum = (typeof PharmacistScalarFieldEnum)[keyof typeof PharmacistScalarFieldEnum]


  export const ManufacturerScalarFieldEnum: {
    id: 'id',
    userid: 'userid',
    companyname: 'companyname'
  };

  export type ManufacturerScalarFieldEnum = (typeof ManufacturerScalarFieldEnum)[keyof typeof ManufacturerScalarFieldEnum]


  export const DistributorScalarFieldEnum: {
    id: 'id',
    userid: 'userid',
    companyname: 'companyname'
  };

  export type DistributorScalarFieldEnum = (typeof DistributorScalarFieldEnum)[keyof typeof DistributorScalarFieldEnum]


  export const RegulatorScalarFieldEnum: {
    id: 'id',
    userid: 'userid',
    agencyname: 'agencyname'
  };

  export type RegulatorScalarFieldEnum = (typeof RegulatorScalarFieldEnum)[keyof typeof RegulatorScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    userid: 'userid'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const DrugScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    formulation: 'formulation',
    dosageunit: 'dosageunit'
  };

  export type DrugScalarFieldEnum = (typeof DrugScalarFieldEnum)[keyof typeof DrugScalarFieldEnum]


  export const PrescriptionScalarFieldEnum: {
    id: 'id',
    patientid: 'patientid',
    doctorid: 'doctorid',
    drugid: 'drugid',
    dosage: 'dosage',
    issuedat: 'issuedat',
    expiresat: 'expiresat',
    blockchaintx: 'blockchaintx',
    qrcode: 'qrcode',
    ipfshash: 'ipfshash',
    status: 'status'
  };

  export type PrescriptionScalarFieldEnum = (typeof PrescriptionScalarFieldEnum)[keyof typeof PrescriptionScalarFieldEnum]


  export const DrugBatchScalarFieldEnum: {
    id: 'id',
    manufacturerid: 'manufacturerid',
    drugid: 'drugid',
    batchnumber: 'batchnumber',
    manufacturedate: 'manufacturedate',
    expirydate: 'expirydate',
    blockchaintx: 'blockchaintx',
    qrcode: 'qrcode',
    ipfshash: 'ipfshash'
  };

  export type DrugBatchScalarFieldEnum = (typeof DrugBatchScalarFieldEnum)[keyof typeof DrugBatchScalarFieldEnum]


  export const SupplyChainRecordScalarFieldEnum: {
    id: 'id',
    drugbatchid: 'drugbatchid',
    fromentityid: 'fromentityid',
    toentityid: 'toentityid',
    action: 'action',
    timestamp: 'timestamp',
    blockchaintx: 'blockchaintx'
  };

  export type SupplyChainRecordScalarFieldEnum = (typeof SupplyChainRecordScalarFieldEnum)[keyof typeof SupplyChainRecordScalarFieldEnum]


  export const RevocationRecordScalarFieldEnum: {
    id: 'id',
    type: 'type',
    refid: 'refid',
    reason: 'reason',
    revokedbyid: 'revokedbyid',
    timestamp: 'timestamp',
    blockchaintx: 'blockchaintx'
  };

  export type RevocationRecordScalarFieldEnum = (typeof RevocationRecordScalarFieldEnum)[keyof typeof RevocationRecordScalarFieldEnum]


  export const OtpScalarFieldEnum: {
    id: 'id',
    userid: 'userid',
    code: 'code',
    expiresat: 'expiresat',
    createdat: 'createdat'
  };

  export type OtpScalarFieldEnum = (typeof OtpScalarFieldEnum)[keyof typeof OtpScalarFieldEnum]


  export const AlertScalarFieldEnum: {
    id: 'id',
    userid: 'userid',
    title: 'title',
    message: 'message',
    isread: 'isread',
    priority: 'priority',
    createdat: 'createdat'
  };

  export type AlertScalarFieldEnum = (typeof AlertScalarFieldEnum)[keyof typeof AlertScalarFieldEnum]


  export const ActivityLogScalarFieldEnum: {
    id: 'id',
    userid: 'userid',
    action: 'action',
    details: 'details',
    timestamp: 'timestamp'
  };

  export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    userid: 'userid',
    reporttype: 'reporttype',
    filters: 'filters',
    generatedat: 'generatedat',
    ipfshash: 'ipfshash'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const DispenseRecordScalarFieldEnum: {
    id: 'id',
    prescriptionid: 'prescriptionid',
    pharmacistid: 'pharmacistid',
    drugbatchid: 'drugbatchid',
    quantity: 'quantity',
    dispensedat: 'dispensedat',
    blockchaintx: 'blockchaintx'
  };

  export type DispenseRecordScalarFieldEnum = (typeof DispenseRecordScalarFieldEnum)[keyof typeof DispenseRecordScalarFieldEnum]


  export const BlockchainEventLogScalarFieldEnum: {
    id: 'id',
    eventname: 'eventname',
    contractname: 'contractname',
    entityid: 'entityid',
    entitytype: 'entitytype',
    transactionhash: 'transactionhash',
    timestamp: 'timestamp',
    processed: 'processed'
  };

  export type BlockchainEventLogScalarFieldEnum = (typeof BlockchainEventLogScalarFieldEnum)[keyof typeof BlockchainEventLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Deep Input Types
   */


  export type RoleWhereInput = {
    AND?: Enumerable<RoleWhereInput>
    OR?: Enumerable<RoleWhereInput>
    NOT?: Enumerable<RoleWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    users?: UserListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    users?: UserOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RoleScalarWhereWithAggregatesInput>
    OR?: Enumerable<RoleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RoleScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    wallet?: StringFilter | string
    email?: StringNullableFilter | string | null
    passwordhash?: StringNullableFilter | string | null
    roleid?: IntNullableFilter | number | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    activitylog?: ActivityLogListRelationFilter
    admin?: XOR<AdminRelationFilter, AdminWhereInput> | null
    alert?: AlertListRelationFilter
    distributor?: XOR<DistributorRelationFilter, DistributorWhereInput> | null
    doctor?: XOR<DoctorRelationFilter, DoctorWhereInput> | null
    manufacturer?: XOR<ManufacturerRelationFilter, ManufacturerWhereInput> | null
    otp?: OtpListRelationFilter
    patient?: XOR<PatientRelationFilter, PatientWhereInput> | null
    pharmacist?: XOR<PharmacistRelationFilter, PharmacistWhereInput> | null
    regulator?: XOR<RegulatorRelationFilter, RegulatorWhereInput> | null
    reports?: ReportListRelationFilter
    revocationrecord?: RevocationRecordListRelationFilter
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordListRelationFilter
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordListRelationFilter
    roles?: XOR<RoleRelationFilter, RoleWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    wallet?: SortOrder
    email?: SortOrderInput | SortOrder
    passwordhash?: SortOrderInput | SortOrder
    roleid?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    activitylog?: ActivityLogOrderByRelationAggregateInput
    admin?: AdminOrderByWithRelationInput
    alert?: AlertOrderByRelationAggregateInput
    distributor?: DistributorOrderByWithRelationInput
    doctor?: DoctorOrderByWithRelationInput
    manufacturer?: ManufacturerOrderByWithRelationInput
    otp?: OtpOrderByRelationAggregateInput
    patient?: PatientOrderByWithRelationInput
    pharmacist?: PharmacistOrderByWithRelationInput
    regulator?: RegulatorOrderByWithRelationInput
    reports?: ReportOrderByRelationAggregateInput
    revocationrecord?: RevocationRecordOrderByRelationAggregateInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordOrderByRelationAggregateInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordOrderByRelationAggregateInput
    roles?: RoleOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = {
    id?: number
    wallet?: string
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    wallet?: SortOrder
    email?: SortOrderInput | SortOrder
    passwordhash?: SortOrderInput | SortOrder
    roleid?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    wallet?: StringWithAggregatesFilter | string
    email?: StringNullableWithAggregatesFilter | string | null
    passwordhash?: StringNullableWithAggregatesFilter | string | null
    roleid?: IntNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type PermissionWhereInput = {
    AND?: Enumerable<PermissionWhereInput>
    OR?: Enumerable<PermissionWhereInput>
    NOT?: Enumerable<PermissionWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type PermissionWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _avg?: PermissionAvgOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
    _sum?: PermissionSumOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PermissionScalarWhereWithAggregatesInput>
    OR?: Enumerable<PermissionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PermissionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type DoctorWhereInput = {
    AND?: Enumerable<DoctorWhereInput>
    OR?: Enumerable<DoctorWhereInput>
    NOT?: Enumerable<DoctorWhereInput>
    id?: IntFilter | number
    userid?: IntNullableFilter | number | null
    licenseno?: StringFilter | string
    hospital?: StringFilter | string
    users?: XOR<UserRelationFilter, UserWhereInput> | null
    prescription?: PrescriptionListRelationFilter
  }

  export type DoctorOrderByWithRelationInput = {
    id?: SortOrder
    userid?: SortOrderInput | SortOrder
    licenseno?: SortOrder
    hospital?: SortOrder
    users?: UserOrderByWithRelationInput
    prescription?: PrescriptionOrderByRelationAggregateInput
  }

  export type DoctorWhereUniqueInput = {
    id?: number
    userid?: number
    licenseno?: string
  }

  export type DoctorOrderByWithAggregationInput = {
    id?: SortOrder
    userid?: SortOrderInput | SortOrder
    licenseno?: SortOrder
    hospital?: SortOrder
    _count?: DoctorCountOrderByAggregateInput
    _avg?: DoctorAvgOrderByAggregateInput
    _max?: DoctorMaxOrderByAggregateInput
    _min?: DoctorMinOrderByAggregateInput
    _sum?: DoctorSumOrderByAggregateInput
  }

  export type DoctorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DoctorScalarWhereWithAggregatesInput>
    OR?: Enumerable<DoctorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DoctorScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userid?: IntNullableWithAggregatesFilter | number | null
    licenseno?: StringWithAggregatesFilter | string
    hospital?: StringWithAggregatesFilter | string
  }

  export type PatientWhereInput = {
    AND?: Enumerable<PatientWhereInput>
    OR?: Enumerable<PatientWhereInput>
    NOT?: Enumerable<PatientWhereInput>
    id?: IntFilter | number
    userid?: IntNullableFilter | number | null
    dateofbirth?: DateTimeFilter | Date | string
    users?: XOR<UserRelationFilter, UserWhereInput> | null
    prescription?: PrescriptionListRelationFilter
  }

  export type PatientOrderByWithRelationInput = {
    id?: SortOrder
    userid?: SortOrderInput | SortOrder
    dateofbirth?: SortOrder
    users?: UserOrderByWithRelationInput
    prescription?: PrescriptionOrderByRelationAggregateInput
  }

  export type PatientWhereUniqueInput = {
    id?: number
    userid?: number
  }

  export type PatientOrderByWithAggregationInput = {
    id?: SortOrder
    userid?: SortOrderInput | SortOrder
    dateofbirth?: SortOrder
    _count?: PatientCountOrderByAggregateInput
    _avg?: PatientAvgOrderByAggregateInput
    _max?: PatientMaxOrderByAggregateInput
    _min?: PatientMinOrderByAggregateInput
    _sum?: PatientSumOrderByAggregateInput
  }

  export type PatientScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PatientScalarWhereWithAggregatesInput>
    OR?: Enumerable<PatientScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PatientScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userid?: IntNullableWithAggregatesFilter | number | null
    dateofbirth?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PharmacistWhereInput = {
    AND?: Enumerable<PharmacistWhereInput>
    OR?: Enumerable<PharmacistWhereInput>
    NOT?: Enumerable<PharmacistWhereInput>
    id?: IntFilter | number
    userid?: IntNullableFilter | number | null
    licenseno?: StringFilter | string
    pharmacy?: StringFilter | string
    dispenserecord?: DispenseRecordListRelationFilter
    users?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type PharmacistOrderByWithRelationInput = {
    id?: SortOrder
    userid?: SortOrderInput | SortOrder
    licenseno?: SortOrder
    pharmacy?: SortOrder
    dispenserecord?: DispenseRecordOrderByRelationAggregateInput
    users?: UserOrderByWithRelationInput
  }

  export type PharmacistWhereUniqueInput = {
    id?: number
    userid?: number
    licenseno?: string
  }

  export type PharmacistOrderByWithAggregationInput = {
    id?: SortOrder
    userid?: SortOrderInput | SortOrder
    licenseno?: SortOrder
    pharmacy?: SortOrder
    _count?: PharmacistCountOrderByAggregateInput
    _avg?: PharmacistAvgOrderByAggregateInput
    _max?: PharmacistMaxOrderByAggregateInput
    _min?: PharmacistMinOrderByAggregateInput
    _sum?: PharmacistSumOrderByAggregateInput
  }

  export type PharmacistScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PharmacistScalarWhereWithAggregatesInput>
    OR?: Enumerable<PharmacistScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PharmacistScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userid?: IntNullableWithAggregatesFilter | number | null
    licenseno?: StringWithAggregatesFilter | string
    pharmacy?: StringWithAggregatesFilter | string
  }

  export type ManufacturerWhereInput = {
    AND?: Enumerable<ManufacturerWhereInput>
    OR?: Enumerable<ManufacturerWhereInput>
    NOT?: Enumerable<ManufacturerWhereInput>
    id?: IntFilter | number
    userid?: IntNullableFilter | number | null
    companyname?: StringFilter | string
    drugbatch?: DrugBatchListRelationFilter
    users?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type ManufacturerOrderByWithRelationInput = {
    id?: SortOrder
    userid?: SortOrderInput | SortOrder
    companyname?: SortOrder
    drugbatch?: DrugBatchOrderByRelationAggregateInput
    users?: UserOrderByWithRelationInput
  }

  export type ManufacturerWhereUniqueInput = {
    id?: number
    userid?: number
  }

  export type ManufacturerOrderByWithAggregationInput = {
    id?: SortOrder
    userid?: SortOrderInput | SortOrder
    companyname?: SortOrder
    _count?: ManufacturerCountOrderByAggregateInput
    _avg?: ManufacturerAvgOrderByAggregateInput
    _max?: ManufacturerMaxOrderByAggregateInput
    _min?: ManufacturerMinOrderByAggregateInput
    _sum?: ManufacturerSumOrderByAggregateInput
  }

  export type ManufacturerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ManufacturerScalarWhereWithAggregatesInput>
    OR?: Enumerable<ManufacturerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ManufacturerScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userid?: IntNullableWithAggregatesFilter | number | null
    companyname?: StringWithAggregatesFilter | string
  }

  export type DistributorWhereInput = {
    AND?: Enumerable<DistributorWhereInput>
    OR?: Enumerable<DistributorWhereInput>
    NOT?: Enumerable<DistributorWhereInput>
    id?: IntFilter | number
    userid?: IntNullableFilter | number | null
    companyname?: StringFilter | string
    users?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type DistributorOrderByWithRelationInput = {
    id?: SortOrder
    userid?: SortOrderInput | SortOrder
    companyname?: SortOrder
    users?: UserOrderByWithRelationInput
  }

  export type DistributorWhereUniqueInput = {
    id?: number
    userid?: number
  }

  export type DistributorOrderByWithAggregationInput = {
    id?: SortOrder
    userid?: SortOrderInput | SortOrder
    companyname?: SortOrder
    _count?: DistributorCountOrderByAggregateInput
    _avg?: DistributorAvgOrderByAggregateInput
    _max?: DistributorMaxOrderByAggregateInput
    _min?: DistributorMinOrderByAggregateInput
    _sum?: DistributorSumOrderByAggregateInput
  }

  export type DistributorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DistributorScalarWhereWithAggregatesInput>
    OR?: Enumerable<DistributorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DistributorScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userid?: IntNullableWithAggregatesFilter | number | null
    companyname?: StringWithAggregatesFilter | string
  }

  export type RegulatorWhereInput = {
    AND?: Enumerable<RegulatorWhereInput>
    OR?: Enumerable<RegulatorWhereInput>
    NOT?: Enumerable<RegulatorWhereInput>
    id?: IntFilter | number
    userid?: IntNullableFilter | number | null
    agencyname?: StringFilter | string
    users?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type RegulatorOrderByWithRelationInput = {
    id?: SortOrder
    userid?: SortOrderInput | SortOrder
    agencyname?: SortOrder
    users?: UserOrderByWithRelationInput
  }

  export type RegulatorWhereUniqueInput = {
    id?: number
    userid?: number
  }

  export type RegulatorOrderByWithAggregationInput = {
    id?: SortOrder
    userid?: SortOrderInput | SortOrder
    agencyname?: SortOrder
    _count?: RegulatorCountOrderByAggregateInput
    _avg?: RegulatorAvgOrderByAggregateInput
    _max?: RegulatorMaxOrderByAggregateInput
    _min?: RegulatorMinOrderByAggregateInput
    _sum?: RegulatorSumOrderByAggregateInput
  }

  export type RegulatorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RegulatorScalarWhereWithAggregatesInput>
    OR?: Enumerable<RegulatorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RegulatorScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userid?: IntNullableWithAggregatesFilter | number | null
    agencyname?: StringWithAggregatesFilter | string
  }

  export type AdminWhereInput = {
    AND?: Enumerable<AdminWhereInput>
    OR?: Enumerable<AdminWhereInput>
    NOT?: Enumerable<AdminWhereInput>
    id?: IntFilter | number
    userid?: IntNullableFilter | number | null
    users?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    userid?: SortOrderInput | SortOrder
    users?: UserOrderByWithRelationInput
  }

  export type AdminWhereUniqueInput = {
    id?: number
    userid?: number
  }

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    userid?: SortOrderInput | SortOrder
    _count?: AdminCountOrderByAggregateInput
    _avg?: AdminAvgOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
    _sum?: AdminSumOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AdminScalarWhereWithAggregatesInput>
    OR?: Enumerable<AdminScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AdminScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userid?: IntNullableWithAggregatesFilter | number | null
  }

  export type DrugWhereInput = {
    AND?: Enumerable<DrugWhereInput>
    OR?: Enumerable<DrugWhereInput>
    NOT?: Enumerable<DrugWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    code?: StringFilter | string
    formulation?: StringFilter | string
    dosageunit?: StringFilter | string
    drugbatch?: DrugBatchListRelationFilter
    prescription?: PrescriptionListRelationFilter
  }

  export type DrugOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    formulation?: SortOrder
    dosageunit?: SortOrder
    drugbatch?: DrugBatchOrderByRelationAggregateInput
    prescription?: PrescriptionOrderByRelationAggregateInput
  }

  export type DrugWhereUniqueInput = {
    id?: number
    code?: string
  }

  export type DrugOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    formulation?: SortOrder
    dosageunit?: SortOrder
    _count?: DrugCountOrderByAggregateInput
    _avg?: DrugAvgOrderByAggregateInput
    _max?: DrugMaxOrderByAggregateInput
    _min?: DrugMinOrderByAggregateInput
    _sum?: DrugSumOrderByAggregateInput
  }

  export type DrugScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DrugScalarWhereWithAggregatesInput>
    OR?: Enumerable<DrugScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DrugScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    formulation?: StringWithAggregatesFilter | string
    dosageunit?: StringWithAggregatesFilter | string
  }

  export type PrescriptionWhereInput = {
    AND?: Enumerable<PrescriptionWhereInput>
    OR?: Enumerable<PrescriptionWhereInput>
    NOT?: Enumerable<PrescriptionWhereInput>
    id?: IntFilter | number
    patientid?: IntNullableFilter | number | null
    doctorid?: IntNullableFilter | number | null
    drugid?: IntNullableFilter | number | null
    dosage?: StringFilter | string
    issuedat?: DateTimeNullableFilter | Date | string | null
    expiresat?: DateTimeFilter | Date | string
    blockchaintx?: StringNullableFilter | string | null
    qrcode?: StringFilter | string
    ipfshash?: StringNullableFilter | string | null
    status?: StringFilter | string
    blockchaineventlog?: BlockchainEventLogListRelationFilter
    dispenserecord?: DispenseRecordListRelationFilter
    doctor?: XOR<DoctorRelationFilter, DoctorWhereInput> | null
    drug?: XOR<DrugRelationFilter, DrugWhereInput> | null
    patient?: XOR<PatientRelationFilter, PatientWhereInput> | null
  }

  export type PrescriptionOrderByWithRelationInput = {
    id?: SortOrder
    patientid?: SortOrderInput | SortOrder
    doctorid?: SortOrderInput | SortOrder
    drugid?: SortOrderInput | SortOrder
    dosage?: SortOrder
    issuedat?: SortOrderInput | SortOrder
    expiresat?: SortOrder
    blockchaintx?: SortOrderInput | SortOrder
    qrcode?: SortOrder
    ipfshash?: SortOrderInput | SortOrder
    status?: SortOrder
    blockchaineventlog?: BlockchainEventLogOrderByRelationAggregateInput
    dispenserecord?: DispenseRecordOrderByRelationAggregateInput
    doctor?: DoctorOrderByWithRelationInput
    drug?: DrugOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
  }

  export type PrescriptionWhereUniqueInput = {
    id?: number
  }

  export type PrescriptionOrderByWithAggregationInput = {
    id?: SortOrder
    patientid?: SortOrderInput | SortOrder
    doctorid?: SortOrderInput | SortOrder
    drugid?: SortOrderInput | SortOrder
    dosage?: SortOrder
    issuedat?: SortOrderInput | SortOrder
    expiresat?: SortOrder
    blockchaintx?: SortOrderInput | SortOrder
    qrcode?: SortOrder
    ipfshash?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: PrescriptionCountOrderByAggregateInput
    _avg?: PrescriptionAvgOrderByAggregateInput
    _max?: PrescriptionMaxOrderByAggregateInput
    _min?: PrescriptionMinOrderByAggregateInput
    _sum?: PrescriptionSumOrderByAggregateInput
  }

  export type PrescriptionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PrescriptionScalarWhereWithAggregatesInput>
    OR?: Enumerable<PrescriptionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PrescriptionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    patientid?: IntNullableWithAggregatesFilter | number | null
    doctorid?: IntNullableWithAggregatesFilter | number | null
    drugid?: IntNullableWithAggregatesFilter | number | null
    dosage?: StringWithAggregatesFilter | string
    issuedat?: DateTimeNullableWithAggregatesFilter | Date | string | null
    expiresat?: DateTimeWithAggregatesFilter | Date | string
    blockchaintx?: StringNullableWithAggregatesFilter | string | null
    qrcode?: StringWithAggregatesFilter | string
    ipfshash?: StringNullableWithAggregatesFilter | string | null
    status?: StringWithAggregatesFilter | string
  }

  export type DrugBatchWhereInput = {
    AND?: Enumerable<DrugBatchWhereInput>
    OR?: Enumerable<DrugBatchWhereInput>
    NOT?: Enumerable<DrugBatchWhereInput>
    id?: IntFilter | number
    manufacturerid?: IntNullableFilter | number | null
    drugid?: IntNullableFilter | number | null
    batchnumber?: StringFilter | string
    manufacturedate?: DateTimeFilter | Date | string
    expirydate?: DateTimeFilter | Date | string
    blockchaintx?: StringNullableFilter | string | null
    qrcode?: StringFilter | string
    ipfshash?: StringNullableFilter | string | null
    blockchaineventlog?: BlockchainEventLogListRelationFilter
    dispenserecord?: DispenseRecordListRelationFilter
    drug?: XOR<DrugRelationFilter, DrugWhereInput> | null
    manufacturer?: XOR<ManufacturerRelationFilter, ManufacturerWhereInput> | null
    supplychainrecord?: SupplyChainRecordListRelationFilter
  }

  export type DrugBatchOrderByWithRelationInput = {
    id?: SortOrder
    manufacturerid?: SortOrderInput | SortOrder
    drugid?: SortOrderInput | SortOrder
    batchnumber?: SortOrder
    manufacturedate?: SortOrder
    expirydate?: SortOrder
    blockchaintx?: SortOrderInput | SortOrder
    qrcode?: SortOrder
    ipfshash?: SortOrderInput | SortOrder
    blockchaineventlog?: BlockchainEventLogOrderByRelationAggregateInput
    dispenserecord?: DispenseRecordOrderByRelationAggregateInput
    drug?: DrugOrderByWithRelationInput
    manufacturer?: ManufacturerOrderByWithRelationInput
    supplychainrecord?: SupplyChainRecordOrderByRelationAggregateInput
  }

  export type DrugBatchWhereUniqueInput = {
    id?: number
    batchnumber?: string
  }

  export type DrugBatchOrderByWithAggregationInput = {
    id?: SortOrder
    manufacturerid?: SortOrderInput | SortOrder
    drugid?: SortOrderInput | SortOrder
    batchnumber?: SortOrder
    manufacturedate?: SortOrder
    expirydate?: SortOrder
    blockchaintx?: SortOrderInput | SortOrder
    qrcode?: SortOrder
    ipfshash?: SortOrderInput | SortOrder
    _count?: DrugBatchCountOrderByAggregateInput
    _avg?: DrugBatchAvgOrderByAggregateInput
    _max?: DrugBatchMaxOrderByAggregateInput
    _min?: DrugBatchMinOrderByAggregateInput
    _sum?: DrugBatchSumOrderByAggregateInput
  }

  export type DrugBatchScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DrugBatchScalarWhereWithAggregatesInput>
    OR?: Enumerable<DrugBatchScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DrugBatchScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    manufacturerid?: IntNullableWithAggregatesFilter | number | null
    drugid?: IntNullableWithAggregatesFilter | number | null
    batchnumber?: StringWithAggregatesFilter | string
    manufacturedate?: DateTimeWithAggregatesFilter | Date | string
    expirydate?: DateTimeWithAggregatesFilter | Date | string
    blockchaintx?: StringNullableWithAggregatesFilter | string | null
    qrcode?: StringWithAggregatesFilter | string
    ipfshash?: StringNullableWithAggregatesFilter | string | null
  }

  export type SupplyChainRecordWhereInput = {
    AND?: Enumerable<SupplyChainRecordWhereInput>
    OR?: Enumerable<SupplyChainRecordWhereInput>
    NOT?: Enumerable<SupplyChainRecordWhereInput>
    id?: IntFilter | number
    drugbatchid?: IntNullableFilter | number | null
    fromentityid?: IntNullableFilter | number | null
    toentityid?: IntNullableFilter | number | null
    action?: StringFilter | string
    timestamp?: DateTimeNullableFilter | Date | string | null
    blockchaintx?: StringNullableFilter | string | null
    blockchaineventlog?: BlockchainEventLogListRelationFilter
    drugbatch?: XOR<DrugBatchRelationFilter, DrugBatchWhereInput> | null
    users_supplychainrecord_fromentityidTousers?: XOR<UserRelationFilter, UserWhereInput> | null
    users_supplychainrecord_toentityidTousers?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type SupplyChainRecordOrderByWithRelationInput = {
    id?: SortOrder
    drugbatchid?: SortOrderInput | SortOrder
    fromentityid?: SortOrderInput | SortOrder
    toentityid?: SortOrderInput | SortOrder
    action?: SortOrder
    timestamp?: SortOrderInput | SortOrder
    blockchaintx?: SortOrderInput | SortOrder
    blockchaineventlog?: BlockchainEventLogOrderByRelationAggregateInput
    drugbatch?: DrugBatchOrderByWithRelationInput
    users_supplychainrecord_fromentityidTousers?: UserOrderByWithRelationInput
    users_supplychainrecord_toentityidTousers?: UserOrderByWithRelationInput
  }

  export type SupplyChainRecordWhereUniqueInput = {
    id?: number
  }

  export type SupplyChainRecordOrderByWithAggregationInput = {
    id?: SortOrder
    drugbatchid?: SortOrderInput | SortOrder
    fromentityid?: SortOrderInput | SortOrder
    toentityid?: SortOrderInput | SortOrder
    action?: SortOrder
    timestamp?: SortOrderInput | SortOrder
    blockchaintx?: SortOrderInput | SortOrder
    _count?: SupplyChainRecordCountOrderByAggregateInput
    _avg?: SupplyChainRecordAvgOrderByAggregateInput
    _max?: SupplyChainRecordMaxOrderByAggregateInput
    _min?: SupplyChainRecordMinOrderByAggregateInput
    _sum?: SupplyChainRecordSumOrderByAggregateInput
  }

  export type SupplyChainRecordScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SupplyChainRecordScalarWhereWithAggregatesInput>
    OR?: Enumerable<SupplyChainRecordScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SupplyChainRecordScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    drugbatchid?: IntNullableWithAggregatesFilter | number | null
    fromentityid?: IntNullableWithAggregatesFilter | number | null
    toentityid?: IntNullableWithAggregatesFilter | number | null
    action?: StringWithAggregatesFilter | string
    timestamp?: DateTimeNullableWithAggregatesFilter | Date | string | null
    blockchaintx?: StringNullableWithAggregatesFilter | string | null
  }

  export type RevocationRecordWhereInput = {
    AND?: Enumerable<RevocationRecordWhereInput>
    OR?: Enumerable<RevocationRecordWhereInput>
    NOT?: Enumerable<RevocationRecordWhereInput>
    id?: IntFilter | number
    type?: StringFilter | string
    refid?: IntFilter | number
    reason?: StringFilter | string
    revokedbyid?: IntNullableFilter | number | null
    timestamp?: DateTimeNullableFilter | Date | string | null
    blockchaintx?: StringNullableFilter | string | null
    users?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type RevocationRecordOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    refid?: SortOrder
    reason?: SortOrder
    revokedbyid?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    blockchaintx?: SortOrderInput | SortOrder
    users?: UserOrderByWithRelationInput
  }

  export type RevocationRecordWhereUniqueInput = {
    id?: number
  }

  export type RevocationRecordOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    refid?: SortOrder
    reason?: SortOrder
    revokedbyid?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    blockchaintx?: SortOrderInput | SortOrder
    _count?: RevocationRecordCountOrderByAggregateInput
    _avg?: RevocationRecordAvgOrderByAggregateInput
    _max?: RevocationRecordMaxOrderByAggregateInput
    _min?: RevocationRecordMinOrderByAggregateInput
    _sum?: RevocationRecordSumOrderByAggregateInput
  }

  export type RevocationRecordScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RevocationRecordScalarWhereWithAggregatesInput>
    OR?: Enumerable<RevocationRecordScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RevocationRecordScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    type?: StringWithAggregatesFilter | string
    refid?: IntWithAggregatesFilter | number
    reason?: StringWithAggregatesFilter | string
    revokedbyid?: IntNullableWithAggregatesFilter | number | null
    timestamp?: DateTimeNullableWithAggregatesFilter | Date | string | null
    blockchaintx?: StringNullableWithAggregatesFilter | string | null
  }

  export type OtpWhereInput = {
    AND?: Enumerable<OtpWhereInput>
    OR?: Enumerable<OtpWhereInput>
    NOT?: Enumerable<OtpWhereInput>
    id?: IntFilter | number
    userid?: IntNullableFilter | number | null
    code?: StringFilter | string
    expiresat?: DateTimeFilter | Date | string
    createdat?: DateTimeNullableFilter | Date | string | null
    users?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type OtpOrderByWithRelationInput = {
    id?: SortOrder
    userid?: SortOrderInput | SortOrder
    code?: SortOrder
    expiresat?: SortOrder
    createdat?: SortOrderInput | SortOrder
    users?: UserOrderByWithRelationInput
  }

  export type OtpWhereUniqueInput = {
    id?: number
  }

  export type OtpOrderByWithAggregationInput = {
    id?: SortOrder
    userid?: SortOrderInput | SortOrder
    code?: SortOrder
    expiresat?: SortOrder
    createdat?: SortOrderInput | SortOrder
    _count?: OtpCountOrderByAggregateInput
    _avg?: OtpAvgOrderByAggregateInput
    _max?: OtpMaxOrderByAggregateInput
    _min?: OtpMinOrderByAggregateInput
    _sum?: OtpSumOrderByAggregateInput
  }

  export type OtpScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OtpScalarWhereWithAggregatesInput>
    OR?: Enumerable<OtpScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OtpScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userid?: IntNullableWithAggregatesFilter | number | null
    code?: StringWithAggregatesFilter | string
    expiresat?: DateTimeWithAggregatesFilter | Date | string
    createdat?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type AlertWhereInput = {
    AND?: Enumerable<AlertWhereInput>
    OR?: Enumerable<AlertWhereInput>
    NOT?: Enumerable<AlertWhereInput>
    id?: IntFilter | number
    userid?: IntNullableFilter | number | null
    title?: StringFilter | string
    message?: StringFilter | string
    isread?: BoolNullableFilter | boolean | null
    priority?: StringFilter | string
    createdat?: DateTimeNullableFilter | Date | string | null
    users?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type AlertOrderByWithRelationInput = {
    id?: SortOrder
    userid?: SortOrderInput | SortOrder
    title?: SortOrder
    message?: SortOrder
    isread?: SortOrderInput | SortOrder
    priority?: SortOrder
    createdat?: SortOrderInput | SortOrder
    users?: UserOrderByWithRelationInput
  }

  export type AlertWhereUniqueInput = {
    id?: number
  }

  export type AlertOrderByWithAggregationInput = {
    id?: SortOrder
    userid?: SortOrderInput | SortOrder
    title?: SortOrder
    message?: SortOrder
    isread?: SortOrderInput | SortOrder
    priority?: SortOrder
    createdat?: SortOrderInput | SortOrder
    _count?: AlertCountOrderByAggregateInput
    _avg?: AlertAvgOrderByAggregateInput
    _max?: AlertMaxOrderByAggregateInput
    _min?: AlertMinOrderByAggregateInput
    _sum?: AlertSumOrderByAggregateInput
  }

  export type AlertScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AlertScalarWhereWithAggregatesInput>
    OR?: Enumerable<AlertScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AlertScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userid?: IntNullableWithAggregatesFilter | number | null
    title?: StringWithAggregatesFilter | string
    message?: StringWithAggregatesFilter | string
    isread?: BoolNullableWithAggregatesFilter | boolean | null
    priority?: StringWithAggregatesFilter | string
    createdat?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type ActivityLogWhereInput = {
    AND?: Enumerable<ActivityLogWhereInput>
    OR?: Enumerable<ActivityLogWhereInput>
    NOT?: Enumerable<ActivityLogWhereInput>
    id?: IntFilter | number
    userid?: IntNullableFilter | number | null
    action?: StringFilter | string
    details?: StringNullableFilter | string | null
    timestamp?: DateTimeNullableFilter | Date | string | null
    users?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type ActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    userid?: SortOrderInput | SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    users?: UserOrderByWithRelationInput
  }

  export type ActivityLogWhereUniqueInput = {
    id?: number
  }

  export type ActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    userid?: SortOrderInput | SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    _count?: ActivityLogCountOrderByAggregateInput
    _avg?: ActivityLogAvgOrderByAggregateInput
    _max?: ActivityLogMaxOrderByAggregateInput
    _min?: ActivityLogMinOrderByAggregateInput
    _sum?: ActivityLogSumOrderByAggregateInput
  }

  export type ActivityLogScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ActivityLogScalarWhereWithAggregatesInput>
    OR?: Enumerable<ActivityLogScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ActivityLogScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userid?: IntNullableWithAggregatesFilter | number | null
    action?: StringWithAggregatesFilter | string
    details?: StringNullableWithAggregatesFilter | string | null
    timestamp?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type ReportWhereInput = {
    AND?: Enumerable<ReportWhereInput>
    OR?: Enumerable<ReportWhereInput>
    NOT?: Enumerable<ReportWhereInput>
    id?: IntFilter | number
    userid?: IntNullableFilter | number | null
    reporttype?: StringFilter | string
    filters?: JsonNullableFilter
    generatedat?: DateTimeNullableFilter | Date | string | null
    ipfshash?: StringNullableFilter | string | null
    users?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    userid?: SortOrderInput | SortOrder
    reporttype?: SortOrder
    filters?: SortOrderInput | SortOrder
    generatedat?: SortOrderInput | SortOrder
    ipfshash?: SortOrderInput | SortOrder
    users?: UserOrderByWithRelationInput
  }

  export type ReportWhereUniqueInput = {
    id?: number
  }

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    userid?: SortOrderInput | SortOrder
    reporttype?: SortOrder
    filters?: SortOrderInput | SortOrder
    generatedat?: SortOrderInput | SortOrder
    ipfshash?: SortOrderInput | SortOrder
    _count?: ReportCountOrderByAggregateInput
    _avg?: ReportAvgOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
    _sum?: ReportSumOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReportScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReportScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReportScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userid?: IntNullableWithAggregatesFilter | number | null
    reporttype?: StringWithAggregatesFilter | string
    filters?: JsonNullableWithAggregatesFilter
    generatedat?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ipfshash?: StringNullableWithAggregatesFilter | string | null
  }

  export type DispenseRecordWhereInput = {
    AND?: Enumerable<DispenseRecordWhereInput>
    OR?: Enumerable<DispenseRecordWhereInput>
    NOT?: Enumerable<DispenseRecordWhereInput>
    id?: IntFilter | number
    prescriptionid?: IntNullableFilter | number | null
    pharmacistid?: IntNullableFilter | number | null
    drugbatchid?: IntNullableFilter | number | null
    quantity?: IntFilter | number
    dispensedat?: DateTimeNullableFilter | Date | string | null
    blockchaintx?: StringNullableFilter | string | null
    drugbatch?: XOR<DrugBatchRelationFilter, DrugBatchWhereInput> | null
    pharmacist?: XOR<PharmacistRelationFilter, PharmacistWhereInput> | null
    prescription?: XOR<PrescriptionRelationFilter, PrescriptionWhereInput> | null
  }

  export type DispenseRecordOrderByWithRelationInput = {
    id?: SortOrder
    prescriptionid?: SortOrderInput | SortOrder
    pharmacistid?: SortOrderInput | SortOrder
    drugbatchid?: SortOrderInput | SortOrder
    quantity?: SortOrder
    dispensedat?: SortOrderInput | SortOrder
    blockchaintx?: SortOrderInput | SortOrder
    drugbatch?: DrugBatchOrderByWithRelationInput
    pharmacist?: PharmacistOrderByWithRelationInput
    prescription?: PrescriptionOrderByWithRelationInput
  }

  export type DispenseRecordWhereUniqueInput = {
    id?: number
  }

  export type DispenseRecordOrderByWithAggregationInput = {
    id?: SortOrder
    prescriptionid?: SortOrderInput | SortOrder
    pharmacistid?: SortOrderInput | SortOrder
    drugbatchid?: SortOrderInput | SortOrder
    quantity?: SortOrder
    dispensedat?: SortOrderInput | SortOrder
    blockchaintx?: SortOrderInput | SortOrder
    _count?: DispenseRecordCountOrderByAggregateInput
    _avg?: DispenseRecordAvgOrderByAggregateInput
    _max?: DispenseRecordMaxOrderByAggregateInput
    _min?: DispenseRecordMinOrderByAggregateInput
    _sum?: DispenseRecordSumOrderByAggregateInput
  }

  export type DispenseRecordScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DispenseRecordScalarWhereWithAggregatesInput>
    OR?: Enumerable<DispenseRecordScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DispenseRecordScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    prescriptionid?: IntNullableWithAggregatesFilter | number | null
    pharmacistid?: IntNullableWithAggregatesFilter | number | null
    drugbatchid?: IntNullableWithAggregatesFilter | number | null
    quantity?: IntWithAggregatesFilter | number
    dispensedat?: DateTimeNullableWithAggregatesFilter | Date | string | null
    blockchaintx?: StringNullableWithAggregatesFilter | string | null
  }

  export type BlockchainEventLogWhereInput = {
    AND?: Enumerable<BlockchainEventLogWhereInput>
    OR?: Enumerable<BlockchainEventLogWhereInput>
    NOT?: Enumerable<BlockchainEventLogWhereInput>
    id?: IntFilter | number
    eventname?: StringFilter | string
    contractname?: StringFilter | string
    entityid?: IntNullableFilter | number | null
    entitytype?: StringNullableFilter | string | null
    transactionhash?: StringFilter | string
    timestamp?: DateTimeNullableFilter | Date | string | null
    processed?: BoolNullableFilter | boolean | null
    drugbatch?: XOR<DrugBatchRelationFilter, DrugBatchWhereInput> | null
    prescription?: XOR<PrescriptionRelationFilter, PrescriptionWhereInput> | null
    supplychainrecord?: XOR<SupplyChainRecordRelationFilter, SupplyChainRecordWhereInput> | null
  }

  export type BlockchainEventLogOrderByWithRelationInput = {
    id?: SortOrder
    eventname?: SortOrder
    contractname?: SortOrder
    entityid?: SortOrderInput | SortOrder
    entitytype?: SortOrderInput | SortOrder
    transactionhash?: SortOrder
    timestamp?: SortOrderInput | SortOrder
    processed?: SortOrderInput | SortOrder
    drugbatch?: DrugBatchOrderByWithRelationInput
    prescription?: PrescriptionOrderByWithRelationInput
    supplychainrecord?: SupplyChainRecordOrderByWithRelationInput
  }

  export type BlockchainEventLogWhereUniqueInput = {
    id?: number
    transactionhash?: string
  }

  export type BlockchainEventLogOrderByWithAggregationInput = {
    id?: SortOrder
    eventname?: SortOrder
    contractname?: SortOrder
    entityid?: SortOrderInput | SortOrder
    entitytype?: SortOrderInput | SortOrder
    transactionhash?: SortOrder
    timestamp?: SortOrderInput | SortOrder
    processed?: SortOrderInput | SortOrder
    _count?: BlockchainEventLogCountOrderByAggregateInput
    _avg?: BlockchainEventLogAvgOrderByAggregateInput
    _max?: BlockchainEventLogMaxOrderByAggregateInput
    _min?: BlockchainEventLogMinOrderByAggregateInput
    _sum?: BlockchainEventLogSumOrderByAggregateInput
  }

  export type BlockchainEventLogScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BlockchainEventLogScalarWhereWithAggregatesInput>
    OR?: Enumerable<BlockchainEventLogScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BlockchainEventLogScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    eventname?: StringWithAggregatesFilter | string
    contractname?: StringWithAggregatesFilter | string
    entityid?: IntNullableWithAggregatesFilter | number | null
    entitytype?: StringNullableWithAggregatesFilter | string | null
    transactionhash?: StringWithAggregatesFilter | string
    timestamp?: DateTimeNullableWithAggregatesFilter | Date | string | null
    processed?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type RoleCreateInput = {
    name: string
    users?: UserCreateNestedManyWithoutRolesInput
  }

  export type RoleUncheckedCreateInput = {
    id?: number
    name: string
    users?: UserUncheckedCreateNestedManyWithoutRolesInput
  }

  export type RoleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutRolesNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type RoleCreateManyInput = {
    id?: number
    name: string
  }

  export type RoleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    wallet: string
    email?: string | null
    passwordhash?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    activitylog?: ActivityLogCreateNestedManyWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUsersInput
    alert?: AlertCreateNestedManyWithoutUsersInput
    distributor?: DistributorCreateNestedOneWithoutUsersInput
    doctor?: DoctorCreateNestedOneWithoutUsersInput
    manufacturer?: ManufacturerCreateNestedOneWithoutUsersInput
    otp?: OtpCreateNestedManyWithoutUsersInput
    patient?: PatientCreateNestedOneWithoutUsersInput
    pharmacist?: PharmacistCreateNestedOneWithoutUsersInput
    regulator?: RegulatorCreateNestedOneWithoutUsersInput
    reports?: ReportCreateNestedManyWithoutUsersInput
    revocationrecord?: RevocationRecordCreateNestedManyWithoutUsersInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordCreateNestedManyWithoutUsers_supplychainrecord_fromentityidTousersInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordCreateNestedManyWithoutUsers_supplychainrecord_toentityidTousersInput
    roles?: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    wallet: string
    email?: string | null
    passwordhash?: string | null
    roleid?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    activitylog?: ActivityLogUncheckedCreateNestedManyWithoutUsersInput
    admin?: AdminUncheckedCreateNestedOneWithoutUsersInput
    alert?: AlertUncheckedCreateNestedManyWithoutUsersInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUsersInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUsersInput
    manufacturer?: ManufacturerUncheckedCreateNestedOneWithoutUsersInput
    otp?: OtpUncheckedCreateNestedManyWithoutUsersInput
    patient?: PatientUncheckedCreateNestedOneWithoutUsersInput
    pharmacist?: PharmacistUncheckedCreateNestedOneWithoutUsersInput
    regulator?: RegulatorUncheckedCreateNestedOneWithoutUsersInput
    reports?: ReportUncheckedCreateNestedManyWithoutUsersInput
    revocationrecord?: RevocationRecordUncheckedCreateNestedManyWithoutUsersInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUncheckedCreateNestedManyWithoutUsers_supplychainrecord_fromentityidTousersInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUncheckedCreateNestedManyWithoutUsers_supplychainrecord_toentityidTousersInput
  }

  export type UserUpdateInput = {
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: ActivityLogUpdateManyWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUsersNestedInput
    alert?: AlertUpdateManyWithoutUsersNestedInput
    distributor?: DistributorUpdateOneWithoutUsersNestedInput
    doctor?: DoctorUpdateOneWithoutUsersNestedInput
    manufacturer?: ManufacturerUpdateOneWithoutUsersNestedInput
    otp?: OtpUpdateManyWithoutUsersNestedInput
    patient?: PatientUpdateOneWithoutUsersNestedInput
    pharmacist?: PharmacistUpdateOneWithoutUsersNestedInput
    regulator?: RegulatorUpdateOneWithoutUsersNestedInput
    reports?: ReportUpdateManyWithoutUsersNestedInput
    revocationrecord?: RevocationRecordUpdateManyWithoutUsersNestedInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUpdateManyWithoutUsers_supplychainrecord_fromentityidTousersNestedInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUpdateManyWithoutUsers_supplychainrecord_toentityidTousersNestedInput
    roles?: RoleUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    roleid?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: ActivityLogUncheckedUpdateManyWithoutUsersNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUsersNestedInput
    alert?: AlertUncheckedUpdateManyWithoutUsersNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUsersNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUsersNestedInput
    manufacturer?: ManufacturerUncheckedUpdateOneWithoutUsersNestedInput
    otp?: OtpUncheckedUpdateManyWithoutUsersNestedInput
    patient?: PatientUncheckedUpdateOneWithoutUsersNestedInput
    pharmacist?: PharmacistUncheckedUpdateOneWithoutUsersNestedInput
    regulator?: RegulatorUncheckedUpdateOneWithoutUsersNestedInput
    reports?: ReportUncheckedUpdateManyWithoutUsersNestedInput
    revocationrecord?: RevocationRecordUncheckedUpdateManyWithoutUsersNestedInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUncheckedUpdateManyWithoutUsers_supplychainrecord_fromentityidTousersNestedInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUncheckedUpdateManyWithoutUsers_supplychainrecord_toentityidTousersNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    wallet: string
    email?: string | null
    passwordhash?: string | null
    roleid?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    roleid?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PermissionCreateInput = {
    name: string
  }

  export type PermissionUncheckedCreateInput = {
    id?: number
    name: string
  }

  export type PermissionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PermissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PermissionCreateManyInput = {
    id?: number
    name: string
  }

  export type PermissionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DoctorCreateInput = {
    licenseno: string
    hospital: string
    users?: UserCreateNestedOneWithoutDoctorInput
    prescription?: PrescriptionCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUncheckedCreateInput = {
    id?: number
    userid?: number | null
    licenseno: string
    hospital: string
    prescription?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUpdateInput = {
    licenseno?: StringFieldUpdateOperationsInput | string
    hospital?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateOneWithoutDoctorNestedInput
    prescription?: PrescriptionUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    licenseno?: StringFieldUpdateOperationsInput | string
    hospital?: StringFieldUpdateOperationsInput | string
    prescription?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorCreateManyInput = {
    id?: number
    userid?: number | null
    licenseno: string
    hospital: string
  }

  export type DoctorUpdateManyMutationInput = {
    licenseno?: StringFieldUpdateOperationsInput | string
    hospital?: StringFieldUpdateOperationsInput | string
  }

  export type DoctorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    licenseno?: StringFieldUpdateOperationsInput | string
    hospital?: StringFieldUpdateOperationsInput | string
  }

  export type PatientCreateInput = {
    dateofbirth: Date | string
    users?: UserCreateNestedOneWithoutPatientInput
    prescription?: PrescriptionCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateInput = {
    id?: number
    userid?: number | null
    dateofbirth: Date | string
    prescription?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientUpdateInput = {
    dateofbirth?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateOneWithoutPatientNestedInput
    prescription?: PrescriptionUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    dateofbirth?: DateTimeFieldUpdateOperationsInput | Date | string
    prescription?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateManyInput = {
    id?: number
    userid?: number | null
    dateofbirth: Date | string
  }

  export type PatientUpdateManyMutationInput = {
    dateofbirth?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    dateofbirth?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PharmacistCreateInput = {
    licenseno: string
    pharmacy: string
    dispenserecord?: DispenseRecordCreateNestedManyWithoutPharmacistInput
    users?: UserCreateNestedOneWithoutPharmacistInput
  }

  export type PharmacistUncheckedCreateInput = {
    id?: number
    userid?: number | null
    licenseno: string
    pharmacy: string
    dispenserecord?: DispenseRecordUncheckedCreateNestedManyWithoutPharmacistInput
  }

  export type PharmacistUpdateInput = {
    licenseno?: StringFieldUpdateOperationsInput | string
    pharmacy?: StringFieldUpdateOperationsInput | string
    dispenserecord?: DispenseRecordUpdateManyWithoutPharmacistNestedInput
    users?: UserUpdateOneWithoutPharmacistNestedInput
  }

  export type PharmacistUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    licenseno?: StringFieldUpdateOperationsInput | string
    pharmacy?: StringFieldUpdateOperationsInput | string
    dispenserecord?: DispenseRecordUncheckedUpdateManyWithoutPharmacistNestedInput
  }

  export type PharmacistCreateManyInput = {
    id?: number
    userid?: number | null
    licenseno: string
    pharmacy: string
  }

  export type PharmacistUpdateManyMutationInput = {
    licenseno?: StringFieldUpdateOperationsInput | string
    pharmacy?: StringFieldUpdateOperationsInput | string
  }

  export type PharmacistUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    licenseno?: StringFieldUpdateOperationsInput | string
    pharmacy?: StringFieldUpdateOperationsInput | string
  }

  export type ManufacturerCreateInput = {
    companyname: string
    drugbatch?: DrugBatchCreateNestedManyWithoutManufacturerInput
    users?: UserCreateNestedOneWithoutManufacturerInput
  }

  export type ManufacturerUncheckedCreateInput = {
    id?: number
    userid?: number | null
    companyname: string
    drugbatch?: DrugBatchUncheckedCreateNestedManyWithoutManufacturerInput
  }

  export type ManufacturerUpdateInput = {
    companyname?: StringFieldUpdateOperationsInput | string
    drugbatch?: DrugBatchUpdateManyWithoutManufacturerNestedInput
    users?: UserUpdateOneWithoutManufacturerNestedInput
  }

  export type ManufacturerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    companyname?: StringFieldUpdateOperationsInput | string
    drugbatch?: DrugBatchUncheckedUpdateManyWithoutManufacturerNestedInput
  }

  export type ManufacturerCreateManyInput = {
    id?: number
    userid?: number | null
    companyname: string
  }

  export type ManufacturerUpdateManyMutationInput = {
    companyname?: StringFieldUpdateOperationsInput | string
  }

  export type ManufacturerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    companyname?: StringFieldUpdateOperationsInput | string
  }

  export type DistributorCreateInput = {
    companyname: string
    users?: UserCreateNestedOneWithoutDistributorInput
  }

  export type DistributorUncheckedCreateInput = {
    id?: number
    userid?: number | null
    companyname: string
  }

  export type DistributorUpdateInput = {
    companyname?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateOneWithoutDistributorNestedInput
  }

  export type DistributorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    companyname?: StringFieldUpdateOperationsInput | string
  }

  export type DistributorCreateManyInput = {
    id?: number
    userid?: number | null
    companyname: string
  }

  export type DistributorUpdateManyMutationInput = {
    companyname?: StringFieldUpdateOperationsInput | string
  }

  export type DistributorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    companyname?: StringFieldUpdateOperationsInput | string
  }

  export type RegulatorCreateInput = {
    agencyname: string
    users?: UserCreateNestedOneWithoutRegulatorInput
  }

  export type RegulatorUncheckedCreateInput = {
    id?: number
    userid?: number | null
    agencyname: string
  }

  export type RegulatorUpdateInput = {
    agencyname?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateOneWithoutRegulatorNestedInput
  }

  export type RegulatorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    agencyname?: StringFieldUpdateOperationsInput | string
  }

  export type RegulatorCreateManyInput = {
    id?: number
    userid?: number | null
    agencyname: string
  }

  export type RegulatorUpdateManyMutationInput = {
    agencyname?: StringFieldUpdateOperationsInput | string
  }

  export type RegulatorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    agencyname?: StringFieldUpdateOperationsInput | string
  }

  export type AdminCreateInput = {
    users?: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    id?: number
    userid?: number | null
  }

  export type AdminUpdateInput = {
    users?: UserUpdateOneWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AdminCreateManyInput = {
    id?: number
    userid?: number | null
  }

  export type AdminUpdateManyMutationInput = {

  }

  export type AdminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DrugCreateInput = {
    name: string
    code: string
    formulation: string
    dosageunit: string
    drugbatch?: DrugBatchCreateNestedManyWithoutDrugInput
    prescription?: PrescriptionCreateNestedManyWithoutDrugInput
  }

  export type DrugUncheckedCreateInput = {
    id?: number
    name: string
    code: string
    formulation: string
    dosageunit: string
    drugbatch?: DrugBatchUncheckedCreateNestedManyWithoutDrugInput
    prescription?: PrescriptionUncheckedCreateNestedManyWithoutDrugInput
  }

  export type DrugUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    formulation?: StringFieldUpdateOperationsInput | string
    dosageunit?: StringFieldUpdateOperationsInput | string
    drugbatch?: DrugBatchUpdateManyWithoutDrugNestedInput
    prescription?: PrescriptionUpdateManyWithoutDrugNestedInput
  }

  export type DrugUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    formulation?: StringFieldUpdateOperationsInput | string
    dosageunit?: StringFieldUpdateOperationsInput | string
    drugbatch?: DrugBatchUncheckedUpdateManyWithoutDrugNestedInput
    prescription?: PrescriptionUncheckedUpdateManyWithoutDrugNestedInput
  }

  export type DrugCreateManyInput = {
    id?: number
    name: string
    code: string
    formulation: string
    dosageunit: string
  }

  export type DrugUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    formulation?: StringFieldUpdateOperationsInput | string
    dosageunit?: StringFieldUpdateOperationsInput | string
  }

  export type DrugUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    formulation?: StringFieldUpdateOperationsInput | string
    dosageunit?: StringFieldUpdateOperationsInput | string
  }

  export type PrescriptionCreateInput = {
    dosage: string
    issuedat?: Date | string | null
    expiresat: Date | string
    blockchaintx?: string | null
    qrcode: string
    ipfshash?: string | null
    status: string
    blockchaineventlog?: BlockchainEventLogCreateNestedManyWithoutPrescriptionInput
    dispenserecord?: DispenseRecordCreateNestedManyWithoutPrescriptionInput
    doctor?: DoctorCreateNestedOneWithoutPrescriptionInput
    drug?: DrugCreateNestedOneWithoutPrescriptionInput
    patient?: PatientCreateNestedOneWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateInput = {
    id?: number
    patientid?: number | null
    doctorid?: number | null
    drugid?: number | null
    dosage: string
    issuedat?: Date | string | null
    expiresat: Date | string
    blockchaintx?: string | null
    qrcode: string
    ipfshash?: string | null
    status: string
    blockchaineventlog?: BlockchainEventLogUncheckedCreateNestedManyWithoutPrescriptionInput
    dispenserecord?: DispenseRecordUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUpdateInput = {
    dosage?: StringFieldUpdateOperationsInput | string
    issuedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresat?: DateTimeFieldUpdateOperationsInput | Date | string
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: StringFieldUpdateOperationsInput | string
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    blockchaineventlog?: BlockchainEventLogUpdateManyWithoutPrescriptionNestedInput
    dispenserecord?: DispenseRecordUpdateManyWithoutPrescriptionNestedInput
    doctor?: DoctorUpdateOneWithoutPrescriptionNestedInput
    drug?: DrugUpdateOneWithoutPrescriptionNestedInput
    patient?: PatientUpdateOneWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientid?: NullableIntFieldUpdateOperationsInput | number | null
    doctorid?: NullableIntFieldUpdateOperationsInput | number | null
    drugid?: NullableIntFieldUpdateOperationsInput | number | null
    dosage?: StringFieldUpdateOperationsInput | string
    issuedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresat?: DateTimeFieldUpdateOperationsInput | Date | string
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: StringFieldUpdateOperationsInput | string
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    blockchaineventlog?: BlockchainEventLogUncheckedUpdateManyWithoutPrescriptionNestedInput
    dispenserecord?: DispenseRecordUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionCreateManyInput = {
    id?: number
    patientid?: number | null
    doctorid?: number | null
    drugid?: number | null
    dosage: string
    issuedat?: Date | string | null
    expiresat: Date | string
    blockchaintx?: string | null
    qrcode: string
    ipfshash?: string | null
    status: string
  }

  export type PrescriptionUpdateManyMutationInput = {
    dosage?: StringFieldUpdateOperationsInput | string
    issuedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresat?: DateTimeFieldUpdateOperationsInput | Date | string
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: StringFieldUpdateOperationsInput | string
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type PrescriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientid?: NullableIntFieldUpdateOperationsInput | number | null
    doctorid?: NullableIntFieldUpdateOperationsInput | number | null
    drugid?: NullableIntFieldUpdateOperationsInput | number | null
    dosage?: StringFieldUpdateOperationsInput | string
    issuedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresat?: DateTimeFieldUpdateOperationsInput | Date | string
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: StringFieldUpdateOperationsInput | string
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type DrugBatchCreateInput = {
    batchnumber: string
    manufacturedate: Date | string
    expirydate: Date | string
    blockchaintx?: string | null
    qrcode: string
    ipfshash?: string | null
    blockchaineventlog?: BlockchainEventLogCreateNestedManyWithoutDrugbatchInput
    dispenserecord?: DispenseRecordCreateNestedManyWithoutDrugbatchInput
    drug?: DrugCreateNestedOneWithoutDrugbatchInput
    manufacturer?: ManufacturerCreateNestedOneWithoutDrugbatchInput
    supplychainrecord?: SupplyChainRecordCreateNestedManyWithoutDrugbatchInput
  }

  export type DrugBatchUncheckedCreateInput = {
    id?: number
    manufacturerid?: number | null
    drugid?: number | null
    batchnumber: string
    manufacturedate: Date | string
    expirydate: Date | string
    blockchaintx?: string | null
    qrcode: string
    ipfshash?: string | null
    blockchaineventlog?: BlockchainEventLogUncheckedCreateNestedManyWithoutDrugbatchInput
    dispenserecord?: DispenseRecordUncheckedCreateNestedManyWithoutDrugbatchInput
    supplychainrecord?: SupplyChainRecordUncheckedCreateNestedManyWithoutDrugbatchInput
  }

  export type DrugBatchUpdateInput = {
    batchnumber?: StringFieldUpdateOperationsInput | string
    manufacturedate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirydate?: DateTimeFieldUpdateOperationsInput | Date | string
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: StringFieldUpdateOperationsInput | string
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
    blockchaineventlog?: BlockchainEventLogUpdateManyWithoutDrugbatchNestedInput
    dispenserecord?: DispenseRecordUpdateManyWithoutDrugbatchNestedInput
    drug?: DrugUpdateOneWithoutDrugbatchNestedInput
    manufacturer?: ManufacturerUpdateOneWithoutDrugbatchNestedInput
    supplychainrecord?: SupplyChainRecordUpdateManyWithoutDrugbatchNestedInput
  }

  export type DrugBatchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    manufacturerid?: NullableIntFieldUpdateOperationsInput | number | null
    drugid?: NullableIntFieldUpdateOperationsInput | number | null
    batchnumber?: StringFieldUpdateOperationsInput | string
    manufacturedate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirydate?: DateTimeFieldUpdateOperationsInput | Date | string
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: StringFieldUpdateOperationsInput | string
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
    blockchaineventlog?: BlockchainEventLogUncheckedUpdateManyWithoutDrugbatchNestedInput
    dispenserecord?: DispenseRecordUncheckedUpdateManyWithoutDrugbatchNestedInput
    supplychainrecord?: SupplyChainRecordUncheckedUpdateManyWithoutDrugbatchNestedInput
  }

  export type DrugBatchCreateManyInput = {
    id?: number
    manufacturerid?: number | null
    drugid?: number | null
    batchnumber: string
    manufacturedate: Date | string
    expirydate: Date | string
    blockchaintx?: string | null
    qrcode: string
    ipfshash?: string | null
  }

  export type DrugBatchUpdateManyMutationInput = {
    batchnumber?: StringFieldUpdateOperationsInput | string
    manufacturedate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirydate?: DateTimeFieldUpdateOperationsInput | Date | string
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: StringFieldUpdateOperationsInput | string
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DrugBatchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    manufacturerid?: NullableIntFieldUpdateOperationsInput | number | null
    drugid?: NullableIntFieldUpdateOperationsInput | number | null
    batchnumber?: StringFieldUpdateOperationsInput | string
    manufacturedate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirydate?: DateTimeFieldUpdateOperationsInput | Date | string
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: StringFieldUpdateOperationsInput | string
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupplyChainRecordCreateInput = {
    action: string
    timestamp?: Date | string | null
    blockchaintx?: string | null
    blockchaineventlog?: BlockchainEventLogCreateNestedManyWithoutSupplychainrecordInput
    drugbatch?: DrugBatchCreateNestedOneWithoutSupplychainrecordInput
    users_supplychainrecord_fromentityidTousers?: UserCreateNestedOneWithoutSupplychainrecord_supplychainrecord_fromentityidTousersInput
    users_supplychainrecord_toentityidTousers?: UserCreateNestedOneWithoutSupplychainrecord_supplychainrecord_toentityidTousersInput
  }

  export type SupplyChainRecordUncheckedCreateInput = {
    id?: number
    drugbatchid?: number | null
    fromentityid?: number | null
    toentityid?: number | null
    action: string
    timestamp?: Date | string | null
    blockchaintx?: string | null
    blockchaineventlog?: BlockchainEventLogUncheckedCreateNestedManyWithoutSupplychainrecordInput
  }

  export type SupplyChainRecordUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    blockchaineventlog?: BlockchainEventLogUpdateManyWithoutSupplychainrecordNestedInput
    drugbatch?: DrugBatchUpdateOneWithoutSupplychainrecordNestedInput
    users_supplychainrecord_fromentityidTousers?: UserUpdateOneWithoutSupplychainrecord_supplychainrecord_fromentityidTousersNestedInput
    users_supplychainrecord_toentityidTousers?: UserUpdateOneWithoutSupplychainrecord_supplychainrecord_toentityidTousersNestedInput
  }

  export type SupplyChainRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    drugbatchid?: NullableIntFieldUpdateOperationsInput | number | null
    fromentityid?: NullableIntFieldUpdateOperationsInput | number | null
    toentityid?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    blockchaineventlog?: BlockchainEventLogUncheckedUpdateManyWithoutSupplychainrecordNestedInput
  }

  export type SupplyChainRecordCreateManyInput = {
    id?: number
    drugbatchid?: number | null
    fromentityid?: number | null
    toentityid?: number | null
    action: string
    timestamp?: Date | string | null
    blockchaintx?: string | null
  }

  export type SupplyChainRecordUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupplyChainRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    drugbatchid?: NullableIntFieldUpdateOperationsInput | number | null
    fromentityid?: NullableIntFieldUpdateOperationsInput | number | null
    toentityid?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RevocationRecordCreateInput = {
    type: string
    refid: number
    reason: string
    timestamp?: Date | string | null
    blockchaintx?: string | null
    users?: UserCreateNestedOneWithoutRevocationrecordInput
  }

  export type RevocationRecordUncheckedCreateInput = {
    id?: number
    type: string
    refid: number
    reason: string
    revokedbyid?: number | null
    timestamp?: Date | string | null
    blockchaintx?: string | null
  }

  export type RevocationRecordUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    refid?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateOneWithoutRevocationrecordNestedInput
  }

  export type RevocationRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    refid?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    revokedbyid?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RevocationRecordCreateManyInput = {
    id?: number
    type: string
    refid: number
    reason: string
    revokedbyid?: number | null
    timestamp?: Date | string | null
    blockchaintx?: string | null
  }

  export type RevocationRecordUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    refid?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RevocationRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    refid?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    revokedbyid?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OtpCreateInput = {
    code: string
    expiresat: Date | string
    createdat?: Date | string | null
    users?: UserCreateNestedOneWithoutOtpInput
  }

  export type OtpUncheckedCreateInput = {
    id?: number
    userid?: number | null
    code: string
    expiresat: Date | string
    createdat?: Date | string | null
  }

  export type OtpUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    expiresat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateOneWithoutOtpNestedInput
  }

  export type OtpUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    expiresat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OtpCreateManyInput = {
    id?: number
    userid?: number | null
    code: string
    expiresat: Date | string
    createdat?: Date | string | null
  }

  export type OtpUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    expiresat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OtpUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    expiresat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AlertCreateInput = {
    title: string
    message: string
    isread?: boolean | null
    priority: string
    createdat?: Date | string | null
    users?: UserCreateNestedOneWithoutAlertInput
  }

  export type AlertUncheckedCreateInput = {
    id?: number
    userid?: number | null
    title: string
    message: string
    isread?: boolean | null
    priority: string
    createdat?: Date | string | null
  }

  export type AlertUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isread?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priority?: StringFieldUpdateOperationsInput | string
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateOneWithoutAlertNestedInput
  }

  export type AlertUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isread?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priority?: StringFieldUpdateOperationsInput | string
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AlertCreateManyInput = {
    id?: number
    userid?: number | null
    title: string
    message: string
    isread?: boolean | null
    priority: string
    createdat?: Date | string | null
  }

  export type AlertUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isread?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priority?: StringFieldUpdateOperationsInput | string
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AlertUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isread?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priority?: StringFieldUpdateOperationsInput | string
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActivityLogCreateInput = {
    action: string
    details?: string | null
    timestamp?: Date | string | null
    users?: UserCreateNestedOneWithoutActivitylogInput
  }

  export type ActivityLogUncheckedCreateInput = {
    id?: number
    userid?: number | null
    action: string
    details?: string | null
    timestamp?: Date | string | null
  }

  export type ActivityLogUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateOneWithoutActivitylogNestedInput
  }

  export type ActivityLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActivityLogCreateManyInput = {
    id?: number
    userid?: number | null
    action: string
    details?: string | null
    timestamp?: Date | string | null
  }

  export type ActivityLogUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActivityLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportCreateInput = {
    reporttype: string
    filters?: NullableJsonNullValueInput | InputJsonValue
    generatedat?: Date | string | null
    ipfshash?: string | null
    users?: UserCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateInput = {
    id?: number
    userid?: number | null
    reporttype: string
    filters?: NullableJsonNullValueInput | InputJsonValue
    generatedat?: Date | string | null
    ipfshash?: string | null
  }

  export type ReportUpdateInput = {
    reporttype?: StringFieldUpdateOperationsInput | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    generatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateOneWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    reporttype?: StringFieldUpdateOperationsInput | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    generatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportCreateManyInput = {
    id?: number
    userid?: number | null
    reporttype: string
    filters?: NullableJsonNullValueInput | InputJsonValue
    generatedat?: Date | string | null
    ipfshash?: string | null
  }

  export type ReportUpdateManyMutationInput = {
    reporttype?: StringFieldUpdateOperationsInput | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    generatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    reporttype?: StringFieldUpdateOperationsInput | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    generatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DispenseRecordCreateInput = {
    quantity: number
    dispensedat?: Date | string | null
    blockchaintx?: string | null
    drugbatch?: DrugBatchCreateNestedOneWithoutDispenserecordInput
    pharmacist?: PharmacistCreateNestedOneWithoutDispenserecordInput
    prescription?: PrescriptionCreateNestedOneWithoutDispenserecordInput
  }

  export type DispenseRecordUncheckedCreateInput = {
    id?: number
    prescriptionid?: number | null
    pharmacistid?: number | null
    drugbatchid?: number | null
    quantity: number
    dispensedat?: Date | string | null
    blockchaintx?: string | null
  }

  export type DispenseRecordUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    dispensedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    drugbatch?: DrugBatchUpdateOneWithoutDispenserecordNestedInput
    pharmacist?: PharmacistUpdateOneWithoutDispenserecordNestedInput
    prescription?: PrescriptionUpdateOneWithoutDispenserecordNestedInput
  }

  export type DispenseRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    prescriptionid?: NullableIntFieldUpdateOperationsInput | number | null
    pharmacistid?: NullableIntFieldUpdateOperationsInput | number | null
    drugbatchid?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    dispensedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DispenseRecordCreateManyInput = {
    id?: number
    prescriptionid?: number | null
    pharmacistid?: number | null
    drugbatchid?: number | null
    quantity: number
    dispensedat?: Date | string | null
    blockchaintx?: string | null
  }

  export type DispenseRecordUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    dispensedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DispenseRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    prescriptionid?: NullableIntFieldUpdateOperationsInput | number | null
    pharmacistid?: NullableIntFieldUpdateOperationsInput | number | null
    drugbatchid?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    dispensedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BlockchainEventLogCreateInput = {
    eventname: string
    contractname: string
    entitytype?: string | null
    transactionhash: string
    timestamp?: Date | string | null
    processed?: boolean | null
    drugbatch?: DrugBatchCreateNestedOneWithoutBlockchaineventlogInput
    prescription?: PrescriptionCreateNestedOneWithoutBlockchaineventlogInput
    supplychainrecord?: SupplyChainRecordCreateNestedOneWithoutBlockchaineventlogInput
  }

  export type BlockchainEventLogUncheckedCreateInput = {
    id?: number
    eventname: string
    contractname: string
    entityid?: number | null
    entitytype?: string | null
    transactionhash: string
    timestamp?: Date | string | null
    processed?: boolean | null
  }

  export type BlockchainEventLogUpdateInput = {
    eventname?: StringFieldUpdateOperationsInput | string
    contractname?: StringFieldUpdateOperationsInput | string
    entitytype?: NullableStringFieldUpdateOperationsInput | string | null
    transactionhash?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    drugbatch?: DrugBatchUpdateOneWithoutBlockchaineventlogNestedInput
    prescription?: PrescriptionUpdateOneWithoutBlockchaineventlogNestedInput
    supplychainrecord?: SupplyChainRecordUpdateOneWithoutBlockchaineventlogNestedInput
  }

  export type BlockchainEventLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventname?: StringFieldUpdateOperationsInput | string
    contractname?: StringFieldUpdateOperationsInput | string
    entityid?: NullableIntFieldUpdateOperationsInput | number | null
    entitytype?: NullableStringFieldUpdateOperationsInput | string | null
    transactionhash?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processed?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type BlockchainEventLogCreateManyInput = {
    id?: number
    eventname: string
    contractname: string
    entityid?: number | null
    entitytype?: string | null
    transactionhash: string
    timestamp?: Date | string | null
    processed?: boolean | null
  }

  export type BlockchainEventLogUpdateManyMutationInput = {
    eventname?: StringFieldUpdateOperationsInput | string
    contractname?: StringFieldUpdateOperationsInput | string
    entitytype?: NullableStringFieldUpdateOperationsInput | string | null
    transactionhash?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processed?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type BlockchainEventLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventname?: StringFieldUpdateOperationsInput | string
    contractname?: StringFieldUpdateOperationsInput | string
    entityid?: NullableIntFieldUpdateOperationsInput | number | null
    entitytype?: NullableStringFieldUpdateOperationsInput | string | null
    transactionhash?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processed?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type ActivityLogListRelationFilter = {
    every?: ActivityLogWhereInput
    some?: ActivityLogWhereInput
    none?: ActivityLogWhereInput
  }

  export type AdminRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type AlertListRelationFilter = {
    every?: AlertWhereInput
    some?: AlertWhereInput
    none?: AlertWhereInput
  }

  export type DistributorRelationFilter = {
    is?: DistributorWhereInput | null
    isNot?: DistributorWhereInput | null
  }

  export type DoctorRelationFilter = {
    is?: DoctorWhereInput | null
    isNot?: DoctorWhereInput | null
  }

  export type ManufacturerRelationFilter = {
    is?: ManufacturerWhereInput | null
    isNot?: ManufacturerWhereInput | null
  }

  export type OtpListRelationFilter = {
    every?: OtpWhereInput
    some?: OtpWhereInput
    none?: OtpWhereInput
  }

  export type PatientRelationFilter = {
    is?: PatientWhereInput | null
    isNot?: PatientWhereInput | null
  }

  export type PharmacistRelationFilter = {
    is?: PharmacistWhereInput | null
    isNot?: PharmacistWhereInput | null
  }

  export type RegulatorRelationFilter = {
    is?: RegulatorWhereInput | null
    isNot?: RegulatorWhereInput | null
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type RevocationRecordListRelationFilter = {
    every?: RevocationRecordWhereInput
    some?: RevocationRecordWhereInput
    none?: RevocationRecordWhereInput
  }

  export type SupplyChainRecordListRelationFilter = {
    every?: SupplyChainRecordWhereInput
    some?: SupplyChainRecordWhereInput
    none?: SupplyChainRecordWhereInput
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput | null
    isNot?: RoleWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OtpOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RevocationRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplyChainRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    wallet?: SortOrder
    email?: SortOrder
    passwordhash?: SortOrder
    roleid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    roleid?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    wallet?: SortOrder
    email?: SortOrder
    passwordhash?: SortOrder
    roleid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    wallet?: SortOrder
    email?: SortOrder
    passwordhash?: SortOrder
    roleid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    roleid?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type PermissionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type PermissionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type PrescriptionListRelationFilter = {
    every?: PrescriptionWhereInput
    some?: PrescriptionWhereInput
    none?: PrescriptionWhereInput
  }

  export type PrescriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DoctorCountOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    licenseno?: SortOrder
    hospital?: SortOrder
  }

  export type DoctorAvgOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type DoctorMaxOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    licenseno?: SortOrder
    hospital?: SortOrder
  }

  export type DoctorMinOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    licenseno?: SortOrder
    hospital?: SortOrder
  }

  export type DoctorSumOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type PatientCountOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    dateofbirth?: SortOrder
  }

  export type PatientAvgOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type PatientMaxOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    dateofbirth?: SortOrder
  }

  export type PatientMinOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    dateofbirth?: SortOrder
  }

  export type PatientSumOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type DispenseRecordListRelationFilter = {
    every?: DispenseRecordWhereInput
    some?: DispenseRecordWhereInput
    none?: DispenseRecordWhereInput
  }

  export type DispenseRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PharmacistCountOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    licenseno?: SortOrder
    pharmacy?: SortOrder
  }

  export type PharmacistAvgOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type PharmacistMaxOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    licenseno?: SortOrder
    pharmacy?: SortOrder
  }

  export type PharmacistMinOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    licenseno?: SortOrder
    pharmacy?: SortOrder
  }

  export type PharmacistSumOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type DrugBatchListRelationFilter = {
    every?: DrugBatchWhereInput
    some?: DrugBatchWhereInput
    none?: DrugBatchWhereInput
  }

  export type DrugBatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ManufacturerCountOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    companyname?: SortOrder
  }

  export type ManufacturerAvgOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type ManufacturerMaxOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    companyname?: SortOrder
  }

  export type ManufacturerMinOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    companyname?: SortOrder
  }

  export type ManufacturerSumOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type DistributorCountOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    companyname?: SortOrder
  }

  export type DistributorAvgOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type DistributorMaxOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    companyname?: SortOrder
  }

  export type DistributorMinOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    companyname?: SortOrder
  }

  export type DistributorSumOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type RegulatorCountOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    agencyname?: SortOrder
  }

  export type RegulatorAvgOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type RegulatorMaxOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    agencyname?: SortOrder
  }

  export type RegulatorMinOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    agencyname?: SortOrder
  }

  export type RegulatorSumOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type AdminAvgOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type AdminSumOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type DrugCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    formulation?: SortOrder
    dosageunit?: SortOrder
  }

  export type DrugAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DrugMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    formulation?: SortOrder
    dosageunit?: SortOrder
  }

  export type DrugMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    formulation?: SortOrder
    dosageunit?: SortOrder
  }

  export type DrugSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BlockchainEventLogListRelationFilter = {
    every?: BlockchainEventLogWhereInput
    some?: BlockchainEventLogWhereInput
    none?: BlockchainEventLogWhereInput
  }

  export type DrugRelationFilter = {
    is?: DrugWhereInput | null
    isNot?: DrugWhereInput | null
  }

  export type BlockchainEventLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrescriptionCountOrderByAggregateInput = {
    id?: SortOrder
    patientid?: SortOrder
    doctorid?: SortOrder
    drugid?: SortOrder
    dosage?: SortOrder
    issuedat?: SortOrder
    expiresat?: SortOrder
    blockchaintx?: SortOrder
    qrcode?: SortOrder
    ipfshash?: SortOrder
    status?: SortOrder
  }

  export type PrescriptionAvgOrderByAggregateInput = {
    id?: SortOrder
    patientid?: SortOrder
    doctorid?: SortOrder
    drugid?: SortOrder
  }

  export type PrescriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    patientid?: SortOrder
    doctorid?: SortOrder
    drugid?: SortOrder
    dosage?: SortOrder
    issuedat?: SortOrder
    expiresat?: SortOrder
    blockchaintx?: SortOrder
    qrcode?: SortOrder
    ipfshash?: SortOrder
    status?: SortOrder
  }

  export type PrescriptionMinOrderByAggregateInput = {
    id?: SortOrder
    patientid?: SortOrder
    doctorid?: SortOrder
    drugid?: SortOrder
    dosage?: SortOrder
    issuedat?: SortOrder
    expiresat?: SortOrder
    blockchaintx?: SortOrder
    qrcode?: SortOrder
    ipfshash?: SortOrder
    status?: SortOrder
  }

  export type PrescriptionSumOrderByAggregateInput = {
    id?: SortOrder
    patientid?: SortOrder
    doctorid?: SortOrder
    drugid?: SortOrder
  }

  export type DrugBatchCountOrderByAggregateInput = {
    id?: SortOrder
    manufacturerid?: SortOrder
    drugid?: SortOrder
    batchnumber?: SortOrder
    manufacturedate?: SortOrder
    expirydate?: SortOrder
    blockchaintx?: SortOrder
    qrcode?: SortOrder
    ipfshash?: SortOrder
  }

  export type DrugBatchAvgOrderByAggregateInput = {
    id?: SortOrder
    manufacturerid?: SortOrder
    drugid?: SortOrder
  }

  export type DrugBatchMaxOrderByAggregateInput = {
    id?: SortOrder
    manufacturerid?: SortOrder
    drugid?: SortOrder
    batchnumber?: SortOrder
    manufacturedate?: SortOrder
    expirydate?: SortOrder
    blockchaintx?: SortOrder
    qrcode?: SortOrder
    ipfshash?: SortOrder
  }

  export type DrugBatchMinOrderByAggregateInput = {
    id?: SortOrder
    manufacturerid?: SortOrder
    drugid?: SortOrder
    batchnumber?: SortOrder
    manufacturedate?: SortOrder
    expirydate?: SortOrder
    blockchaintx?: SortOrder
    qrcode?: SortOrder
    ipfshash?: SortOrder
  }

  export type DrugBatchSumOrderByAggregateInput = {
    id?: SortOrder
    manufacturerid?: SortOrder
    drugid?: SortOrder
  }

  export type DrugBatchRelationFilter = {
    is?: DrugBatchWhereInput | null
    isNot?: DrugBatchWhereInput | null
  }

  export type SupplyChainRecordCountOrderByAggregateInput = {
    id?: SortOrder
    drugbatchid?: SortOrder
    fromentityid?: SortOrder
    toentityid?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
    blockchaintx?: SortOrder
  }

  export type SupplyChainRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    drugbatchid?: SortOrder
    fromentityid?: SortOrder
    toentityid?: SortOrder
  }

  export type SupplyChainRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    drugbatchid?: SortOrder
    fromentityid?: SortOrder
    toentityid?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
    blockchaintx?: SortOrder
  }

  export type SupplyChainRecordMinOrderByAggregateInput = {
    id?: SortOrder
    drugbatchid?: SortOrder
    fromentityid?: SortOrder
    toentityid?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
    blockchaintx?: SortOrder
  }

  export type SupplyChainRecordSumOrderByAggregateInput = {
    id?: SortOrder
    drugbatchid?: SortOrder
    fromentityid?: SortOrder
    toentityid?: SortOrder
  }

  export type RevocationRecordCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    refid?: SortOrder
    reason?: SortOrder
    revokedbyid?: SortOrder
    timestamp?: SortOrder
    blockchaintx?: SortOrder
  }

  export type RevocationRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    refid?: SortOrder
    revokedbyid?: SortOrder
  }

  export type RevocationRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    refid?: SortOrder
    reason?: SortOrder
    revokedbyid?: SortOrder
    timestamp?: SortOrder
    blockchaintx?: SortOrder
  }

  export type RevocationRecordMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    refid?: SortOrder
    reason?: SortOrder
    revokedbyid?: SortOrder
    timestamp?: SortOrder
    blockchaintx?: SortOrder
  }

  export type RevocationRecordSumOrderByAggregateInput = {
    id?: SortOrder
    refid?: SortOrder
    revokedbyid?: SortOrder
  }

  export type OtpCountOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    code?: SortOrder
    expiresat?: SortOrder
    createdat?: SortOrder
  }

  export type OtpAvgOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type OtpMaxOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    code?: SortOrder
    expiresat?: SortOrder
    createdat?: SortOrder
  }

  export type OtpMinOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    code?: SortOrder
    expiresat?: SortOrder
    createdat?: SortOrder
  }

  export type OtpSumOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type AlertCountOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isread?: SortOrder
    priority?: SortOrder
    createdat?: SortOrder
  }

  export type AlertAvgOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type AlertMaxOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isread?: SortOrder
    priority?: SortOrder
    createdat?: SortOrder
  }

  export type AlertMinOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isread?: SortOrder
    priority?: SortOrder
    createdat?: SortOrder
  }

  export type AlertSumOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type ActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    action?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
  }

  export type ActivityLogAvgOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type ActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    action?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
  }

  export type ActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    action?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
  }

  export type ActivityLogSumOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }
  export type JsonNullableFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase>, Exclude<keyof Required<JsonNullableFilterBase>, 'path'>>,
        Required<JsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase>, 'path'>>

  export type JsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    reporttype?: SortOrder
    filters?: SortOrder
    generatedat?: SortOrder
    ipfshash?: SortOrder
  }

  export type ReportAvgOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    reporttype?: SortOrder
    generatedat?: SortOrder
    ipfshash?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    reporttype?: SortOrder
    generatedat?: SortOrder
    ipfshash?: SortOrder
  }

  export type ReportSumOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
    _count?: NestedIntNullableFilter
    _min?: NestedJsonNullableFilter
    _max?: NestedJsonNullableFilter
  }

  export type PrescriptionRelationFilter = {
    is?: PrescriptionWhereInput | null
    isNot?: PrescriptionWhereInput | null
  }

  export type DispenseRecordCountOrderByAggregateInput = {
    id?: SortOrder
    prescriptionid?: SortOrder
    pharmacistid?: SortOrder
    drugbatchid?: SortOrder
    quantity?: SortOrder
    dispensedat?: SortOrder
    blockchaintx?: SortOrder
  }

  export type DispenseRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    prescriptionid?: SortOrder
    pharmacistid?: SortOrder
    drugbatchid?: SortOrder
    quantity?: SortOrder
  }

  export type DispenseRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    prescriptionid?: SortOrder
    pharmacistid?: SortOrder
    drugbatchid?: SortOrder
    quantity?: SortOrder
    dispensedat?: SortOrder
    blockchaintx?: SortOrder
  }

  export type DispenseRecordMinOrderByAggregateInput = {
    id?: SortOrder
    prescriptionid?: SortOrder
    pharmacistid?: SortOrder
    drugbatchid?: SortOrder
    quantity?: SortOrder
    dispensedat?: SortOrder
    blockchaintx?: SortOrder
  }

  export type DispenseRecordSumOrderByAggregateInput = {
    id?: SortOrder
    prescriptionid?: SortOrder
    pharmacistid?: SortOrder
    drugbatchid?: SortOrder
    quantity?: SortOrder
  }

  export type SupplyChainRecordRelationFilter = {
    is?: SupplyChainRecordWhereInput | null
    isNot?: SupplyChainRecordWhereInput | null
  }

  export type BlockchainEventLogCountOrderByAggregateInput = {
    id?: SortOrder
    eventname?: SortOrder
    contractname?: SortOrder
    entityid?: SortOrder
    entitytype?: SortOrder
    transactionhash?: SortOrder
    timestamp?: SortOrder
    processed?: SortOrder
  }

  export type BlockchainEventLogAvgOrderByAggregateInput = {
    id?: SortOrder
    entityid?: SortOrder
  }

  export type BlockchainEventLogMaxOrderByAggregateInput = {
    id?: SortOrder
    eventname?: SortOrder
    contractname?: SortOrder
    entityid?: SortOrder
    entitytype?: SortOrder
    transactionhash?: SortOrder
    timestamp?: SortOrder
    processed?: SortOrder
  }

  export type BlockchainEventLogMinOrderByAggregateInput = {
    id?: SortOrder
    eventname?: SortOrder
    contractname?: SortOrder
    entityid?: SortOrder
    entitytype?: SortOrder
    transactionhash?: SortOrder
    timestamp?: SortOrder
    processed?: SortOrder
  }

  export type BlockchainEventLogSumOrderByAggregateInput = {
    id?: SortOrder
    entityid?: SortOrder
  }

  export type UserCreateNestedManyWithoutRolesInput = {
    create?: XOR<Enumerable<UserCreateWithoutRolesInput>, Enumerable<UserUncheckedCreateWithoutRolesInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRolesInput>
    createMany?: UserCreateManyRolesInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<Enumerable<UserCreateWithoutRolesInput>, Enumerable<UserUncheckedCreateWithoutRolesInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRolesInput>
    createMany?: UserCreateManyRolesInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type UserUpdateManyWithoutRolesNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutRolesInput>, Enumerable<UserUncheckedCreateWithoutRolesInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRolesInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutRolesInput>
    createMany?: UserCreateManyRolesInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutRolesInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutRolesInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutRolesInput>, Enumerable<UserUncheckedCreateWithoutRolesInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRolesInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutRolesInput>
    createMany?: UserCreateManyRolesInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutRolesInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutRolesInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type ActivityLogCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<ActivityLogCreateWithoutUsersInput>, Enumerable<ActivityLogUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<ActivityLogCreateOrConnectWithoutUsersInput>
    createMany?: ActivityLogCreateManyUsersInputEnvelope
    connect?: Enumerable<ActivityLogWhereUniqueInput>
  }

  export type AdminCreateNestedOneWithoutUsersInput = {
    create?: XOR<AdminCreateWithoutUsersInput, AdminUncheckedCreateWithoutUsersInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUsersInput
    connect?: AdminWhereUniqueInput
  }

  export type AlertCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<AlertCreateWithoutUsersInput>, Enumerable<AlertUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<AlertCreateOrConnectWithoutUsersInput>
    createMany?: AlertCreateManyUsersInputEnvelope
    connect?: Enumerable<AlertWhereUniqueInput>
  }

  export type DistributorCreateNestedOneWithoutUsersInput = {
    create?: XOR<DistributorCreateWithoutUsersInput, DistributorUncheckedCreateWithoutUsersInput>
    connectOrCreate?: DistributorCreateOrConnectWithoutUsersInput
    connect?: DistributorWhereUniqueInput
  }

  export type DoctorCreateNestedOneWithoutUsersInput = {
    create?: XOR<DoctorCreateWithoutUsersInput, DoctorUncheckedCreateWithoutUsersInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutUsersInput
    connect?: DoctorWhereUniqueInput
  }

  export type ManufacturerCreateNestedOneWithoutUsersInput = {
    create?: XOR<ManufacturerCreateWithoutUsersInput, ManufacturerUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ManufacturerCreateOrConnectWithoutUsersInput
    connect?: ManufacturerWhereUniqueInput
  }

  export type OtpCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<OtpCreateWithoutUsersInput>, Enumerable<OtpUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<OtpCreateOrConnectWithoutUsersInput>
    createMany?: OtpCreateManyUsersInputEnvelope
    connect?: Enumerable<OtpWhereUniqueInput>
  }

  export type PatientCreateNestedOneWithoutUsersInput = {
    create?: XOR<PatientCreateWithoutUsersInput, PatientUncheckedCreateWithoutUsersInput>
    connectOrCreate?: PatientCreateOrConnectWithoutUsersInput
    connect?: PatientWhereUniqueInput
  }

  export type PharmacistCreateNestedOneWithoutUsersInput = {
    create?: XOR<PharmacistCreateWithoutUsersInput, PharmacistUncheckedCreateWithoutUsersInput>
    connectOrCreate?: PharmacistCreateOrConnectWithoutUsersInput
    connect?: PharmacistWhereUniqueInput
  }

  export type RegulatorCreateNestedOneWithoutUsersInput = {
    create?: XOR<RegulatorCreateWithoutUsersInput, RegulatorUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RegulatorCreateOrConnectWithoutUsersInput
    connect?: RegulatorWhereUniqueInput
  }

  export type ReportCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<ReportCreateWithoutUsersInput>, Enumerable<ReportUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<ReportCreateOrConnectWithoutUsersInput>
    createMany?: ReportCreateManyUsersInputEnvelope
    connect?: Enumerable<ReportWhereUniqueInput>
  }

  export type RevocationRecordCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<RevocationRecordCreateWithoutUsersInput>, Enumerable<RevocationRecordUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<RevocationRecordCreateOrConnectWithoutUsersInput>
    createMany?: RevocationRecordCreateManyUsersInputEnvelope
    connect?: Enumerable<RevocationRecordWhereUniqueInput>
  }

  export type SupplyChainRecordCreateNestedManyWithoutUsers_supplychainrecord_fromentityidTousersInput = {
    create?: XOR<Enumerable<SupplyChainRecordCreateWithoutUsers_supplychainrecord_fromentityidTousersInput>, Enumerable<SupplyChainRecordUncheckedCreateWithoutUsers_supplychainrecord_fromentityidTousersInput>>
    connectOrCreate?: Enumerable<SupplyChainRecordCreateOrConnectWithoutUsers_supplychainrecord_fromentityidTousersInput>
    createMany?: SupplyChainRecordCreateManyUsers_supplychainrecord_fromentityidTousersInputEnvelope
    connect?: Enumerable<SupplyChainRecordWhereUniqueInput>
  }

  export type SupplyChainRecordCreateNestedManyWithoutUsers_supplychainrecord_toentityidTousersInput = {
    create?: XOR<Enumerable<SupplyChainRecordCreateWithoutUsers_supplychainrecord_toentityidTousersInput>, Enumerable<SupplyChainRecordUncheckedCreateWithoutUsers_supplychainrecord_toentityidTousersInput>>
    connectOrCreate?: Enumerable<SupplyChainRecordCreateOrConnectWithoutUsers_supplychainrecord_toentityidTousersInput>
    createMany?: SupplyChainRecordCreateManyUsers_supplychainrecord_toentityidTousersInputEnvelope
    connect?: Enumerable<SupplyChainRecordWhereUniqueInput>
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<ActivityLogCreateWithoutUsersInput>, Enumerable<ActivityLogUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<ActivityLogCreateOrConnectWithoutUsersInput>
    createMany?: ActivityLogCreateManyUsersInputEnvelope
    connect?: Enumerable<ActivityLogWhereUniqueInput>
  }

  export type AdminUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<AdminCreateWithoutUsersInput, AdminUncheckedCreateWithoutUsersInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUsersInput
    connect?: AdminWhereUniqueInput
  }

  export type AlertUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<AlertCreateWithoutUsersInput>, Enumerable<AlertUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<AlertCreateOrConnectWithoutUsersInput>
    createMany?: AlertCreateManyUsersInputEnvelope
    connect?: Enumerable<AlertWhereUniqueInput>
  }

  export type DistributorUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<DistributorCreateWithoutUsersInput, DistributorUncheckedCreateWithoutUsersInput>
    connectOrCreate?: DistributorCreateOrConnectWithoutUsersInput
    connect?: DistributorWhereUniqueInput
  }

  export type DoctorUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<DoctorCreateWithoutUsersInput, DoctorUncheckedCreateWithoutUsersInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutUsersInput
    connect?: DoctorWhereUniqueInput
  }

  export type ManufacturerUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<ManufacturerCreateWithoutUsersInput, ManufacturerUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ManufacturerCreateOrConnectWithoutUsersInput
    connect?: ManufacturerWhereUniqueInput
  }

  export type OtpUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<OtpCreateWithoutUsersInput>, Enumerable<OtpUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<OtpCreateOrConnectWithoutUsersInput>
    createMany?: OtpCreateManyUsersInputEnvelope
    connect?: Enumerable<OtpWhereUniqueInput>
  }

  export type PatientUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<PatientCreateWithoutUsersInput, PatientUncheckedCreateWithoutUsersInput>
    connectOrCreate?: PatientCreateOrConnectWithoutUsersInput
    connect?: PatientWhereUniqueInput
  }

  export type PharmacistUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<PharmacistCreateWithoutUsersInput, PharmacistUncheckedCreateWithoutUsersInput>
    connectOrCreate?: PharmacistCreateOrConnectWithoutUsersInput
    connect?: PharmacistWhereUniqueInput
  }

  export type RegulatorUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<RegulatorCreateWithoutUsersInput, RegulatorUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RegulatorCreateOrConnectWithoutUsersInput
    connect?: RegulatorWhereUniqueInput
  }

  export type ReportUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<ReportCreateWithoutUsersInput>, Enumerable<ReportUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<ReportCreateOrConnectWithoutUsersInput>
    createMany?: ReportCreateManyUsersInputEnvelope
    connect?: Enumerable<ReportWhereUniqueInput>
  }

  export type RevocationRecordUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<RevocationRecordCreateWithoutUsersInput>, Enumerable<RevocationRecordUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<RevocationRecordCreateOrConnectWithoutUsersInput>
    createMany?: RevocationRecordCreateManyUsersInputEnvelope
    connect?: Enumerable<RevocationRecordWhereUniqueInput>
  }

  export type SupplyChainRecordUncheckedCreateNestedManyWithoutUsers_supplychainrecord_fromentityidTousersInput = {
    create?: XOR<Enumerable<SupplyChainRecordCreateWithoutUsers_supplychainrecord_fromentityidTousersInput>, Enumerable<SupplyChainRecordUncheckedCreateWithoutUsers_supplychainrecord_fromentityidTousersInput>>
    connectOrCreate?: Enumerable<SupplyChainRecordCreateOrConnectWithoutUsers_supplychainrecord_fromentityidTousersInput>
    createMany?: SupplyChainRecordCreateManyUsers_supplychainrecord_fromentityidTousersInputEnvelope
    connect?: Enumerable<SupplyChainRecordWhereUniqueInput>
  }

  export type SupplyChainRecordUncheckedCreateNestedManyWithoutUsers_supplychainrecord_toentityidTousersInput = {
    create?: XOR<Enumerable<SupplyChainRecordCreateWithoutUsers_supplychainrecord_toentityidTousersInput>, Enumerable<SupplyChainRecordUncheckedCreateWithoutUsers_supplychainrecord_toentityidTousersInput>>
    connectOrCreate?: Enumerable<SupplyChainRecordCreateOrConnectWithoutUsers_supplychainrecord_toentityidTousersInput>
    createMany?: SupplyChainRecordCreateManyUsers_supplychainrecord_toentityidTousersInputEnvelope
    connect?: Enumerable<SupplyChainRecordWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ActivityLogUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<ActivityLogCreateWithoutUsersInput>, Enumerable<ActivityLogUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<ActivityLogCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<ActivityLogUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: ActivityLogCreateManyUsersInputEnvelope
    set?: Enumerable<ActivityLogWhereUniqueInput>
    disconnect?: Enumerable<ActivityLogWhereUniqueInput>
    delete?: Enumerable<ActivityLogWhereUniqueInput>
    connect?: Enumerable<ActivityLogWhereUniqueInput>
    update?: Enumerable<ActivityLogUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<ActivityLogUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<ActivityLogScalarWhereInput>
  }

  export type AdminUpdateOneWithoutUsersNestedInput = {
    create?: XOR<AdminCreateWithoutUsersInput, AdminUncheckedCreateWithoutUsersInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUsersInput
    upsert?: AdminUpsertWithoutUsersInput
    disconnect?: boolean
    delete?: boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<AdminUpdateWithoutUsersInput, AdminUncheckedUpdateWithoutUsersInput>
  }

  export type AlertUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<AlertCreateWithoutUsersInput>, Enumerable<AlertUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<AlertCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<AlertUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: AlertCreateManyUsersInputEnvelope
    set?: Enumerable<AlertWhereUniqueInput>
    disconnect?: Enumerable<AlertWhereUniqueInput>
    delete?: Enumerable<AlertWhereUniqueInput>
    connect?: Enumerable<AlertWhereUniqueInput>
    update?: Enumerable<AlertUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<AlertUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<AlertScalarWhereInput>
  }

  export type DistributorUpdateOneWithoutUsersNestedInput = {
    create?: XOR<DistributorCreateWithoutUsersInput, DistributorUncheckedCreateWithoutUsersInput>
    connectOrCreate?: DistributorCreateOrConnectWithoutUsersInput
    upsert?: DistributorUpsertWithoutUsersInput
    disconnect?: boolean
    delete?: boolean
    connect?: DistributorWhereUniqueInput
    update?: XOR<DistributorUpdateWithoutUsersInput, DistributorUncheckedUpdateWithoutUsersInput>
  }

  export type DoctorUpdateOneWithoutUsersNestedInput = {
    create?: XOR<DoctorCreateWithoutUsersInput, DoctorUncheckedCreateWithoutUsersInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutUsersInput
    upsert?: DoctorUpsertWithoutUsersInput
    disconnect?: boolean
    delete?: boolean
    connect?: DoctorWhereUniqueInput
    update?: XOR<DoctorUpdateWithoutUsersInput, DoctorUncheckedUpdateWithoutUsersInput>
  }

  export type ManufacturerUpdateOneWithoutUsersNestedInput = {
    create?: XOR<ManufacturerCreateWithoutUsersInput, ManufacturerUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ManufacturerCreateOrConnectWithoutUsersInput
    upsert?: ManufacturerUpsertWithoutUsersInput
    disconnect?: boolean
    delete?: boolean
    connect?: ManufacturerWhereUniqueInput
    update?: XOR<ManufacturerUpdateWithoutUsersInput, ManufacturerUncheckedUpdateWithoutUsersInput>
  }

  export type OtpUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<OtpCreateWithoutUsersInput>, Enumerable<OtpUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<OtpCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<OtpUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: OtpCreateManyUsersInputEnvelope
    set?: Enumerable<OtpWhereUniqueInput>
    disconnect?: Enumerable<OtpWhereUniqueInput>
    delete?: Enumerable<OtpWhereUniqueInput>
    connect?: Enumerable<OtpWhereUniqueInput>
    update?: Enumerable<OtpUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<OtpUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<OtpScalarWhereInput>
  }

  export type PatientUpdateOneWithoutUsersNestedInput = {
    create?: XOR<PatientCreateWithoutUsersInput, PatientUncheckedCreateWithoutUsersInput>
    connectOrCreate?: PatientCreateOrConnectWithoutUsersInput
    upsert?: PatientUpsertWithoutUsersInput
    disconnect?: boolean
    delete?: boolean
    connect?: PatientWhereUniqueInput
    update?: XOR<PatientUpdateWithoutUsersInput, PatientUncheckedUpdateWithoutUsersInput>
  }

  export type PharmacistUpdateOneWithoutUsersNestedInput = {
    create?: XOR<PharmacistCreateWithoutUsersInput, PharmacistUncheckedCreateWithoutUsersInput>
    connectOrCreate?: PharmacistCreateOrConnectWithoutUsersInput
    upsert?: PharmacistUpsertWithoutUsersInput
    disconnect?: boolean
    delete?: boolean
    connect?: PharmacistWhereUniqueInput
    update?: XOR<PharmacistUpdateWithoutUsersInput, PharmacistUncheckedUpdateWithoutUsersInput>
  }

  export type RegulatorUpdateOneWithoutUsersNestedInput = {
    create?: XOR<RegulatorCreateWithoutUsersInput, RegulatorUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RegulatorCreateOrConnectWithoutUsersInput
    upsert?: RegulatorUpsertWithoutUsersInput
    disconnect?: boolean
    delete?: boolean
    connect?: RegulatorWhereUniqueInput
    update?: XOR<RegulatorUpdateWithoutUsersInput, RegulatorUncheckedUpdateWithoutUsersInput>
  }

  export type ReportUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<ReportCreateWithoutUsersInput>, Enumerable<ReportUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<ReportCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<ReportUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: ReportCreateManyUsersInputEnvelope
    set?: Enumerable<ReportWhereUniqueInput>
    disconnect?: Enumerable<ReportWhereUniqueInput>
    delete?: Enumerable<ReportWhereUniqueInput>
    connect?: Enumerable<ReportWhereUniqueInput>
    update?: Enumerable<ReportUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<ReportUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<ReportScalarWhereInput>
  }

  export type RevocationRecordUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<RevocationRecordCreateWithoutUsersInput>, Enumerable<RevocationRecordUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<RevocationRecordCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<RevocationRecordUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: RevocationRecordCreateManyUsersInputEnvelope
    set?: Enumerable<RevocationRecordWhereUniqueInput>
    disconnect?: Enumerable<RevocationRecordWhereUniqueInput>
    delete?: Enumerable<RevocationRecordWhereUniqueInput>
    connect?: Enumerable<RevocationRecordWhereUniqueInput>
    update?: Enumerable<RevocationRecordUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<RevocationRecordUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<RevocationRecordScalarWhereInput>
  }

  export type SupplyChainRecordUpdateManyWithoutUsers_supplychainrecord_fromentityidTousersNestedInput = {
    create?: XOR<Enumerable<SupplyChainRecordCreateWithoutUsers_supplychainrecord_fromentityidTousersInput>, Enumerable<SupplyChainRecordUncheckedCreateWithoutUsers_supplychainrecord_fromentityidTousersInput>>
    connectOrCreate?: Enumerable<SupplyChainRecordCreateOrConnectWithoutUsers_supplychainrecord_fromentityidTousersInput>
    upsert?: Enumerable<SupplyChainRecordUpsertWithWhereUniqueWithoutUsers_supplychainrecord_fromentityidTousersInput>
    createMany?: SupplyChainRecordCreateManyUsers_supplychainrecord_fromentityidTousersInputEnvelope
    set?: Enumerable<SupplyChainRecordWhereUniqueInput>
    disconnect?: Enumerable<SupplyChainRecordWhereUniqueInput>
    delete?: Enumerable<SupplyChainRecordWhereUniqueInput>
    connect?: Enumerable<SupplyChainRecordWhereUniqueInput>
    update?: Enumerable<SupplyChainRecordUpdateWithWhereUniqueWithoutUsers_supplychainrecord_fromentityidTousersInput>
    updateMany?: Enumerable<SupplyChainRecordUpdateManyWithWhereWithoutUsers_supplychainrecord_fromentityidTousersInput>
    deleteMany?: Enumerable<SupplyChainRecordScalarWhereInput>
  }

  export type SupplyChainRecordUpdateManyWithoutUsers_supplychainrecord_toentityidTousersNestedInput = {
    create?: XOR<Enumerable<SupplyChainRecordCreateWithoutUsers_supplychainrecord_toentityidTousersInput>, Enumerable<SupplyChainRecordUncheckedCreateWithoutUsers_supplychainrecord_toentityidTousersInput>>
    connectOrCreate?: Enumerable<SupplyChainRecordCreateOrConnectWithoutUsers_supplychainrecord_toentityidTousersInput>
    upsert?: Enumerable<SupplyChainRecordUpsertWithWhereUniqueWithoutUsers_supplychainrecord_toentityidTousersInput>
    createMany?: SupplyChainRecordCreateManyUsers_supplychainrecord_toentityidTousersInputEnvelope
    set?: Enumerable<SupplyChainRecordWhereUniqueInput>
    disconnect?: Enumerable<SupplyChainRecordWhereUniqueInput>
    delete?: Enumerable<SupplyChainRecordWhereUniqueInput>
    connect?: Enumerable<SupplyChainRecordWhereUniqueInput>
    update?: Enumerable<SupplyChainRecordUpdateWithWhereUniqueWithoutUsers_supplychainrecord_toentityidTousersInput>
    updateMany?: Enumerable<SupplyChainRecordUpdateManyWithWhereWithoutUsers_supplychainrecord_toentityidTousersInput>
    deleteMany?: Enumerable<SupplyChainRecordScalarWhereInput>
  }

  export type RoleUpdateOneWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    disconnect?: boolean
    delete?: boolean
    connect?: RoleWhereUniqueInput
    update?: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ActivityLogUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<ActivityLogCreateWithoutUsersInput>, Enumerable<ActivityLogUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<ActivityLogCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<ActivityLogUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: ActivityLogCreateManyUsersInputEnvelope
    set?: Enumerable<ActivityLogWhereUniqueInput>
    disconnect?: Enumerable<ActivityLogWhereUniqueInput>
    delete?: Enumerable<ActivityLogWhereUniqueInput>
    connect?: Enumerable<ActivityLogWhereUniqueInput>
    update?: Enumerable<ActivityLogUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<ActivityLogUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<ActivityLogScalarWhereInput>
  }

  export type AdminUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<AdminCreateWithoutUsersInput, AdminUncheckedCreateWithoutUsersInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUsersInput
    upsert?: AdminUpsertWithoutUsersInput
    disconnect?: boolean
    delete?: boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<AdminUpdateWithoutUsersInput, AdminUncheckedUpdateWithoutUsersInput>
  }

  export type AlertUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<AlertCreateWithoutUsersInput>, Enumerable<AlertUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<AlertCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<AlertUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: AlertCreateManyUsersInputEnvelope
    set?: Enumerable<AlertWhereUniqueInput>
    disconnect?: Enumerable<AlertWhereUniqueInput>
    delete?: Enumerable<AlertWhereUniqueInput>
    connect?: Enumerable<AlertWhereUniqueInput>
    update?: Enumerable<AlertUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<AlertUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<AlertScalarWhereInput>
  }

  export type DistributorUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<DistributorCreateWithoutUsersInput, DistributorUncheckedCreateWithoutUsersInput>
    connectOrCreate?: DistributorCreateOrConnectWithoutUsersInput
    upsert?: DistributorUpsertWithoutUsersInput
    disconnect?: boolean
    delete?: boolean
    connect?: DistributorWhereUniqueInput
    update?: XOR<DistributorUpdateWithoutUsersInput, DistributorUncheckedUpdateWithoutUsersInput>
  }

  export type DoctorUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<DoctorCreateWithoutUsersInput, DoctorUncheckedCreateWithoutUsersInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutUsersInput
    upsert?: DoctorUpsertWithoutUsersInput
    disconnect?: boolean
    delete?: boolean
    connect?: DoctorWhereUniqueInput
    update?: XOR<DoctorUpdateWithoutUsersInput, DoctorUncheckedUpdateWithoutUsersInput>
  }

  export type ManufacturerUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<ManufacturerCreateWithoutUsersInput, ManufacturerUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ManufacturerCreateOrConnectWithoutUsersInput
    upsert?: ManufacturerUpsertWithoutUsersInput
    disconnect?: boolean
    delete?: boolean
    connect?: ManufacturerWhereUniqueInput
    update?: XOR<ManufacturerUpdateWithoutUsersInput, ManufacturerUncheckedUpdateWithoutUsersInput>
  }

  export type OtpUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<OtpCreateWithoutUsersInput>, Enumerable<OtpUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<OtpCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<OtpUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: OtpCreateManyUsersInputEnvelope
    set?: Enumerable<OtpWhereUniqueInput>
    disconnect?: Enumerable<OtpWhereUniqueInput>
    delete?: Enumerable<OtpWhereUniqueInput>
    connect?: Enumerable<OtpWhereUniqueInput>
    update?: Enumerable<OtpUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<OtpUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<OtpScalarWhereInput>
  }

  export type PatientUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<PatientCreateWithoutUsersInput, PatientUncheckedCreateWithoutUsersInput>
    connectOrCreate?: PatientCreateOrConnectWithoutUsersInput
    upsert?: PatientUpsertWithoutUsersInput
    disconnect?: boolean
    delete?: boolean
    connect?: PatientWhereUniqueInput
    update?: XOR<PatientUpdateWithoutUsersInput, PatientUncheckedUpdateWithoutUsersInput>
  }

  export type PharmacistUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<PharmacistCreateWithoutUsersInput, PharmacistUncheckedCreateWithoutUsersInput>
    connectOrCreate?: PharmacistCreateOrConnectWithoutUsersInput
    upsert?: PharmacistUpsertWithoutUsersInput
    disconnect?: boolean
    delete?: boolean
    connect?: PharmacistWhereUniqueInput
    update?: XOR<PharmacistUpdateWithoutUsersInput, PharmacistUncheckedUpdateWithoutUsersInput>
  }

  export type RegulatorUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<RegulatorCreateWithoutUsersInput, RegulatorUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RegulatorCreateOrConnectWithoutUsersInput
    upsert?: RegulatorUpsertWithoutUsersInput
    disconnect?: boolean
    delete?: boolean
    connect?: RegulatorWhereUniqueInput
    update?: XOR<RegulatorUpdateWithoutUsersInput, RegulatorUncheckedUpdateWithoutUsersInput>
  }

  export type ReportUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<ReportCreateWithoutUsersInput>, Enumerable<ReportUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<ReportCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<ReportUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: ReportCreateManyUsersInputEnvelope
    set?: Enumerable<ReportWhereUniqueInput>
    disconnect?: Enumerable<ReportWhereUniqueInput>
    delete?: Enumerable<ReportWhereUniqueInput>
    connect?: Enumerable<ReportWhereUniqueInput>
    update?: Enumerable<ReportUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<ReportUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<ReportScalarWhereInput>
  }

  export type RevocationRecordUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<RevocationRecordCreateWithoutUsersInput>, Enumerable<RevocationRecordUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<RevocationRecordCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<RevocationRecordUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: RevocationRecordCreateManyUsersInputEnvelope
    set?: Enumerable<RevocationRecordWhereUniqueInput>
    disconnect?: Enumerable<RevocationRecordWhereUniqueInput>
    delete?: Enumerable<RevocationRecordWhereUniqueInput>
    connect?: Enumerable<RevocationRecordWhereUniqueInput>
    update?: Enumerable<RevocationRecordUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<RevocationRecordUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<RevocationRecordScalarWhereInput>
  }

  export type SupplyChainRecordUncheckedUpdateManyWithoutUsers_supplychainrecord_fromentityidTousersNestedInput = {
    create?: XOR<Enumerable<SupplyChainRecordCreateWithoutUsers_supplychainrecord_fromentityidTousersInput>, Enumerable<SupplyChainRecordUncheckedCreateWithoutUsers_supplychainrecord_fromentityidTousersInput>>
    connectOrCreate?: Enumerable<SupplyChainRecordCreateOrConnectWithoutUsers_supplychainrecord_fromentityidTousersInput>
    upsert?: Enumerable<SupplyChainRecordUpsertWithWhereUniqueWithoutUsers_supplychainrecord_fromentityidTousersInput>
    createMany?: SupplyChainRecordCreateManyUsers_supplychainrecord_fromentityidTousersInputEnvelope
    set?: Enumerable<SupplyChainRecordWhereUniqueInput>
    disconnect?: Enumerable<SupplyChainRecordWhereUniqueInput>
    delete?: Enumerable<SupplyChainRecordWhereUniqueInput>
    connect?: Enumerable<SupplyChainRecordWhereUniqueInput>
    update?: Enumerable<SupplyChainRecordUpdateWithWhereUniqueWithoutUsers_supplychainrecord_fromentityidTousersInput>
    updateMany?: Enumerable<SupplyChainRecordUpdateManyWithWhereWithoutUsers_supplychainrecord_fromentityidTousersInput>
    deleteMany?: Enumerable<SupplyChainRecordScalarWhereInput>
  }

  export type SupplyChainRecordUncheckedUpdateManyWithoutUsers_supplychainrecord_toentityidTousersNestedInput = {
    create?: XOR<Enumerable<SupplyChainRecordCreateWithoutUsers_supplychainrecord_toentityidTousersInput>, Enumerable<SupplyChainRecordUncheckedCreateWithoutUsers_supplychainrecord_toentityidTousersInput>>
    connectOrCreate?: Enumerable<SupplyChainRecordCreateOrConnectWithoutUsers_supplychainrecord_toentityidTousersInput>
    upsert?: Enumerable<SupplyChainRecordUpsertWithWhereUniqueWithoutUsers_supplychainrecord_toentityidTousersInput>
    createMany?: SupplyChainRecordCreateManyUsers_supplychainrecord_toentityidTousersInputEnvelope
    set?: Enumerable<SupplyChainRecordWhereUniqueInput>
    disconnect?: Enumerable<SupplyChainRecordWhereUniqueInput>
    delete?: Enumerable<SupplyChainRecordWhereUniqueInput>
    connect?: Enumerable<SupplyChainRecordWhereUniqueInput>
    update?: Enumerable<SupplyChainRecordUpdateWithWhereUniqueWithoutUsers_supplychainrecord_toentityidTousersInput>
    updateMany?: Enumerable<SupplyChainRecordUpdateManyWithWhereWithoutUsers_supplychainrecord_toentityidTousersInput>
    deleteMany?: Enumerable<SupplyChainRecordScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutDoctorInput = {
    create?: XOR<UserCreateWithoutDoctorInput, UserUncheckedCreateWithoutDoctorInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorInput
    connect?: UserWhereUniqueInput
  }

  export type PrescriptionCreateNestedManyWithoutDoctorInput = {
    create?: XOR<Enumerable<PrescriptionCreateWithoutDoctorInput>, Enumerable<PrescriptionUncheckedCreateWithoutDoctorInput>>
    connectOrCreate?: Enumerable<PrescriptionCreateOrConnectWithoutDoctorInput>
    createMany?: PrescriptionCreateManyDoctorInputEnvelope
    connect?: Enumerable<PrescriptionWhereUniqueInput>
  }

  export type PrescriptionUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<Enumerable<PrescriptionCreateWithoutDoctorInput>, Enumerable<PrescriptionUncheckedCreateWithoutDoctorInput>>
    connectOrCreate?: Enumerable<PrescriptionCreateOrConnectWithoutDoctorInput>
    createMany?: PrescriptionCreateManyDoctorInputEnvelope
    connect?: Enumerable<PrescriptionWhereUniqueInput>
  }

  export type UserUpdateOneWithoutDoctorNestedInput = {
    create?: XOR<UserCreateWithoutDoctorInput, UserUncheckedCreateWithoutDoctorInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorInput
    upsert?: UserUpsertWithoutDoctorInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutDoctorInput, UserUncheckedUpdateWithoutDoctorInput>
  }

  export type PrescriptionUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<Enumerable<PrescriptionCreateWithoutDoctorInput>, Enumerable<PrescriptionUncheckedCreateWithoutDoctorInput>>
    connectOrCreate?: Enumerable<PrescriptionCreateOrConnectWithoutDoctorInput>
    upsert?: Enumerable<PrescriptionUpsertWithWhereUniqueWithoutDoctorInput>
    createMany?: PrescriptionCreateManyDoctorInputEnvelope
    set?: Enumerable<PrescriptionWhereUniqueInput>
    disconnect?: Enumerable<PrescriptionWhereUniqueInput>
    delete?: Enumerable<PrescriptionWhereUniqueInput>
    connect?: Enumerable<PrescriptionWhereUniqueInput>
    update?: Enumerable<PrescriptionUpdateWithWhereUniqueWithoutDoctorInput>
    updateMany?: Enumerable<PrescriptionUpdateManyWithWhereWithoutDoctorInput>
    deleteMany?: Enumerable<PrescriptionScalarWhereInput>
  }

  export type PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<Enumerable<PrescriptionCreateWithoutDoctorInput>, Enumerable<PrescriptionUncheckedCreateWithoutDoctorInput>>
    connectOrCreate?: Enumerable<PrescriptionCreateOrConnectWithoutDoctorInput>
    upsert?: Enumerable<PrescriptionUpsertWithWhereUniqueWithoutDoctorInput>
    createMany?: PrescriptionCreateManyDoctorInputEnvelope
    set?: Enumerable<PrescriptionWhereUniqueInput>
    disconnect?: Enumerable<PrescriptionWhereUniqueInput>
    delete?: Enumerable<PrescriptionWhereUniqueInput>
    connect?: Enumerable<PrescriptionWhereUniqueInput>
    update?: Enumerable<PrescriptionUpdateWithWhereUniqueWithoutDoctorInput>
    updateMany?: Enumerable<PrescriptionUpdateManyWithWhereWithoutDoctorInput>
    deleteMany?: Enumerable<PrescriptionScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutPatientInput = {
    create?: XOR<UserCreateWithoutPatientInput, UserUncheckedCreateWithoutPatientInput>
    connectOrCreate?: UserCreateOrConnectWithoutPatientInput
    connect?: UserWhereUniqueInput
  }

  export type PrescriptionCreateNestedManyWithoutPatientInput = {
    create?: XOR<Enumerable<PrescriptionCreateWithoutPatientInput>, Enumerable<PrescriptionUncheckedCreateWithoutPatientInput>>
    connectOrCreate?: Enumerable<PrescriptionCreateOrConnectWithoutPatientInput>
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    connect?: Enumerable<PrescriptionWhereUniqueInput>
  }

  export type PrescriptionUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<Enumerable<PrescriptionCreateWithoutPatientInput>, Enumerable<PrescriptionUncheckedCreateWithoutPatientInput>>
    connectOrCreate?: Enumerable<PrescriptionCreateOrConnectWithoutPatientInput>
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    connect?: Enumerable<PrescriptionWhereUniqueInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneWithoutPatientNestedInput = {
    create?: XOR<UserCreateWithoutPatientInput, UserUncheckedCreateWithoutPatientInput>
    connectOrCreate?: UserCreateOrConnectWithoutPatientInput
    upsert?: UserUpsertWithoutPatientInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutPatientInput, UserUncheckedUpdateWithoutPatientInput>
  }

  export type PrescriptionUpdateManyWithoutPatientNestedInput = {
    create?: XOR<Enumerable<PrescriptionCreateWithoutPatientInput>, Enumerable<PrescriptionUncheckedCreateWithoutPatientInput>>
    connectOrCreate?: Enumerable<PrescriptionCreateOrConnectWithoutPatientInput>
    upsert?: Enumerable<PrescriptionUpsertWithWhereUniqueWithoutPatientInput>
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    set?: Enumerable<PrescriptionWhereUniqueInput>
    disconnect?: Enumerable<PrescriptionWhereUniqueInput>
    delete?: Enumerable<PrescriptionWhereUniqueInput>
    connect?: Enumerable<PrescriptionWhereUniqueInput>
    update?: Enumerable<PrescriptionUpdateWithWhereUniqueWithoutPatientInput>
    updateMany?: Enumerable<PrescriptionUpdateManyWithWhereWithoutPatientInput>
    deleteMany?: Enumerable<PrescriptionScalarWhereInput>
  }

  export type PrescriptionUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<Enumerable<PrescriptionCreateWithoutPatientInput>, Enumerable<PrescriptionUncheckedCreateWithoutPatientInput>>
    connectOrCreate?: Enumerable<PrescriptionCreateOrConnectWithoutPatientInput>
    upsert?: Enumerable<PrescriptionUpsertWithWhereUniqueWithoutPatientInput>
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    set?: Enumerable<PrescriptionWhereUniqueInput>
    disconnect?: Enumerable<PrescriptionWhereUniqueInput>
    delete?: Enumerable<PrescriptionWhereUniqueInput>
    connect?: Enumerable<PrescriptionWhereUniqueInput>
    update?: Enumerable<PrescriptionUpdateWithWhereUniqueWithoutPatientInput>
    updateMany?: Enumerable<PrescriptionUpdateManyWithWhereWithoutPatientInput>
    deleteMany?: Enumerable<PrescriptionScalarWhereInput>
  }

  export type DispenseRecordCreateNestedManyWithoutPharmacistInput = {
    create?: XOR<Enumerable<DispenseRecordCreateWithoutPharmacistInput>, Enumerable<DispenseRecordUncheckedCreateWithoutPharmacistInput>>
    connectOrCreate?: Enumerable<DispenseRecordCreateOrConnectWithoutPharmacistInput>
    createMany?: DispenseRecordCreateManyPharmacistInputEnvelope
    connect?: Enumerable<DispenseRecordWhereUniqueInput>
  }

  export type UserCreateNestedOneWithoutPharmacistInput = {
    create?: XOR<UserCreateWithoutPharmacistInput, UserUncheckedCreateWithoutPharmacistInput>
    connectOrCreate?: UserCreateOrConnectWithoutPharmacistInput
    connect?: UserWhereUniqueInput
  }

  export type DispenseRecordUncheckedCreateNestedManyWithoutPharmacistInput = {
    create?: XOR<Enumerable<DispenseRecordCreateWithoutPharmacistInput>, Enumerable<DispenseRecordUncheckedCreateWithoutPharmacistInput>>
    connectOrCreate?: Enumerable<DispenseRecordCreateOrConnectWithoutPharmacistInput>
    createMany?: DispenseRecordCreateManyPharmacistInputEnvelope
    connect?: Enumerable<DispenseRecordWhereUniqueInput>
  }

  export type DispenseRecordUpdateManyWithoutPharmacistNestedInput = {
    create?: XOR<Enumerable<DispenseRecordCreateWithoutPharmacistInput>, Enumerable<DispenseRecordUncheckedCreateWithoutPharmacistInput>>
    connectOrCreate?: Enumerable<DispenseRecordCreateOrConnectWithoutPharmacistInput>
    upsert?: Enumerable<DispenseRecordUpsertWithWhereUniqueWithoutPharmacistInput>
    createMany?: DispenseRecordCreateManyPharmacistInputEnvelope
    set?: Enumerable<DispenseRecordWhereUniqueInput>
    disconnect?: Enumerable<DispenseRecordWhereUniqueInput>
    delete?: Enumerable<DispenseRecordWhereUniqueInput>
    connect?: Enumerable<DispenseRecordWhereUniqueInput>
    update?: Enumerable<DispenseRecordUpdateWithWhereUniqueWithoutPharmacistInput>
    updateMany?: Enumerable<DispenseRecordUpdateManyWithWhereWithoutPharmacistInput>
    deleteMany?: Enumerable<DispenseRecordScalarWhereInput>
  }

  export type UserUpdateOneWithoutPharmacistNestedInput = {
    create?: XOR<UserCreateWithoutPharmacistInput, UserUncheckedCreateWithoutPharmacistInput>
    connectOrCreate?: UserCreateOrConnectWithoutPharmacistInput
    upsert?: UserUpsertWithoutPharmacistInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutPharmacistInput, UserUncheckedUpdateWithoutPharmacistInput>
  }

  export type DispenseRecordUncheckedUpdateManyWithoutPharmacistNestedInput = {
    create?: XOR<Enumerable<DispenseRecordCreateWithoutPharmacistInput>, Enumerable<DispenseRecordUncheckedCreateWithoutPharmacistInput>>
    connectOrCreate?: Enumerable<DispenseRecordCreateOrConnectWithoutPharmacistInput>
    upsert?: Enumerable<DispenseRecordUpsertWithWhereUniqueWithoutPharmacistInput>
    createMany?: DispenseRecordCreateManyPharmacistInputEnvelope
    set?: Enumerable<DispenseRecordWhereUniqueInput>
    disconnect?: Enumerable<DispenseRecordWhereUniqueInput>
    delete?: Enumerable<DispenseRecordWhereUniqueInput>
    connect?: Enumerable<DispenseRecordWhereUniqueInput>
    update?: Enumerable<DispenseRecordUpdateWithWhereUniqueWithoutPharmacistInput>
    updateMany?: Enumerable<DispenseRecordUpdateManyWithWhereWithoutPharmacistInput>
    deleteMany?: Enumerable<DispenseRecordScalarWhereInput>
  }

  export type DrugBatchCreateNestedManyWithoutManufacturerInput = {
    create?: XOR<Enumerable<DrugBatchCreateWithoutManufacturerInput>, Enumerable<DrugBatchUncheckedCreateWithoutManufacturerInput>>
    connectOrCreate?: Enumerable<DrugBatchCreateOrConnectWithoutManufacturerInput>
    createMany?: DrugBatchCreateManyManufacturerInputEnvelope
    connect?: Enumerable<DrugBatchWhereUniqueInput>
  }

  export type UserCreateNestedOneWithoutManufacturerInput = {
    create?: XOR<UserCreateWithoutManufacturerInput, UserUncheckedCreateWithoutManufacturerInput>
    connectOrCreate?: UserCreateOrConnectWithoutManufacturerInput
    connect?: UserWhereUniqueInput
  }

  export type DrugBatchUncheckedCreateNestedManyWithoutManufacturerInput = {
    create?: XOR<Enumerable<DrugBatchCreateWithoutManufacturerInput>, Enumerable<DrugBatchUncheckedCreateWithoutManufacturerInput>>
    connectOrCreate?: Enumerable<DrugBatchCreateOrConnectWithoutManufacturerInput>
    createMany?: DrugBatchCreateManyManufacturerInputEnvelope
    connect?: Enumerable<DrugBatchWhereUniqueInput>
  }

  export type DrugBatchUpdateManyWithoutManufacturerNestedInput = {
    create?: XOR<Enumerable<DrugBatchCreateWithoutManufacturerInput>, Enumerable<DrugBatchUncheckedCreateWithoutManufacturerInput>>
    connectOrCreate?: Enumerable<DrugBatchCreateOrConnectWithoutManufacturerInput>
    upsert?: Enumerable<DrugBatchUpsertWithWhereUniqueWithoutManufacturerInput>
    createMany?: DrugBatchCreateManyManufacturerInputEnvelope
    set?: Enumerable<DrugBatchWhereUniqueInput>
    disconnect?: Enumerable<DrugBatchWhereUniqueInput>
    delete?: Enumerable<DrugBatchWhereUniqueInput>
    connect?: Enumerable<DrugBatchWhereUniqueInput>
    update?: Enumerable<DrugBatchUpdateWithWhereUniqueWithoutManufacturerInput>
    updateMany?: Enumerable<DrugBatchUpdateManyWithWhereWithoutManufacturerInput>
    deleteMany?: Enumerable<DrugBatchScalarWhereInput>
  }

  export type UserUpdateOneWithoutManufacturerNestedInput = {
    create?: XOR<UserCreateWithoutManufacturerInput, UserUncheckedCreateWithoutManufacturerInput>
    connectOrCreate?: UserCreateOrConnectWithoutManufacturerInput
    upsert?: UserUpsertWithoutManufacturerInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutManufacturerInput, UserUncheckedUpdateWithoutManufacturerInput>
  }

  export type DrugBatchUncheckedUpdateManyWithoutManufacturerNestedInput = {
    create?: XOR<Enumerable<DrugBatchCreateWithoutManufacturerInput>, Enumerable<DrugBatchUncheckedCreateWithoutManufacturerInput>>
    connectOrCreate?: Enumerable<DrugBatchCreateOrConnectWithoutManufacturerInput>
    upsert?: Enumerable<DrugBatchUpsertWithWhereUniqueWithoutManufacturerInput>
    createMany?: DrugBatchCreateManyManufacturerInputEnvelope
    set?: Enumerable<DrugBatchWhereUniqueInput>
    disconnect?: Enumerable<DrugBatchWhereUniqueInput>
    delete?: Enumerable<DrugBatchWhereUniqueInput>
    connect?: Enumerable<DrugBatchWhereUniqueInput>
    update?: Enumerable<DrugBatchUpdateWithWhereUniqueWithoutManufacturerInput>
    updateMany?: Enumerable<DrugBatchUpdateManyWithWhereWithoutManufacturerInput>
    deleteMany?: Enumerable<DrugBatchScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutDistributorInput = {
    create?: XOR<UserCreateWithoutDistributorInput, UserUncheckedCreateWithoutDistributorInput>
    connectOrCreate?: UserCreateOrConnectWithoutDistributorInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutDistributorNestedInput = {
    create?: XOR<UserCreateWithoutDistributorInput, UserUncheckedCreateWithoutDistributorInput>
    connectOrCreate?: UserCreateOrConnectWithoutDistributorInput
    upsert?: UserUpsertWithoutDistributorInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutDistributorInput, UserUncheckedUpdateWithoutDistributorInput>
  }

  export type UserCreateNestedOneWithoutRegulatorInput = {
    create?: XOR<UserCreateWithoutRegulatorInput, UserUncheckedCreateWithoutRegulatorInput>
    connectOrCreate?: UserCreateOrConnectWithoutRegulatorInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutRegulatorNestedInput = {
    create?: XOR<UserCreateWithoutRegulatorInput, UserUncheckedCreateWithoutRegulatorInput>
    connectOrCreate?: UserCreateOrConnectWithoutRegulatorInput
    upsert?: UserUpsertWithoutRegulatorInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutRegulatorInput, UserUncheckedUpdateWithoutRegulatorInput>
  }

  export type UserCreateNestedOneWithoutAdminInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAdminNestedInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    upsert?: UserUpsertWithoutAdminInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
  }

  export type DrugBatchCreateNestedManyWithoutDrugInput = {
    create?: XOR<Enumerable<DrugBatchCreateWithoutDrugInput>, Enumerable<DrugBatchUncheckedCreateWithoutDrugInput>>
    connectOrCreate?: Enumerable<DrugBatchCreateOrConnectWithoutDrugInput>
    createMany?: DrugBatchCreateManyDrugInputEnvelope
    connect?: Enumerable<DrugBatchWhereUniqueInput>
  }

  export type PrescriptionCreateNestedManyWithoutDrugInput = {
    create?: XOR<Enumerable<PrescriptionCreateWithoutDrugInput>, Enumerable<PrescriptionUncheckedCreateWithoutDrugInput>>
    connectOrCreate?: Enumerable<PrescriptionCreateOrConnectWithoutDrugInput>
    createMany?: PrescriptionCreateManyDrugInputEnvelope
    connect?: Enumerable<PrescriptionWhereUniqueInput>
  }

  export type DrugBatchUncheckedCreateNestedManyWithoutDrugInput = {
    create?: XOR<Enumerable<DrugBatchCreateWithoutDrugInput>, Enumerable<DrugBatchUncheckedCreateWithoutDrugInput>>
    connectOrCreate?: Enumerable<DrugBatchCreateOrConnectWithoutDrugInput>
    createMany?: DrugBatchCreateManyDrugInputEnvelope
    connect?: Enumerable<DrugBatchWhereUniqueInput>
  }

  export type PrescriptionUncheckedCreateNestedManyWithoutDrugInput = {
    create?: XOR<Enumerable<PrescriptionCreateWithoutDrugInput>, Enumerable<PrescriptionUncheckedCreateWithoutDrugInput>>
    connectOrCreate?: Enumerable<PrescriptionCreateOrConnectWithoutDrugInput>
    createMany?: PrescriptionCreateManyDrugInputEnvelope
    connect?: Enumerable<PrescriptionWhereUniqueInput>
  }

  export type DrugBatchUpdateManyWithoutDrugNestedInput = {
    create?: XOR<Enumerable<DrugBatchCreateWithoutDrugInput>, Enumerable<DrugBatchUncheckedCreateWithoutDrugInput>>
    connectOrCreate?: Enumerable<DrugBatchCreateOrConnectWithoutDrugInput>
    upsert?: Enumerable<DrugBatchUpsertWithWhereUniqueWithoutDrugInput>
    createMany?: DrugBatchCreateManyDrugInputEnvelope
    set?: Enumerable<DrugBatchWhereUniqueInput>
    disconnect?: Enumerable<DrugBatchWhereUniqueInput>
    delete?: Enumerable<DrugBatchWhereUniqueInput>
    connect?: Enumerable<DrugBatchWhereUniqueInput>
    update?: Enumerable<DrugBatchUpdateWithWhereUniqueWithoutDrugInput>
    updateMany?: Enumerable<DrugBatchUpdateManyWithWhereWithoutDrugInput>
    deleteMany?: Enumerable<DrugBatchScalarWhereInput>
  }

  export type PrescriptionUpdateManyWithoutDrugNestedInput = {
    create?: XOR<Enumerable<PrescriptionCreateWithoutDrugInput>, Enumerable<PrescriptionUncheckedCreateWithoutDrugInput>>
    connectOrCreate?: Enumerable<PrescriptionCreateOrConnectWithoutDrugInput>
    upsert?: Enumerable<PrescriptionUpsertWithWhereUniqueWithoutDrugInput>
    createMany?: PrescriptionCreateManyDrugInputEnvelope
    set?: Enumerable<PrescriptionWhereUniqueInput>
    disconnect?: Enumerable<PrescriptionWhereUniqueInput>
    delete?: Enumerable<PrescriptionWhereUniqueInput>
    connect?: Enumerable<PrescriptionWhereUniqueInput>
    update?: Enumerable<PrescriptionUpdateWithWhereUniqueWithoutDrugInput>
    updateMany?: Enumerable<PrescriptionUpdateManyWithWhereWithoutDrugInput>
    deleteMany?: Enumerable<PrescriptionScalarWhereInput>
  }

  export type DrugBatchUncheckedUpdateManyWithoutDrugNestedInput = {
    create?: XOR<Enumerable<DrugBatchCreateWithoutDrugInput>, Enumerable<DrugBatchUncheckedCreateWithoutDrugInput>>
    connectOrCreate?: Enumerable<DrugBatchCreateOrConnectWithoutDrugInput>
    upsert?: Enumerable<DrugBatchUpsertWithWhereUniqueWithoutDrugInput>
    createMany?: DrugBatchCreateManyDrugInputEnvelope
    set?: Enumerable<DrugBatchWhereUniqueInput>
    disconnect?: Enumerable<DrugBatchWhereUniqueInput>
    delete?: Enumerable<DrugBatchWhereUniqueInput>
    connect?: Enumerable<DrugBatchWhereUniqueInput>
    update?: Enumerable<DrugBatchUpdateWithWhereUniqueWithoutDrugInput>
    updateMany?: Enumerable<DrugBatchUpdateManyWithWhereWithoutDrugInput>
    deleteMany?: Enumerable<DrugBatchScalarWhereInput>
  }

  export type PrescriptionUncheckedUpdateManyWithoutDrugNestedInput = {
    create?: XOR<Enumerable<PrescriptionCreateWithoutDrugInput>, Enumerable<PrescriptionUncheckedCreateWithoutDrugInput>>
    connectOrCreate?: Enumerable<PrescriptionCreateOrConnectWithoutDrugInput>
    upsert?: Enumerable<PrescriptionUpsertWithWhereUniqueWithoutDrugInput>
    createMany?: PrescriptionCreateManyDrugInputEnvelope
    set?: Enumerable<PrescriptionWhereUniqueInput>
    disconnect?: Enumerable<PrescriptionWhereUniqueInput>
    delete?: Enumerable<PrescriptionWhereUniqueInput>
    connect?: Enumerable<PrescriptionWhereUniqueInput>
    update?: Enumerable<PrescriptionUpdateWithWhereUniqueWithoutDrugInput>
    updateMany?: Enumerable<PrescriptionUpdateManyWithWhereWithoutDrugInput>
    deleteMany?: Enumerable<PrescriptionScalarWhereInput>
  }

  export type BlockchainEventLogCreateNestedManyWithoutPrescriptionInput = {
    create?: XOR<Enumerable<BlockchainEventLogCreateWithoutPrescriptionInput>, Enumerable<BlockchainEventLogUncheckedCreateWithoutPrescriptionInput>>
    connectOrCreate?: Enumerable<BlockchainEventLogCreateOrConnectWithoutPrescriptionInput>
    createMany?: BlockchainEventLogCreateManyPrescriptionInputEnvelope
    connect?: Enumerable<BlockchainEventLogWhereUniqueInput>
  }

  export type DispenseRecordCreateNestedManyWithoutPrescriptionInput = {
    create?: XOR<Enumerable<DispenseRecordCreateWithoutPrescriptionInput>, Enumerable<DispenseRecordUncheckedCreateWithoutPrescriptionInput>>
    connectOrCreate?: Enumerable<DispenseRecordCreateOrConnectWithoutPrescriptionInput>
    createMany?: DispenseRecordCreateManyPrescriptionInputEnvelope
    connect?: Enumerable<DispenseRecordWhereUniqueInput>
  }

  export type DoctorCreateNestedOneWithoutPrescriptionInput = {
    create?: XOR<DoctorCreateWithoutPrescriptionInput, DoctorUncheckedCreateWithoutPrescriptionInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutPrescriptionInput
    connect?: DoctorWhereUniqueInput
  }

  export type DrugCreateNestedOneWithoutPrescriptionInput = {
    create?: XOR<DrugCreateWithoutPrescriptionInput, DrugUncheckedCreateWithoutPrescriptionInput>
    connectOrCreate?: DrugCreateOrConnectWithoutPrescriptionInput
    connect?: DrugWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutPrescriptionInput = {
    create?: XOR<PatientCreateWithoutPrescriptionInput, PatientUncheckedCreateWithoutPrescriptionInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPrescriptionInput
    connect?: PatientWhereUniqueInput
  }

  export type BlockchainEventLogUncheckedCreateNestedManyWithoutPrescriptionInput = {
    create?: XOR<Enumerable<BlockchainEventLogCreateWithoutPrescriptionInput>, Enumerable<BlockchainEventLogUncheckedCreateWithoutPrescriptionInput>>
    connectOrCreate?: Enumerable<BlockchainEventLogCreateOrConnectWithoutPrescriptionInput>
    createMany?: BlockchainEventLogCreateManyPrescriptionInputEnvelope
    connect?: Enumerable<BlockchainEventLogWhereUniqueInput>
  }

  export type DispenseRecordUncheckedCreateNestedManyWithoutPrescriptionInput = {
    create?: XOR<Enumerable<DispenseRecordCreateWithoutPrescriptionInput>, Enumerable<DispenseRecordUncheckedCreateWithoutPrescriptionInput>>
    connectOrCreate?: Enumerable<DispenseRecordCreateOrConnectWithoutPrescriptionInput>
    createMany?: DispenseRecordCreateManyPrescriptionInputEnvelope
    connect?: Enumerable<DispenseRecordWhereUniqueInput>
  }

  export type BlockchainEventLogUpdateManyWithoutPrescriptionNestedInput = {
    create?: XOR<Enumerable<BlockchainEventLogCreateWithoutPrescriptionInput>, Enumerable<BlockchainEventLogUncheckedCreateWithoutPrescriptionInput>>
    connectOrCreate?: Enumerable<BlockchainEventLogCreateOrConnectWithoutPrescriptionInput>
    upsert?: Enumerable<BlockchainEventLogUpsertWithWhereUniqueWithoutPrescriptionInput>
    createMany?: BlockchainEventLogCreateManyPrescriptionInputEnvelope
    set?: Enumerable<BlockchainEventLogWhereUniqueInput>
    disconnect?: Enumerable<BlockchainEventLogWhereUniqueInput>
    delete?: Enumerable<BlockchainEventLogWhereUniqueInput>
    connect?: Enumerable<BlockchainEventLogWhereUniqueInput>
    update?: Enumerable<BlockchainEventLogUpdateWithWhereUniqueWithoutPrescriptionInput>
    updateMany?: Enumerable<BlockchainEventLogUpdateManyWithWhereWithoutPrescriptionInput>
    deleteMany?: Enumerable<BlockchainEventLogScalarWhereInput>
  }

  export type DispenseRecordUpdateManyWithoutPrescriptionNestedInput = {
    create?: XOR<Enumerable<DispenseRecordCreateWithoutPrescriptionInput>, Enumerable<DispenseRecordUncheckedCreateWithoutPrescriptionInput>>
    connectOrCreate?: Enumerable<DispenseRecordCreateOrConnectWithoutPrescriptionInput>
    upsert?: Enumerable<DispenseRecordUpsertWithWhereUniqueWithoutPrescriptionInput>
    createMany?: DispenseRecordCreateManyPrescriptionInputEnvelope
    set?: Enumerable<DispenseRecordWhereUniqueInput>
    disconnect?: Enumerable<DispenseRecordWhereUniqueInput>
    delete?: Enumerable<DispenseRecordWhereUniqueInput>
    connect?: Enumerable<DispenseRecordWhereUniqueInput>
    update?: Enumerable<DispenseRecordUpdateWithWhereUniqueWithoutPrescriptionInput>
    updateMany?: Enumerable<DispenseRecordUpdateManyWithWhereWithoutPrescriptionInput>
    deleteMany?: Enumerable<DispenseRecordScalarWhereInput>
  }

  export type DoctorUpdateOneWithoutPrescriptionNestedInput = {
    create?: XOR<DoctorCreateWithoutPrescriptionInput, DoctorUncheckedCreateWithoutPrescriptionInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutPrescriptionInput
    upsert?: DoctorUpsertWithoutPrescriptionInput
    disconnect?: boolean
    delete?: boolean
    connect?: DoctorWhereUniqueInput
    update?: XOR<DoctorUpdateWithoutPrescriptionInput, DoctorUncheckedUpdateWithoutPrescriptionInput>
  }

  export type DrugUpdateOneWithoutPrescriptionNestedInput = {
    create?: XOR<DrugCreateWithoutPrescriptionInput, DrugUncheckedCreateWithoutPrescriptionInput>
    connectOrCreate?: DrugCreateOrConnectWithoutPrescriptionInput
    upsert?: DrugUpsertWithoutPrescriptionInput
    disconnect?: boolean
    delete?: boolean
    connect?: DrugWhereUniqueInput
    update?: XOR<DrugUpdateWithoutPrescriptionInput, DrugUncheckedUpdateWithoutPrescriptionInput>
  }

  export type PatientUpdateOneWithoutPrescriptionNestedInput = {
    create?: XOR<PatientCreateWithoutPrescriptionInput, PatientUncheckedCreateWithoutPrescriptionInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPrescriptionInput
    upsert?: PatientUpsertWithoutPrescriptionInput
    disconnect?: boolean
    delete?: boolean
    connect?: PatientWhereUniqueInput
    update?: XOR<PatientUpdateWithoutPrescriptionInput, PatientUncheckedUpdateWithoutPrescriptionInput>
  }

  export type BlockchainEventLogUncheckedUpdateManyWithoutPrescriptionNestedInput = {
    create?: XOR<Enumerable<BlockchainEventLogCreateWithoutPrescriptionInput>, Enumerable<BlockchainEventLogUncheckedCreateWithoutPrescriptionInput>>
    connectOrCreate?: Enumerable<BlockchainEventLogCreateOrConnectWithoutPrescriptionInput>
    upsert?: Enumerable<BlockchainEventLogUpsertWithWhereUniqueWithoutPrescriptionInput>
    createMany?: BlockchainEventLogCreateManyPrescriptionInputEnvelope
    set?: Enumerable<BlockchainEventLogWhereUniqueInput>
    disconnect?: Enumerable<BlockchainEventLogWhereUniqueInput>
    delete?: Enumerable<BlockchainEventLogWhereUniqueInput>
    connect?: Enumerable<BlockchainEventLogWhereUniqueInput>
    update?: Enumerable<BlockchainEventLogUpdateWithWhereUniqueWithoutPrescriptionInput>
    updateMany?: Enumerable<BlockchainEventLogUpdateManyWithWhereWithoutPrescriptionInput>
    deleteMany?: Enumerable<BlockchainEventLogScalarWhereInput>
  }

  export type DispenseRecordUncheckedUpdateManyWithoutPrescriptionNestedInput = {
    create?: XOR<Enumerable<DispenseRecordCreateWithoutPrescriptionInput>, Enumerable<DispenseRecordUncheckedCreateWithoutPrescriptionInput>>
    connectOrCreate?: Enumerable<DispenseRecordCreateOrConnectWithoutPrescriptionInput>
    upsert?: Enumerable<DispenseRecordUpsertWithWhereUniqueWithoutPrescriptionInput>
    createMany?: DispenseRecordCreateManyPrescriptionInputEnvelope
    set?: Enumerable<DispenseRecordWhereUniqueInput>
    disconnect?: Enumerable<DispenseRecordWhereUniqueInput>
    delete?: Enumerable<DispenseRecordWhereUniqueInput>
    connect?: Enumerable<DispenseRecordWhereUniqueInput>
    update?: Enumerable<DispenseRecordUpdateWithWhereUniqueWithoutPrescriptionInput>
    updateMany?: Enumerable<DispenseRecordUpdateManyWithWhereWithoutPrescriptionInput>
    deleteMany?: Enumerable<DispenseRecordScalarWhereInput>
  }

  export type BlockchainEventLogCreateNestedManyWithoutDrugbatchInput = {
    create?: XOR<Enumerable<BlockchainEventLogCreateWithoutDrugbatchInput>, Enumerable<BlockchainEventLogUncheckedCreateWithoutDrugbatchInput>>
    connectOrCreate?: Enumerable<BlockchainEventLogCreateOrConnectWithoutDrugbatchInput>
    createMany?: BlockchainEventLogCreateManyDrugbatchInputEnvelope
    connect?: Enumerable<BlockchainEventLogWhereUniqueInput>
  }

  export type DispenseRecordCreateNestedManyWithoutDrugbatchInput = {
    create?: XOR<Enumerable<DispenseRecordCreateWithoutDrugbatchInput>, Enumerable<DispenseRecordUncheckedCreateWithoutDrugbatchInput>>
    connectOrCreate?: Enumerable<DispenseRecordCreateOrConnectWithoutDrugbatchInput>
    createMany?: DispenseRecordCreateManyDrugbatchInputEnvelope
    connect?: Enumerable<DispenseRecordWhereUniqueInput>
  }

  export type DrugCreateNestedOneWithoutDrugbatchInput = {
    create?: XOR<DrugCreateWithoutDrugbatchInput, DrugUncheckedCreateWithoutDrugbatchInput>
    connectOrCreate?: DrugCreateOrConnectWithoutDrugbatchInput
    connect?: DrugWhereUniqueInput
  }

  export type ManufacturerCreateNestedOneWithoutDrugbatchInput = {
    create?: XOR<ManufacturerCreateWithoutDrugbatchInput, ManufacturerUncheckedCreateWithoutDrugbatchInput>
    connectOrCreate?: ManufacturerCreateOrConnectWithoutDrugbatchInput
    connect?: ManufacturerWhereUniqueInput
  }

  export type SupplyChainRecordCreateNestedManyWithoutDrugbatchInput = {
    create?: XOR<Enumerable<SupplyChainRecordCreateWithoutDrugbatchInput>, Enumerable<SupplyChainRecordUncheckedCreateWithoutDrugbatchInput>>
    connectOrCreate?: Enumerable<SupplyChainRecordCreateOrConnectWithoutDrugbatchInput>
    createMany?: SupplyChainRecordCreateManyDrugbatchInputEnvelope
    connect?: Enumerable<SupplyChainRecordWhereUniqueInput>
  }

  export type BlockchainEventLogUncheckedCreateNestedManyWithoutDrugbatchInput = {
    create?: XOR<Enumerable<BlockchainEventLogCreateWithoutDrugbatchInput>, Enumerable<BlockchainEventLogUncheckedCreateWithoutDrugbatchInput>>
    connectOrCreate?: Enumerable<BlockchainEventLogCreateOrConnectWithoutDrugbatchInput>
    createMany?: BlockchainEventLogCreateManyDrugbatchInputEnvelope
    connect?: Enumerable<BlockchainEventLogWhereUniqueInput>
  }

  export type DispenseRecordUncheckedCreateNestedManyWithoutDrugbatchInput = {
    create?: XOR<Enumerable<DispenseRecordCreateWithoutDrugbatchInput>, Enumerable<DispenseRecordUncheckedCreateWithoutDrugbatchInput>>
    connectOrCreate?: Enumerable<DispenseRecordCreateOrConnectWithoutDrugbatchInput>
    createMany?: DispenseRecordCreateManyDrugbatchInputEnvelope
    connect?: Enumerable<DispenseRecordWhereUniqueInput>
  }

  export type SupplyChainRecordUncheckedCreateNestedManyWithoutDrugbatchInput = {
    create?: XOR<Enumerable<SupplyChainRecordCreateWithoutDrugbatchInput>, Enumerable<SupplyChainRecordUncheckedCreateWithoutDrugbatchInput>>
    connectOrCreate?: Enumerable<SupplyChainRecordCreateOrConnectWithoutDrugbatchInput>
    createMany?: SupplyChainRecordCreateManyDrugbatchInputEnvelope
    connect?: Enumerable<SupplyChainRecordWhereUniqueInput>
  }

  export type BlockchainEventLogUpdateManyWithoutDrugbatchNestedInput = {
    create?: XOR<Enumerable<BlockchainEventLogCreateWithoutDrugbatchInput>, Enumerable<BlockchainEventLogUncheckedCreateWithoutDrugbatchInput>>
    connectOrCreate?: Enumerable<BlockchainEventLogCreateOrConnectWithoutDrugbatchInput>
    upsert?: Enumerable<BlockchainEventLogUpsertWithWhereUniqueWithoutDrugbatchInput>
    createMany?: BlockchainEventLogCreateManyDrugbatchInputEnvelope
    set?: Enumerable<BlockchainEventLogWhereUniqueInput>
    disconnect?: Enumerable<BlockchainEventLogWhereUniqueInput>
    delete?: Enumerable<BlockchainEventLogWhereUniqueInput>
    connect?: Enumerable<BlockchainEventLogWhereUniqueInput>
    update?: Enumerable<BlockchainEventLogUpdateWithWhereUniqueWithoutDrugbatchInput>
    updateMany?: Enumerable<BlockchainEventLogUpdateManyWithWhereWithoutDrugbatchInput>
    deleteMany?: Enumerable<BlockchainEventLogScalarWhereInput>
  }

  export type DispenseRecordUpdateManyWithoutDrugbatchNestedInput = {
    create?: XOR<Enumerable<DispenseRecordCreateWithoutDrugbatchInput>, Enumerable<DispenseRecordUncheckedCreateWithoutDrugbatchInput>>
    connectOrCreate?: Enumerable<DispenseRecordCreateOrConnectWithoutDrugbatchInput>
    upsert?: Enumerable<DispenseRecordUpsertWithWhereUniqueWithoutDrugbatchInput>
    createMany?: DispenseRecordCreateManyDrugbatchInputEnvelope
    set?: Enumerable<DispenseRecordWhereUniqueInput>
    disconnect?: Enumerable<DispenseRecordWhereUniqueInput>
    delete?: Enumerable<DispenseRecordWhereUniqueInput>
    connect?: Enumerable<DispenseRecordWhereUniqueInput>
    update?: Enumerable<DispenseRecordUpdateWithWhereUniqueWithoutDrugbatchInput>
    updateMany?: Enumerable<DispenseRecordUpdateManyWithWhereWithoutDrugbatchInput>
    deleteMany?: Enumerable<DispenseRecordScalarWhereInput>
  }

  export type DrugUpdateOneWithoutDrugbatchNestedInput = {
    create?: XOR<DrugCreateWithoutDrugbatchInput, DrugUncheckedCreateWithoutDrugbatchInput>
    connectOrCreate?: DrugCreateOrConnectWithoutDrugbatchInput
    upsert?: DrugUpsertWithoutDrugbatchInput
    disconnect?: boolean
    delete?: boolean
    connect?: DrugWhereUniqueInput
    update?: XOR<DrugUpdateWithoutDrugbatchInput, DrugUncheckedUpdateWithoutDrugbatchInput>
  }

  export type ManufacturerUpdateOneWithoutDrugbatchNestedInput = {
    create?: XOR<ManufacturerCreateWithoutDrugbatchInput, ManufacturerUncheckedCreateWithoutDrugbatchInput>
    connectOrCreate?: ManufacturerCreateOrConnectWithoutDrugbatchInput
    upsert?: ManufacturerUpsertWithoutDrugbatchInput
    disconnect?: boolean
    delete?: boolean
    connect?: ManufacturerWhereUniqueInput
    update?: XOR<ManufacturerUpdateWithoutDrugbatchInput, ManufacturerUncheckedUpdateWithoutDrugbatchInput>
  }

  export type SupplyChainRecordUpdateManyWithoutDrugbatchNestedInput = {
    create?: XOR<Enumerable<SupplyChainRecordCreateWithoutDrugbatchInput>, Enumerable<SupplyChainRecordUncheckedCreateWithoutDrugbatchInput>>
    connectOrCreate?: Enumerable<SupplyChainRecordCreateOrConnectWithoutDrugbatchInput>
    upsert?: Enumerable<SupplyChainRecordUpsertWithWhereUniqueWithoutDrugbatchInput>
    createMany?: SupplyChainRecordCreateManyDrugbatchInputEnvelope
    set?: Enumerable<SupplyChainRecordWhereUniqueInput>
    disconnect?: Enumerable<SupplyChainRecordWhereUniqueInput>
    delete?: Enumerable<SupplyChainRecordWhereUniqueInput>
    connect?: Enumerable<SupplyChainRecordWhereUniqueInput>
    update?: Enumerable<SupplyChainRecordUpdateWithWhereUniqueWithoutDrugbatchInput>
    updateMany?: Enumerable<SupplyChainRecordUpdateManyWithWhereWithoutDrugbatchInput>
    deleteMany?: Enumerable<SupplyChainRecordScalarWhereInput>
  }

  export type BlockchainEventLogUncheckedUpdateManyWithoutDrugbatchNestedInput = {
    create?: XOR<Enumerable<BlockchainEventLogCreateWithoutDrugbatchInput>, Enumerable<BlockchainEventLogUncheckedCreateWithoutDrugbatchInput>>
    connectOrCreate?: Enumerable<BlockchainEventLogCreateOrConnectWithoutDrugbatchInput>
    upsert?: Enumerable<BlockchainEventLogUpsertWithWhereUniqueWithoutDrugbatchInput>
    createMany?: BlockchainEventLogCreateManyDrugbatchInputEnvelope
    set?: Enumerable<BlockchainEventLogWhereUniqueInput>
    disconnect?: Enumerable<BlockchainEventLogWhereUniqueInput>
    delete?: Enumerable<BlockchainEventLogWhereUniqueInput>
    connect?: Enumerable<BlockchainEventLogWhereUniqueInput>
    update?: Enumerable<BlockchainEventLogUpdateWithWhereUniqueWithoutDrugbatchInput>
    updateMany?: Enumerable<BlockchainEventLogUpdateManyWithWhereWithoutDrugbatchInput>
    deleteMany?: Enumerable<BlockchainEventLogScalarWhereInput>
  }

  export type DispenseRecordUncheckedUpdateManyWithoutDrugbatchNestedInput = {
    create?: XOR<Enumerable<DispenseRecordCreateWithoutDrugbatchInput>, Enumerable<DispenseRecordUncheckedCreateWithoutDrugbatchInput>>
    connectOrCreate?: Enumerable<DispenseRecordCreateOrConnectWithoutDrugbatchInput>
    upsert?: Enumerable<DispenseRecordUpsertWithWhereUniqueWithoutDrugbatchInput>
    createMany?: DispenseRecordCreateManyDrugbatchInputEnvelope
    set?: Enumerable<DispenseRecordWhereUniqueInput>
    disconnect?: Enumerable<DispenseRecordWhereUniqueInput>
    delete?: Enumerable<DispenseRecordWhereUniqueInput>
    connect?: Enumerable<DispenseRecordWhereUniqueInput>
    update?: Enumerable<DispenseRecordUpdateWithWhereUniqueWithoutDrugbatchInput>
    updateMany?: Enumerable<DispenseRecordUpdateManyWithWhereWithoutDrugbatchInput>
    deleteMany?: Enumerable<DispenseRecordScalarWhereInput>
  }

  export type SupplyChainRecordUncheckedUpdateManyWithoutDrugbatchNestedInput = {
    create?: XOR<Enumerable<SupplyChainRecordCreateWithoutDrugbatchInput>, Enumerable<SupplyChainRecordUncheckedCreateWithoutDrugbatchInput>>
    connectOrCreate?: Enumerable<SupplyChainRecordCreateOrConnectWithoutDrugbatchInput>
    upsert?: Enumerable<SupplyChainRecordUpsertWithWhereUniqueWithoutDrugbatchInput>
    createMany?: SupplyChainRecordCreateManyDrugbatchInputEnvelope
    set?: Enumerable<SupplyChainRecordWhereUniqueInput>
    disconnect?: Enumerable<SupplyChainRecordWhereUniqueInput>
    delete?: Enumerable<SupplyChainRecordWhereUniqueInput>
    connect?: Enumerable<SupplyChainRecordWhereUniqueInput>
    update?: Enumerable<SupplyChainRecordUpdateWithWhereUniqueWithoutDrugbatchInput>
    updateMany?: Enumerable<SupplyChainRecordUpdateManyWithWhereWithoutDrugbatchInput>
    deleteMany?: Enumerable<SupplyChainRecordScalarWhereInput>
  }

  export type BlockchainEventLogCreateNestedManyWithoutSupplychainrecordInput = {
    create?: XOR<Enumerable<BlockchainEventLogCreateWithoutSupplychainrecordInput>, Enumerable<BlockchainEventLogUncheckedCreateWithoutSupplychainrecordInput>>
    connectOrCreate?: Enumerable<BlockchainEventLogCreateOrConnectWithoutSupplychainrecordInput>
    createMany?: BlockchainEventLogCreateManySupplychainrecordInputEnvelope
    connect?: Enumerable<BlockchainEventLogWhereUniqueInput>
  }

  export type DrugBatchCreateNestedOneWithoutSupplychainrecordInput = {
    create?: XOR<DrugBatchCreateWithoutSupplychainrecordInput, DrugBatchUncheckedCreateWithoutSupplychainrecordInput>
    connectOrCreate?: DrugBatchCreateOrConnectWithoutSupplychainrecordInput
    connect?: DrugBatchWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSupplychainrecord_supplychainrecord_fromentityidTousersInput = {
    create?: XOR<UserCreateWithoutSupplychainrecord_supplychainrecord_fromentityidTousersInput, UserUncheckedCreateWithoutSupplychainrecord_supplychainrecord_fromentityidTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupplychainrecord_supplychainrecord_fromentityidTousersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSupplychainrecord_supplychainrecord_toentityidTousersInput = {
    create?: XOR<UserCreateWithoutSupplychainrecord_supplychainrecord_toentityidTousersInput, UserUncheckedCreateWithoutSupplychainrecord_supplychainrecord_toentityidTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupplychainrecord_supplychainrecord_toentityidTousersInput
    connect?: UserWhereUniqueInput
  }

  export type BlockchainEventLogUncheckedCreateNestedManyWithoutSupplychainrecordInput = {
    create?: XOR<Enumerable<BlockchainEventLogCreateWithoutSupplychainrecordInput>, Enumerable<BlockchainEventLogUncheckedCreateWithoutSupplychainrecordInput>>
    connectOrCreate?: Enumerable<BlockchainEventLogCreateOrConnectWithoutSupplychainrecordInput>
    createMany?: BlockchainEventLogCreateManySupplychainrecordInputEnvelope
    connect?: Enumerable<BlockchainEventLogWhereUniqueInput>
  }

  export type BlockchainEventLogUpdateManyWithoutSupplychainrecordNestedInput = {
    create?: XOR<Enumerable<BlockchainEventLogCreateWithoutSupplychainrecordInput>, Enumerable<BlockchainEventLogUncheckedCreateWithoutSupplychainrecordInput>>
    connectOrCreate?: Enumerable<BlockchainEventLogCreateOrConnectWithoutSupplychainrecordInput>
    upsert?: Enumerable<BlockchainEventLogUpsertWithWhereUniqueWithoutSupplychainrecordInput>
    createMany?: BlockchainEventLogCreateManySupplychainrecordInputEnvelope
    set?: Enumerable<BlockchainEventLogWhereUniqueInput>
    disconnect?: Enumerable<BlockchainEventLogWhereUniqueInput>
    delete?: Enumerable<BlockchainEventLogWhereUniqueInput>
    connect?: Enumerable<BlockchainEventLogWhereUniqueInput>
    update?: Enumerable<BlockchainEventLogUpdateWithWhereUniqueWithoutSupplychainrecordInput>
    updateMany?: Enumerable<BlockchainEventLogUpdateManyWithWhereWithoutSupplychainrecordInput>
    deleteMany?: Enumerable<BlockchainEventLogScalarWhereInput>
  }

  export type DrugBatchUpdateOneWithoutSupplychainrecordNestedInput = {
    create?: XOR<DrugBatchCreateWithoutSupplychainrecordInput, DrugBatchUncheckedCreateWithoutSupplychainrecordInput>
    connectOrCreate?: DrugBatchCreateOrConnectWithoutSupplychainrecordInput
    upsert?: DrugBatchUpsertWithoutSupplychainrecordInput
    disconnect?: boolean
    delete?: boolean
    connect?: DrugBatchWhereUniqueInput
    update?: XOR<DrugBatchUpdateWithoutSupplychainrecordInput, DrugBatchUncheckedUpdateWithoutSupplychainrecordInput>
  }

  export type UserUpdateOneWithoutSupplychainrecord_supplychainrecord_fromentityidTousersNestedInput = {
    create?: XOR<UserCreateWithoutSupplychainrecord_supplychainrecord_fromentityidTousersInput, UserUncheckedCreateWithoutSupplychainrecord_supplychainrecord_fromentityidTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupplychainrecord_supplychainrecord_fromentityidTousersInput
    upsert?: UserUpsertWithoutSupplychainrecord_supplychainrecord_fromentityidTousersInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSupplychainrecord_supplychainrecord_fromentityidTousersInput, UserUncheckedUpdateWithoutSupplychainrecord_supplychainrecord_fromentityidTousersInput>
  }

  export type UserUpdateOneWithoutSupplychainrecord_supplychainrecord_toentityidTousersNestedInput = {
    create?: XOR<UserCreateWithoutSupplychainrecord_supplychainrecord_toentityidTousersInput, UserUncheckedCreateWithoutSupplychainrecord_supplychainrecord_toentityidTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupplychainrecord_supplychainrecord_toentityidTousersInput
    upsert?: UserUpsertWithoutSupplychainrecord_supplychainrecord_toentityidTousersInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSupplychainrecord_supplychainrecord_toentityidTousersInput, UserUncheckedUpdateWithoutSupplychainrecord_supplychainrecord_toentityidTousersInput>
  }

  export type BlockchainEventLogUncheckedUpdateManyWithoutSupplychainrecordNestedInput = {
    create?: XOR<Enumerable<BlockchainEventLogCreateWithoutSupplychainrecordInput>, Enumerable<BlockchainEventLogUncheckedCreateWithoutSupplychainrecordInput>>
    connectOrCreate?: Enumerable<BlockchainEventLogCreateOrConnectWithoutSupplychainrecordInput>
    upsert?: Enumerable<BlockchainEventLogUpsertWithWhereUniqueWithoutSupplychainrecordInput>
    createMany?: BlockchainEventLogCreateManySupplychainrecordInputEnvelope
    set?: Enumerable<BlockchainEventLogWhereUniqueInput>
    disconnect?: Enumerable<BlockchainEventLogWhereUniqueInput>
    delete?: Enumerable<BlockchainEventLogWhereUniqueInput>
    connect?: Enumerable<BlockchainEventLogWhereUniqueInput>
    update?: Enumerable<BlockchainEventLogUpdateWithWhereUniqueWithoutSupplychainrecordInput>
    updateMany?: Enumerable<BlockchainEventLogUpdateManyWithWhereWithoutSupplychainrecordInput>
    deleteMany?: Enumerable<BlockchainEventLogScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutRevocationrecordInput = {
    create?: XOR<UserCreateWithoutRevocationrecordInput, UserUncheckedCreateWithoutRevocationrecordInput>
    connectOrCreate?: UserCreateOrConnectWithoutRevocationrecordInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutRevocationrecordNestedInput = {
    create?: XOR<UserCreateWithoutRevocationrecordInput, UserUncheckedCreateWithoutRevocationrecordInput>
    connectOrCreate?: UserCreateOrConnectWithoutRevocationrecordInput
    upsert?: UserUpsertWithoutRevocationrecordInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutRevocationrecordInput, UserUncheckedUpdateWithoutRevocationrecordInput>
  }

  export type UserCreateNestedOneWithoutOtpInput = {
    create?: XOR<UserCreateWithoutOtpInput, UserUncheckedCreateWithoutOtpInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtpInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutOtpNestedInput = {
    create?: XOR<UserCreateWithoutOtpInput, UserUncheckedCreateWithoutOtpInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtpInput
    upsert?: UserUpsertWithoutOtpInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutOtpInput, UserUncheckedUpdateWithoutOtpInput>
  }

  export type UserCreateNestedOneWithoutAlertInput = {
    create?: XOR<UserCreateWithoutAlertInput, UserUncheckedCreateWithoutAlertInput>
    connectOrCreate?: UserCreateOrConnectWithoutAlertInput
    connect?: UserWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type UserUpdateOneWithoutAlertNestedInput = {
    create?: XOR<UserCreateWithoutAlertInput, UserUncheckedCreateWithoutAlertInput>
    connectOrCreate?: UserCreateOrConnectWithoutAlertInput
    upsert?: UserUpsertWithoutAlertInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAlertInput, UserUncheckedUpdateWithoutAlertInput>
  }

  export type UserCreateNestedOneWithoutActivitylogInput = {
    create?: XOR<UserCreateWithoutActivitylogInput, UserUncheckedCreateWithoutActivitylogInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitylogInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutActivitylogNestedInput = {
    create?: XOR<UserCreateWithoutActivitylogInput, UserUncheckedCreateWithoutActivitylogInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitylogInput
    upsert?: UserUpsertWithoutActivitylogInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutActivitylogInput, UserUncheckedUpdateWithoutActivitylogInput>
  }

  export type UserCreateNestedOneWithoutReportsInput = {
    create?: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutReportsNestedInput = {
    create?: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsInput
    upsert?: UserUpsertWithoutReportsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutReportsInput, UserUncheckedUpdateWithoutReportsInput>
  }

  export type DrugBatchCreateNestedOneWithoutDispenserecordInput = {
    create?: XOR<DrugBatchCreateWithoutDispenserecordInput, DrugBatchUncheckedCreateWithoutDispenserecordInput>
    connectOrCreate?: DrugBatchCreateOrConnectWithoutDispenserecordInput
    connect?: DrugBatchWhereUniqueInput
  }

  export type PharmacistCreateNestedOneWithoutDispenserecordInput = {
    create?: XOR<PharmacistCreateWithoutDispenserecordInput, PharmacistUncheckedCreateWithoutDispenserecordInput>
    connectOrCreate?: PharmacistCreateOrConnectWithoutDispenserecordInput
    connect?: PharmacistWhereUniqueInput
  }

  export type PrescriptionCreateNestedOneWithoutDispenserecordInput = {
    create?: XOR<PrescriptionCreateWithoutDispenserecordInput, PrescriptionUncheckedCreateWithoutDispenserecordInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutDispenserecordInput
    connect?: PrescriptionWhereUniqueInput
  }

  export type DrugBatchUpdateOneWithoutDispenserecordNestedInput = {
    create?: XOR<DrugBatchCreateWithoutDispenserecordInput, DrugBatchUncheckedCreateWithoutDispenserecordInput>
    connectOrCreate?: DrugBatchCreateOrConnectWithoutDispenserecordInput
    upsert?: DrugBatchUpsertWithoutDispenserecordInput
    disconnect?: boolean
    delete?: boolean
    connect?: DrugBatchWhereUniqueInput
    update?: XOR<DrugBatchUpdateWithoutDispenserecordInput, DrugBatchUncheckedUpdateWithoutDispenserecordInput>
  }

  export type PharmacistUpdateOneWithoutDispenserecordNestedInput = {
    create?: XOR<PharmacistCreateWithoutDispenserecordInput, PharmacistUncheckedCreateWithoutDispenserecordInput>
    connectOrCreate?: PharmacistCreateOrConnectWithoutDispenserecordInput
    upsert?: PharmacistUpsertWithoutDispenserecordInput
    disconnect?: boolean
    delete?: boolean
    connect?: PharmacistWhereUniqueInput
    update?: XOR<PharmacistUpdateWithoutDispenserecordInput, PharmacistUncheckedUpdateWithoutDispenserecordInput>
  }

  export type PrescriptionUpdateOneWithoutDispenserecordNestedInput = {
    create?: XOR<PrescriptionCreateWithoutDispenserecordInput, PrescriptionUncheckedCreateWithoutDispenserecordInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutDispenserecordInput
    upsert?: PrescriptionUpsertWithoutDispenserecordInput
    disconnect?: boolean
    delete?: boolean
    connect?: PrescriptionWhereUniqueInput
    update?: XOR<PrescriptionUpdateWithoutDispenserecordInput, PrescriptionUncheckedUpdateWithoutDispenserecordInput>
  }

  export type DrugBatchCreateNestedOneWithoutBlockchaineventlogInput = {
    create?: XOR<DrugBatchCreateWithoutBlockchaineventlogInput, DrugBatchUncheckedCreateWithoutBlockchaineventlogInput>
    connectOrCreate?: DrugBatchCreateOrConnectWithoutBlockchaineventlogInput
    connect?: DrugBatchWhereUniqueInput
  }

  export type PrescriptionCreateNestedOneWithoutBlockchaineventlogInput = {
    create?: XOR<PrescriptionCreateWithoutBlockchaineventlogInput, PrescriptionUncheckedCreateWithoutBlockchaineventlogInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutBlockchaineventlogInput
    connect?: PrescriptionWhereUniqueInput
  }

  export type SupplyChainRecordCreateNestedOneWithoutBlockchaineventlogInput = {
    create?: XOR<SupplyChainRecordCreateWithoutBlockchaineventlogInput, SupplyChainRecordUncheckedCreateWithoutBlockchaineventlogInput>
    connectOrCreate?: SupplyChainRecordCreateOrConnectWithoutBlockchaineventlogInput
    connect?: SupplyChainRecordWhereUniqueInput
  }

  export type DrugBatchUpdateOneWithoutBlockchaineventlogNestedInput = {
    create?: XOR<DrugBatchCreateWithoutBlockchaineventlogInput, DrugBatchUncheckedCreateWithoutBlockchaineventlogInput>
    connectOrCreate?: DrugBatchCreateOrConnectWithoutBlockchaineventlogInput
    upsert?: DrugBatchUpsertWithoutBlockchaineventlogInput
    disconnect?: boolean
    delete?: boolean
    connect?: DrugBatchWhereUniqueInput
    update?: XOR<DrugBatchUpdateWithoutBlockchaineventlogInput, DrugBatchUncheckedUpdateWithoutBlockchaineventlogInput>
  }

  export type PrescriptionUpdateOneWithoutBlockchaineventlogNestedInput = {
    create?: XOR<PrescriptionCreateWithoutBlockchaineventlogInput, PrescriptionUncheckedCreateWithoutBlockchaineventlogInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutBlockchaineventlogInput
    upsert?: PrescriptionUpsertWithoutBlockchaineventlogInput
    disconnect?: boolean
    delete?: boolean
    connect?: PrescriptionWhereUniqueInput
    update?: XOR<PrescriptionUpdateWithoutBlockchaineventlogInput, PrescriptionUncheckedUpdateWithoutBlockchaineventlogInput>
  }

  export type SupplyChainRecordUpdateOneWithoutBlockchaineventlogNestedInput = {
    create?: XOR<SupplyChainRecordCreateWithoutBlockchaineventlogInput, SupplyChainRecordUncheckedCreateWithoutBlockchaineventlogInput>
    connectOrCreate?: SupplyChainRecordCreateOrConnectWithoutBlockchaineventlogInput
    upsert?: SupplyChainRecordUpsertWithoutBlockchaineventlogInput
    disconnect?: boolean
    delete?: boolean
    connect?: SupplyChainRecordWhereUniqueInput
    update?: XOR<SupplyChainRecordUpdateWithoutBlockchaineventlogInput, SupplyChainRecordUncheckedUpdateWithoutBlockchaineventlogInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }
  export type NestedJsonNullableFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase>, Exclude<keyof Required<NestedJsonNullableFilterBase>, 'path'>>,
        Required<NestedJsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase>, 'path'>>

  export type NestedJsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type UserCreateWithoutRolesInput = {
    wallet: string
    email?: string | null
    passwordhash?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    activitylog?: ActivityLogCreateNestedManyWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUsersInput
    alert?: AlertCreateNestedManyWithoutUsersInput
    distributor?: DistributorCreateNestedOneWithoutUsersInput
    doctor?: DoctorCreateNestedOneWithoutUsersInput
    manufacturer?: ManufacturerCreateNestedOneWithoutUsersInput
    otp?: OtpCreateNestedManyWithoutUsersInput
    patient?: PatientCreateNestedOneWithoutUsersInput
    pharmacist?: PharmacistCreateNestedOneWithoutUsersInput
    regulator?: RegulatorCreateNestedOneWithoutUsersInput
    reports?: ReportCreateNestedManyWithoutUsersInput
    revocationrecord?: RevocationRecordCreateNestedManyWithoutUsersInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordCreateNestedManyWithoutUsers_supplychainrecord_fromentityidTousersInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordCreateNestedManyWithoutUsers_supplychainrecord_toentityidTousersInput
  }

  export type UserUncheckedCreateWithoutRolesInput = {
    id?: number
    wallet: string
    email?: string | null
    passwordhash?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    activitylog?: ActivityLogUncheckedCreateNestedManyWithoutUsersInput
    admin?: AdminUncheckedCreateNestedOneWithoutUsersInput
    alert?: AlertUncheckedCreateNestedManyWithoutUsersInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUsersInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUsersInput
    manufacturer?: ManufacturerUncheckedCreateNestedOneWithoutUsersInput
    otp?: OtpUncheckedCreateNestedManyWithoutUsersInput
    patient?: PatientUncheckedCreateNestedOneWithoutUsersInput
    pharmacist?: PharmacistUncheckedCreateNestedOneWithoutUsersInput
    regulator?: RegulatorUncheckedCreateNestedOneWithoutUsersInput
    reports?: ReportUncheckedCreateNestedManyWithoutUsersInput
    revocationrecord?: RevocationRecordUncheckedCreateNestedManyWithoutUsersInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUncheckedCreateNestedManyWithoutUsers_supplychainrecord_fromentityidTousersInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUncheckedCreateNestedManyWithoutUsers_supplychainrecord_toentityidTousersInput
  }

  export type UserCreateOrConnectWithoutRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type UserCreateManyRolesInputEnvelope = {
    data: Enumerable<UserCreateManyRolesInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutRolesInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRolesInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
  }

  export type UserUpdateManyWithWhereWithoutRolesInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUsersInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    id?: IntFilter | number
    wallet?: StringFilter | string
    email?: StringNullableFilter | string | null
    passwordhash?: StringNullableFilter | string | null
    roleid?: IntNullableFilter | number | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type ActivityLogCreateWithoutUsersInput = {
    action: string
    details?: string | null
    timestamp?: Date | string | null
  }

  export type ActivityLogUncheckedCreateWithoutUsersInput = {
    id?: number
    action: string
    details?: string | null
    timestamp?: Date | string | null
  }

  export type ActivityLogCreateOrConnectWithoutUsersInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutUsersInput, ActivityLogUncheckedCreateWithoutUsersInput>
  }

  export type ActivityLogCreateManyUsersInputEnvelope = {
    data: Enumerable<ActivityLogCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type AdminCreateWithoutUsersInput = {

  }

  export type AdminUncheckedCreateWithoutUsersInput = {
    id?: number
  }

  export type AdminCreateOrConnectWithoutUsersInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutUsersInput, AdminUncheckedCreateWithoutUsersInput>
  }

  export type AlertCreateWithoutUsersInput = {
    title: string
    message: string
    isread?: boolean | null
    priority: string
    createdat?: Date | string | null
  }

  export type AlertUncheckedCreateWithoutUsersInput = {
    id?: number
    title: string
    message: string
    isread?: boolean | null
    priority: string
    createdat?: Date | string | null
  }

  export type AlertCreateOrConnectWithoutUsersInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutUsersInput, AlertUncheckedCreateWithoutUsersInput>
  }

  export type AlertCreateManyUsersInputEnvelope = {
    data: Enumerable<AlertCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type DistributorCreateWithoutUsersInput = {
    companyname: string
  }

  export type DistributorUncheckedCreateWithoutUsersInput = {
    id?: number
    companyname: string
  }

  export type DistributorCreateOrConnectWithoutUsersInput = {
    where: DistributorWhereUniqueInput
    create: XOR<DistributorCreateWithoutUsersInput, DistributorUncheckedCreateWithoutUsersInput>
  }

  export type DoctorCreateWithoutUsersInput = {
    licenseno: string
    hospital: string
    prescription?: PrescriptionCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUncheckedCreateWithoutUsersInput = {
    id?: number
    licenseno: string
    hospital: string
    prescription?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorCreateOrConnectWithoutUsersInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutUsersInput, DoctorUncheckedCreateWithoutUsersInput>
  }

  export type ManufacturerCreateWithoutUsersInput = {
    companyname: string
    drugbatch?: DrugBatchCreateNestedManyWithoutManufacturerInput
  }

  export type ManufacturerUncheckedCreateWithoutUsersInput = {
    id?: number
    companyname: string
    drugbatch?: DrugBatchUncheckedCreateNestedManyWithoutManufacturerInput
  }

  export type ManufacturerCreateOrConnectWithoutUsersInput = {
    where: ManufacturerWhereUniqueInput
    create: XOR<ManufacturerCreateWithoutUsersInput, ManufacturerUncheckedCreateWithoutUsersInput>
  }

  export type OtpCreateWithoutUsersInput = {
    code: string
    expiresat: Date | string
    createdat?: Date | string | null
  }

  export type OtpUncheckedCreateWithoutUsersInput = {
    id?: number
    code: string
    expiresat: Date | string
    createdat?: Date | string | null
  }

  export type OtpCreateOrConnectWithoutUsersInput = {
    where: OtpWhereUniqueInput
    create: XOR<OtpCreateWithoutUsersInput, OtpUncheckedCreateWithoutUsersInput>
  }

  export type OtpCreateManyUsersInputEnvelope = {
    data: Enumerable<OtpCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type PatientCreateWithoutUsersInput = {
    dateofbirth: Date | string
    prescription?: PrescriptionCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutUsersInput = {
    id?: number
    dateofbirth: Date | string
    prescription?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutUsersInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutUsersInput, PatientUncheckedCreateWithoutUsersInput>
  }

  export type PharmacistCreateWithoutUsersInput = {
    licenseno: string
    pharmacy: string
    dispenserecord?: DispenseRecordCreateNestedManyWithoutPharmacistInput
  }

  export type PharmacistUncheckedCreateWithoutUsersInput = {
    id?: number
    licenseno: string
    pharmacy: string
    dispenserecord?: DispenseRecordUncheckedCreateNestedManyWithoutPharmacistInput
  }

  export type PharmacistCreateOrConnectWithoutUsersInput = {
    where: PharmacistWhereUniqueInput
    create: XOR<PharmacistCreateWithoutUsersInput, PharmacistUncheckedCreateWithoutUsersInput>
  }

  export type RegulatorCreateWithoutUsersInput = {
    agencyname: string
  }

  export type RegulatorUncheckedCreateWithoutUsersInput = {
    id?: number
    agencyname: string
  }

  export type RegulatorCreateOrConnectWithoutUsersInput = {
    where: RegulatorWhereUniqueInput
    create: XOR<RegulatorCreateWithoutUsersInput, RegulatorUncheckedCreateWithoutUsersInput>
  }

  export type ReportCreateWithoutUsersInput = {
    reporttype: string
    filters?: NullableJsonNullValueInput | InputJsonValue
    generatedat?: Date | string | null
    ipfshash?: string | null
  }

  export type ReportUncheckedCreateWithoutUsersInput = {
    id?: number
    reporttype: string
    filters?: NullableJsonNullValueInput | InputJsonValue
    generatedat?: Date | string | null
    ipfshash?: string | null
  }

  export type ReportCreateOrConnectWithoutUsersInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutUsersInput, ReportUncheckedCreateWithoutUsersInput>
  }

  export type ReportCreateManyUsersInputEnvelope = {
    data: Enumerable<ReportCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type RevocationRecordCreateWithoutUsersInput = {
    type: string
    refid: number
    reason: string
    timestamp?: Date | string | null
    blockchaintx?: string | null
  }

  export type RevocationRecordUncheckedCreateWithoutUsersInput = {
    id?: number
    type: string
    refid: number
    reason: string
    timestamp?: Date | string | null
    blockchaintx?: string | null
  }

  export type RevocationRecordCreateOrConnectWithoutUsersInput = {
    where: RevocationRecordWhereUniqueInput
    create: XOR<RevocationRecordCreateWithoutUsersInput, RevocationRecordUncheckedCreateWithoutUsersInput>
  }

  export type RevocationRecordCreateManyUsersInputEnvelope = {
    data: Enumerable<RevocationRecordCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type SupplyChainRecordCreateWithoutUsers_supplychainrecord_fromentityidTousersInput = {
    action: string
    timestamp?: Date | string | null
    blockchaintx?: string | null
    blockchaineventlog?: BlockchainEventLogCreateNestedManyWithoutSupplychainrecordInput
    drugbatch?: DrugBatchCreateNestedOneWithoutSupplychainrecordInput
    users_supplychainrecord_toentityidTousers?: UserCreateNestedOneWithoutSupplychainrecord_supplychainrecord_toentityidTousersInput
  }

  export type SupplyChainRecordUncheckedCreateWithoutUsers_supplychainrecord_fromentityidTousersInput = {
    id?: number
    drugbatchid?: number | null
    toentityid?: number | null
    action: string
    timestamp?: Date | string | null
    blockchaintx?: string | null
    blockchaineventlog?: BlockchainEventLogUncheckedCreateNestedManyWithoutSupplychainrecordInput
  }

  export type SupplyChainRecordCreateOrConnectWithoutUsers_supplychainrecord_fromentityidTousersInput = {
    where: SupplyChainRecordWhereUniqueInput
    create: XOR<SupplyChainRecordCreateWithoutUsers_supplychainrecord_fromentityidTousersInput, SupplyChainRecordUncheckedCreateWithoutUsers_supplychainrecord_fromentityidTousersInput>
  }

  export type SupplyChainRecordCreateManyUsers_supplychainrecord_fromentityidTousersInputEnvelope = {
    data: Enumerable<SupplyChainRecordCreateManyUsers_supplychainrecord_fromentityidTousersInput>
    skipDuplicates?: boolean
  }

  export type SupplyChainRecordCreateWithoutUsers_supplychainrecord_toentityidTousersInput = {
    action: string
    timestamp?: Date | string | null
    blockchaintx?: string | null
    blockchaineventlog?: BlockchainEventLogCreateNestedManyWithoutSupplychainrecordInput
    drugbatch?: DrugBatchCreateNestedOneWithoutSupplychainrecordInput
    users_supplychainrecord_fromentityidTousers?: UserCreateNestedOneWithoutSupplychainrecord_supplychainrecord_fromentityidTousersInput
  }

  export type SupplyChainRecordUncheckedCreateWithoutUsers_supplychainrecord_toentityidTousersInput = {
    id?: number
    drugbatchid?: number | null
    fromentityid?: number | null
    action: string
    timestamp?: Date | string | null
    blockchaintx?: string | null
    blockchaineventlog?: BlockchainEventLogUncheckedCreateNestedManyWithoutSupplychainrecordInput
  }

  export type SupplyChainRecordCreateOrConnectWithoutUsers_supplychainrecord_toentityidTousersInput = {
    where: SupplyChainRecordWhereUniqueInput
    create: XOR<SupplyChainRecordCreateWithoutUsers_supplychainrecord_toentityidTousersInput, SupplyChainRecordUncheckedCreateWithoutUsers_supplychainrecord_toentityidTousersInput>
  }

  export type SupplyChainRecordCreateManyUsers_supplychainrecord_toentityidTousersInputEnvelope = {
    data: Enumerable<SupplyChainRecordCreateManyUsers_supplychainrecord_toentityidTousersInput>
    skipDuplicates?: boolean
  }

  export type RoleCreateWithoutUsersInput = {
    name: string
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutUsersInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutUsersInput, ActivityLogUncheckedUpdateWithoutUsersInput>
    create: XOR<ActivityLogCreateWithoutUsersInput, ActivityLogUncheckedCreateWithoutUsersInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutUsersInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutUsersInput, ActivityLogUncheckedUpdateWithoutUsersInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutUsersInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutActivitylogInput>
  }

  export type ActivityLogScalarWhereInput = {
    AND?: Enumerable<ActivityLogScalarWhereInput>
    OR?: Enumerable<ActivityLogScalarWhereInput>
    NOT?: Enumerable<ActivityLogScalarWhereInput>
    id?: IntFilter | number
    userid?: IntNullableFilter | number | null
    action?: StringFilter | string
    details?: StringNullableFilter | string | null
    timestamp?: DateTimeNullableFilter | Date | string | null
  }

  export type AdminUpsertWithoutUsersInput = {
    update: XOR<AdminUpdateWithoutUsersInput, AdminUncheckedUpdateWithoutUsersInput>
    create: XOR<AdminCreateWithoutUsersInput, AdminUncheckedCreateWithoutUsersInput>
  }

  export type AdminUpdateWithoutUsersInput = {

  }

  export type AdminUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type AlertUpsertWithWhereUniqueWithoutUsersInput = {
    where: AlertWhereUniqueInput
    update: XOR<AlertUpdateWithoutUsersInput, AlertUncheckedUpdateWithoutUsersInput>
    create: XOR<AlertCreateWithoutUsersInput, AlertUncheckedCreateWithoutUsersInput>
  }

  export type AlertUpdateWithWhereUniqueWithoutUsersInput = {
    where: AlertWhereUniqueInput
    data: XOR<AlertUpdateWithoutUsersInput, AlertUncheckedUpdateWithoutUsersInput>
  }

  export type AlertUpdateManyWithWhereWithoutUsersInput = {
    where: AlertScalarWhereInput
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyWithoutAlertInput>
  }

  export type AlertScalarWhereInput = {
    AND?: Enumerable<AlertScalarWhereInput>
    OR?: Enumerable<AlertScalarWhereInput>
    NOT?: Enumerable<AlertScalarWhereInput>
    id?: IntFilter | number
    userid?: IntNullableFilter | number | null
    title?: StringFilter | string
    message?: StringFilter | string
    isread?: BoolNullableFilter | boolean | null
    priority?: StringFilter | string
    createdat?: DateTimeNullableFilter | Date | string | null
  }

  export type DistributorUpsertWithoutUsersInput = {
    update: XOR<DistributorUpdateWithoutUsersInput, DistributorUncheckedUpdateWithoutUsersInput>
    create: XOR<DistributorCreateWithoutUsersInput, DistributorUncheckedCreateWithoutUsersInput>
  }

  export type DistributorUpdateWithoutUsersInput = {
    companyname?: StringFieldUpdateOperationsInput | string
  }

  export type DistributorUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyname?: StringFieldUpdateOperationsInput | string
  }

  export type DoctorUpsertWithoutUsersInput = {
    update: XOR<DoctorUpdateWithoutUsersInput, DoctorUncheckedUpdateWithoutUsersInput>
    create: XOR<DoctorCreateWithoutUsersInput, DoctorUncheckedCreateWithoutUsersInput>
  }

  export type DoctorUpdateWithoutUsersInput = {
    licenseno?: StringFieldUpdateOperationsInput | string
    hospital?: StringFieldUpdateOperationsInput | string
    prescription?: PrescriptionUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    licenseno?: StringFieldUpdateOperationsInput | string
    hospital?: StringFieldUpdateOperationsInput | string
    prescription?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type ManufacturerUpsertWithoutUsersInput = {
    update: XOR<ManufacturerUpdateWithoutUsersInput, ManufacturerUncheckedUpdateWithoutUsersInput>
    create: XOR<ManufacturerCreateWithoutUsersInput, ManufacturerUncheckedCreateWithoutUsersInput>
  }

  export type ManufacturerUpdateWithoutUsersInput = {
    companyname?: StringFieldUpdateOperationsInput | string
    drugbatch?: DrugBatchUpdateManyWithoutManufacturerNestedInput
  }

  export type ManufacturerUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyname?: StringFieldUpdateOperationsInput | string
    drugbatch?: DrugBatchUncheckedUpdateManyWithoutManufacturerNestedInput
  }

  export type OtpUpsertWithWhereUniqueWithoutUsersInput = {
    where: OtpWhereUniqueInput
    update: XOR<OtpUpdateWithoutUsersInput, OtpUncheckedUpdateWithoutUsersInput>
    create: XOR<OtpCreateWithoutUsersInput, OtpUncheckedCreateWithoutUsersInput>
  }

  export type OtpUpdateWithWhereUniqueWithoutUsersInput = {
    where: OtpWhereUniqueInput
    data: XOR<OtpUpdateWithoutUsersInput, OtpUncheckedUpdateWithoutUsersInput>
  }

  export type OtpUpdateManyWithWhereWithoutUsersInput = {
    where: OtpScalarWhereInput
    data: XOR<OtpUpdateManyMutationInput, OtpUncheckedUpdateManyWithoutOtpInput>
  }

  export type OtpScalarWhereInput = {
    AND?: Enumerable<OtpScalarWhereInput>
    OR?: Enumerable<OtpScalarWhereInput>
    NOT?: Enumerable<OtpScalarWhereInput>
    id?: IntFilter | number
    userid?: IntNullableFilter | number | null
    code?: StringFilter | string
    expiresat?: DateTimeFilter | Date | string
    createdat?: DateTimeNullableFilter | Date | string | null
  }

  export type PatientUpsertWithoutUsersInput = {
    update: XOR<PatientUpdateWithoutUsersInput, PatientUncheckedUpdateWithoutUsersInput>
    create: XOR<PatientCreateWithoutUsersInput, PatientUncheckedCreateWithoutUsersInput>
  }

  export type PatientUpdateWithoutUsersInput = {
    dateofbirth?: DateTimeFieldUpdateOperationsInput | Date | string
    prescription?: PrescriptionUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateofbirth?: DateTimeFieldUpdateOperationsInput | Date | string
    prescription?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PharmacistUpsertWithoutUsersInput = {
    update: XOR<PharmacistUpdateWithoutUsersInput, PharmacistUncheckedUpdateWithoutUsersInput>
    create: XOR<PharmacistCreateWithoutUsersInput, PharmacistUncheckedCreateWithoutUsersInput>
  }

  export type PharmacistUpdateWithoutUsersInput = {
    licenseno?: StringFieldUpdateOperationsInput | string
    pharmacy?: StringFieldUpdateOperationsInput | string
    dispenserecord?: DispenseRecordUpdateManyWithoutPharmacistNestedInput
  }

  export type PharmacistUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    licenseno?: StringFieldUpdateOperationsInput | string
    pharmacy?: StringFieldUpdateOperationsInput | string
    dispenserecord?: DispenseRecordUncheckedUpdateManyWithoutPharmacistNestedInput
  }

  export type RegulatorUpsertWithoutUsersInput = {
    update: XOR<RegulatorUpdateWithoutUsersInput, RegulatorUncheckedUpdateWithoutUsersInput>
    create: XOR<RegulatorCreateWithoutUsersInput, RegulatorUncheckedCreateWithoutUsersInput>
  }

  export type RegulatorUpdateWithoutUsersInput = {
    agencyname?: StringFieldUpdateOperationsInput | string
  }

  export type RegulatorUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    agencyname?: StringFieldUpdateOperationsInput | string
  }

  export type ReportUpsertWithWhereUniqueWithoutUsersInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutUsersInput, ReportUncheckedUpdateWithoutUsersInput>
    create: XOR<ReportCreateWithoutUsersInput, ReportUncheckedCreateWithoutUsersInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutUsersInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutUsersInput, ReportUncheckedUpdateWithoutUsersInput>
  }

  export type ReportUpdateManyWithWhereWithoutUsersInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutReportsInput>
  }

  export type ReportScalarWhereInput = {
    AND?: Enumerable<ReportScalarWhereInput>
    OR?: Enumerable<ReportScalarWhereInput>
    NOT?: Enumerable<ReportScalarWhereInput>
    id?: IntFilter | number
    userid?: IntNullableFilter | number | null
    reporttype?: StringFilter | string
    filters?: JsonNullableFilter
    generatedat?: DateTimeNullableFilter | Date | string | null
    ipfshash?: StringNullableFilter | string | null
  }

  export type RevocationRecordUpsertWithWhereUniqueWithoutUsersInput = {
    where: RevocationRecordWhereUniqueInput
    update: XOR<RevocationRecordUpdateWithoutUsersInput, RevocationRecordUncheckedUpdateWithoutUsersInput>
    create: XOR<RevocationRecordCreateWithoutUsersInput, RevocationRecordUncheckedCreateWithoutUsersInput>
  }

  export type RevocationRecordUpdateWithWhereUniqueWithoutUsersInput = {
    where: RevocationRecordWhereUniqueInput
    data: XOR<RevocationRecordUpdateWithoutUsersInput, RevocationRecordUncheckedUpdateWithoutUsersInput>
  }

  export type RevocationRecordUpdateManyWithWhereWithoutUsersInput = {
    where: RevocationRecordScalarWhereInput
    data: XOR<RevocationRecordUpdateManyMutationInput, RevocationRecordUncheckedUpdateManyWithoutRevocationrecordInput>
  }

  export type RevocationRecordScalarWhereInput = {
    AND?: Enumerable<RevocationRecordScalarWhereInput>
    OR?: Enumerable<RevocationRecordScalarWhereInput>
    NOT?: Enumerable<RevocationRecordScalarWhereInput>
    id?: IntFilter | number
    type?: StringFilter | string
    refid?: IntFilter | number
    reason?: StringFilter | string
    revokedbyid?: IntNullableFilter | number | null
    timestamp?: DateTimeNullableFilter | Date | string | null
    blockchaintx?: StringNullableFilter | string | null
  }

  export type SupplyChainRecordUpsertWithWhereUniqueWithoutUsers_supplychainrecord_fromentityidTousersInput = {
    where: SupplyChainRecordWhereUniqueInput
    update: XOR<SupplyChainRecordUpdateWithoutUsers_supplychainrecord_fromentityidTousersInput, SupplyChainRecordUncheckedUpdateWithoutUsers_supplychainrecord_fromentityidTousersInput>
    create: XOR<SupplyChainRecordCreateWithoutUsers_supplychainrecord_fromentityidTousersInput, SupplyChainRecordUncheckedCreateWithoutUsers_supplychainrecord_fromentityidTousersInput>
  }

  export type SupplyChainRecordUpdateWithWhereUniqueWithoutUsers_supplychainrecord_fromentityidTousersInput = {
    where: SupplyChainRecordWhereUniqueInput
    data: XOR<SupplyChainRecordUpdateWithoutUsers_supplychainrecord_fromentityidTousersInput, SupplyChainRecordUncheckedUpdateWithoutUsers_supplychainrecord_fromentityidTousersInput>
  }

  export type SupplyChainRecordUpdateManyWithWhereWithoutUsers_supplychainrecord_fromentityidTousersInput = {
    where: SupplyChainRecordScalarWhereInput
    data: XOR<SupplyChainRecordUpdateManyMutationInput, SupplyChainRecordUncheckedUpdateManyWithoutSupplychainrecord_supplychainrecord_fromentityidTousersInput>
  }

  export type SupplyChainRecordScalarWhereInput = {
    AND?: Enumerable<SupplyChainRecordScalarWhereInput>
    OR?: Enumerable<SupplyChainRecordScalarWhereInput>
    NOT?: Enumerable<SupplyChainRecordScalarWhereInput>
    id?: IntFilter | number
    drugbatchid?: IntNullableFilter | number | null
    fromentityid?: IntNullableFilter | number | null
    toentityid?: IntNullableFilter | number | null
    action?: StringFilter | string
    timestamp?: DateTimeNullableFilter | Date | string | null
    blockchaintx?: StringNullableFilter | string | null
  }

  export type SupplyChainRecordUpsertWithWhereUniqueWithoutUsers_supplychainrecord_toentityidTousersInput = {
    where: SupplyChainRecordWhereUniqueInput
    update: XOR<SupplyChainRecordUpdateWithoutUsers_supplychainrecord_toentityidTousersInput, SupplyChainRecordUncheckedUpdateWithoutUsers_supplychainrecord_toentityidTousersInput>
    create: XOR<SupplyChainRecordCreateWithoutUsers_supplychainrecord_toentityidTousersInput, SupplyChainRecordUncheckedCreateWithoutUsers_supplychainrecord_toentityidTousersInput>
  }

  export type SupplyChainRecordUpdateWithWhereUniqueWithoutUsers_supplychainrecord_toentityidTousersInput = {
    where: SupplyChainRecordWhereUniqueInput
    data: XOR<SupplyChainRecordUpdateWithoutUsers_supplychainrecord_toentityidTousersInput, SupplyChainRecordUncheckedUpdateWithoutUsers_supplychainrecord_toentityidTousersInput>
  }

  export type SupplyChainRecordUpdateManyWithWhereWithoutUsers_supplychainrecord_toentityidTousersInput = {
    where: SupplyChainRecordScalarWhereInput
    data: XOR<SupplyChainRecordUpdateManyMutationInput, SupplyChainRecordUncheckedUpdateManyWithoutSupplychainrecord_supplychainrecord_toentityidTousersInput>
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutDoctorInput = {
    wallet: string
    email?: string | null
    passwordhash?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    activitylog?: ActivityLogCreateNestedManyWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUsersInput
    alert?: AlertCreateNestedManyWithoutUsersInput
    distributor?: DistributorCreateNestedOneWithoutUsersInput
    manufacturer?: ManufacturerCreateNestedOneWithoutUsersInput
    otp?: OtpCreateNestedManyWithoutUsersInput
    patient?: PatientCreateNestedOneWithoutUsersInput
    pharmacist?: PharmacistCreateNestedOneWithoutUsersInput
    regulator?: RegulatorCreateNestedOneWithoutUsersInput
    reports?: ReportCreateNestedManyWithoutUsersInput
    revocationrecord?: RevocationRecordCreateNestedManyWithoutUsersInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordCreateNestedManyWithoutUsers_supplychainrecord_fromentityidTousersInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordCreateNestedManyWithoutUsers_supplychainrecord_toentityidTousersInput
    roles?: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutDoctorInput = {
    id?: number
    wallet: string
    email?: string | null
    passwordhash?: string | null
    roleid?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    activitylog?: ActivityLogUncheckedCreateNestedManyWithoutUsersInput
    admin?: AdminUncheckedCreateNestedOneWithoutUsersInput
    alert?: AlertUncheckedCreateNestedManyWithoutUsersInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUsersInput
    manufacturer?: ManufacturerUncheckedCreateNestedOneWithoutUsersInput
    otp?: OtpUncheckedCreateNestedManyWithoutUsersInput
    patient?: PatientUncheckedCreateNestedOneWithoutUsersInput
    pharmacist?: PharmacistUncheckedCreateNestedOneWithoutUsersInput
    regulator?: RegulatorUncheckedCreateNestedOneWithoutUsersInput
    reports?: ReportUncheckedCreateNestedManyWithoutUsersInput
    revocationrecord?: RevocationRecordUncheckedCreateNestedManyWithoutUsersInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUncheckedCreateNestedManyWithoutUsers_supplychainrecord_fromentityidTousersInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUncheckedCreateNestedManyWithoutUsers_supplychainrecord_toentityidTousersInput
  }

  export type UserCreateOrConnectWithoutDoctorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDoctorInput, UserUncheckedCreateWithoutDoctorInput>
  }

  export type PrescriptionCreateWithoutDoctorInput = {
    dosage: string
    issuedat?: Date | string | null
    expiresat: Date | string
    blockchaintx?: string | null
    qrcode: string
    ipfshash?: string | null
    status: string
    blockchaineventlog?: BlockchainEventLogCreateNestedManyWithoutPrescriptionInput
    dispenserecord?: DispenseRecordCreateNestedManyWithoutPrescriptionInput
    drug?: DrugCreateNestedOneWithoutPrescriptionInput
    patient?: PatientCreateNestedOneWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutDoctorInput = {
    id?: number
    patientid?: number | null
    drugid?: number | null
    dosage: string
    issuedat?: Date | string | null
    expiresat: Date | string
    blockchaintx?: string | null
    qrcode: string
    ipfshash?: string | null
    status: string
    blockchaineventlog?: BlockchainEventLogUncheckedCreateNestedManyWithoutPrescriptionInput
    dispenserecord?: DispenseRecordUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionCreateOrConnectWithoutDoctorInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutDoctorInput, PrescriptionUncheckedCreateWithoutDoctorInput>
  }

  export type PrescriptionCreateManyDoctorInputEnvelope = {
    data: Enumerable<PrescriptionCreateManyDoctorInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutDoctorInput = {
    update: XOR<UserUpdateWithoutDoctorInput, UserUncheckedUpdateWithoutDoctorInput>
    create: XOR<UserCreateWithoutDoctorInput, UserUncheckedCreateWithoutDoctorInput>
  }

  export type UserUpdateWithoutDoctorInput = {
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: ActivityLogUpdateManyWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUsersNestedInput
    alert?: AlertUpdateManyWithoutUsersNestedInput
    distributor?: DistributorUpdateOneWithoutUsersNestedInput
    manufacturer?: ManufacturerUpdateOneWithoutUsersNestedInput
    otp?: OtpUpdateManyWithoutUsersNestedInput
    patient?: PatientUpdateOneWithoutUsersNestedInput
    pharmacist?: PharmacistUpdateOneWithoutUsersNestedInput
    regulator?: RegulatorUpdateOneWithoutUsersNestedInput
    reports?: ReportUpdateManyWithoutUsersNestedInput
    revocationrecord?: RevocationRecordUpdateManyWithoutUsersNestedInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUpdateManyWithoutUsers_supplychainrecord_fromentityidTousersNestedInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUpdateManyWithoutUsers_supplychainrecord_toentityidTousersNestedInput
    roles?: RoleUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    roleid?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: ActivityLogUncheckedUpdateManyWithoutUsersNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUsersNestedInput
    alert?: AlertUncheckedUpdateManyWithoutUsersNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUsersNestedInput
    manufacturer?: ManufacturerUncheckedUpdateOneWithoutUsersNestedInput
    otp?: OtpUncheckedUpdateManyWithoutUsersNestedInput
    patient?: PatientUncheckedUpdateOneWithoutUsersNestedInput
    pharmacist?: PharmacistUncheckedUpdateOneWithoutUsersNestedInput
    regulator?: RegulatorUncheckedUpdateOneWithoutUsersNestedInput
    reports?: ReportUncheckedUpdateManyWithoutUsersNestedInput
    revocationrecord?: RevocationRecordUncheckedUpdateManyWithoutUsersNestedInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUncheckedUpdateManyWithoutUsers_supplychainrecord_fromentityidTousersNestedInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUncheckedUpdateManyWithoutUsers_supplychainrecord_toentityidTousersNestedInput
  }

  export type PrescriptionUpsertWithWhereUniqueWithoutDoctorInput = {
    where: PrescriptionWhereUniqueInput
    update: XOR<PrescriptionUpdateWithoutDoctorInput, PrescriptionUncheckedUpdateWithoutDoctorInput>
    create: XOR<PrescriptionCreateWithoutDoctorInput, PrescriptionUncheckedCreateWithoutDoctorInput>
  }

  export type PrescriptionUpdateWithWhereUniqueWithoutDoctorInput = {
    where: PrescriptionWhereUniqueInput
    data: XOR<PrescriptionUpdateWithoutDoctorInput, PrescriptionUncheckedUpdateWithoutDoctorInput>
  }

  export type PrescriptionUpdateManyWithWhereWithoutDoctorInput = {
    where: PrescriptionScalarWhereInput
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyWithoutPrescriptionInput>
  }

  export type PrescriptionScalarWhereInput = {
    AND?: Enumerable<PrescriptionScalarWhereInput>
    OR?: Enumerable<PrescriptionScalarWhereInput>
    NOT?: Enumerable<PrescriptionScalarWhereInput>
    id?: IntFilter | number
    patientid?: IntNullableFilter | number | null
    doctorid?: IntNullableFilter | number | null
    drugid?: IntNullableFilter | number | null
    dosage?: StringFilter | string
    issuedat?: DateTimeNullableFilter | Date | string | null
    expiresat?: DateTimeFilter | Date | string
    blockchaintx?: StringNullableFilter | string | null
    qrcode?: StringFilter | string
    ipfshash?: StringNullableFilter | string | null
    status?: StringFilter | string
  }

  export type UserCreateWithoutPatientInput = {
    wallet: string
    email?: string | null
    passwordhash?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    activitylog?: ActivityLogCreateNestedManyWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUsersInput
    alert?: AlertCreateNestedManyWithoutUsersInput
    distributor?: DistributorCreateNestedOneWithoutUsersInput
    doctor?: DoctorCreateNestedOneWithoutUsersInput
    manufacturer?: ManufacturerCreateNestedOneWithoutUsersInput
    otp?: OtpCreateNestedManyWithoutUsersInput
    pharmacist?: PharmacistCreateNestedOneWithoutUsersInput
    regulator?: RegulatorCreateNestedOneWithoutUsersInput
    reports?: ReportCreateNestedManyWithoutUsersInput
    revocationrecord?: RevocationRecordCreateNestedManyWithoutUsersInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordCreateNestedManyWithoutUsers_supplychainrecord_fromentityidTousersInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordCreateNestedManyWithoutUsers_supplychainrecord_toentityidTousersInput
    roles?: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutPatientInput = {
    id?: number
    wallet: string
    email?: string | null
    passwordhash?: string | null
    roleid?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    activitylog?: ActivityLogUncheckedCreateNestedManyWithoutUsersInput
    admin?: AdminUncheckedCreateNestedOneWithoutUsersInput
    alert?: AlertUncheckedCreateNestedManyWithoutUsersInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUsersInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUsersInput
    manufacturer?: ManufacturerUncheckedCreateNestedOneWithoutUsersInput
    otp?: OtpUncheckedCreateNestedManyWithoutUsersInput
    pharmacist?: PharmacistUncheckedCreateNestedOneWithoutUsersInput
    regulator?: RegulatorUncheckedCreateNestedOneWithoutUsersInput
    reports?: ReportUncheckedCreateNestedManyWithoutUsersInput
    revocationrecord?: RevocationRecordUncheckedCreateNestedManyWithoutUsersInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUncheckedCreateNestedManyWithoutUsers_supplychainrecord_fromentityidTousersInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUncheckedCreateNestedManyWithoutUsers_supplychainrecord_toentityidTousersInput
  }

  export type UserCreateOrConnectWithoutPatientInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPatientInput, UserUncheckedCreateWithoutPatientInput>
  }

  export type PrescriptionCreateWithoutPatientInput = {
    dosage: string
    issuedat?: Date | string | null
    expiresat: Date | string
    blockchaintx?: string | null
    qrcode: string
    ipfshash?: string | null
    status: string
    blockchaineventlog?: BlockchainEventLogCreateNestedManyWithoutPrescriptionInput
    dispenserecord?: DispenseRecordCreateNestedManyWithoutPrescriptionInput
    doctor?: DoctorCreateNestedOneWithoutPrescriptionInput
    drug?: DrugCreateNestedOneWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutPatientInput = {
    id?: number
    doctorid?: number | null
    drugid?: number | null
    dosage: string
    issuedat?: Date | string | null
    expiresat: Date | string
    blockchaintx?: string | null
    qrcode: string
    ipfshash?: string | null
    status: string
    blockchaineventlog?: BlockchainEventLogUncheckedCreateNestedManyWithoutPrescriptionInput
    dispenserecord?: DispenseRecordUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionCreateOrConnectWithoutPatientInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput>
  }

  export type PrescriptionCreateManyPatientInputEnvelope = {
    data: Enumerable<PrescriptionCreateManyPatientInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPatientInput = {
    update: XOR<UserUpdateWithoutPatientInput, UserUncheckedUpdateWithoutPatientInput>
    create: XOR<UserCreateWithoutPatientInput, UserUncheckedCreateWithoutPatientInput>
  }

  export type UserUpdateWithoutPatientInput = {
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: ActivityLogUpdateManyWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUsersNestedInput
    alert?: AlertUpdateManyWithoutUsersNestedInput
    distributor?: DistributorUpdateOneWithoutUsersNestedInput
    doctor?: DoctorUpdateOneWithoutUsersNestedInput
    manufacturer?: ManufacturerUpdateOneWithoutUsersNestedInput
    otp?: OtpUpdateManyWithoutUsersNestedInput
    pharmacist?: PharmacistUpdateOneWithoutUsersNestedInput
    regulator?: RegulatorUpdateOneWithoutUsersNestedInput
    reports?: ReportUpdateManyWithoutUsersNestedInput
    revocationrecord?: RevocationRecordUpdateManyWithoutUsersNestedInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUpdateManyWithoutUsers_supplychainrecord_fromentityidTousersNestedInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUpdateManyWithoutUsers_supplychainrecord_toentityidTousersNestedInput
    roles?: RoleUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    roleid?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: ActivityLogUncheckedUpdateManyWithoutUsersNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUsersNestedInput
    alert?: AlertUncheckedUpdateManyWithoutUsersNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUsersNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUsersNestedInput
    manufacturer?: ManufacturerUncheckedUpdateOneWithoutUsersNestedInput
    otp?: OtpUncheckedUpdateManyWithoutUsersNestedInput
    pharmacist?: PharmacistUncheckedUpdateOneWithoutUsersNestedInput
    regulator?: RegulatorUncheckedUpdateOneWithoutUsersNestedInput
    reports?: ReportUncheckedUpdateManyWithoutUsersNestedInput
    revocationrecord?: RevocationRecordUncheckedUpdateManyWithoutUsersNestedInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUncheckedUpdateManyWithoutUsers_supplychainrecord_fromentityidTousersNestedInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUncheckedUpdateManyWithoutUsers_supplychainrecord_toentityidTousersNestedInput
  }

  export type PrescriptionUpsertWithWhereUniqueWithoutPatientInput = {
    where: PrescriptionWhereUniqueInput
    update: XOR<PrescriptionUpdateWithoutPatientInput, PrescriptionUncheckedUpdateWithoutPatientInput>
    create: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput>
  }

  export type PrescriptionUpdateWithWhereUniqueWithoutPatientInput = {
    where: PrescriptionWhereUniqueInput
    data: XOR<PrescriptionUpdateWithoutPatientInput, PrescriptionUncheckedUpdateWithoutPatientInput>
  }

  export type PrescriptionUpdateManyWithWhereWithoutPatientInput = {
    where: PrescriptionScalarWhereInput
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyWithoutPrescriptionInput>
  }

  export type DispenseRecordCreateWithoutPharmacistInput = {
    quantity: number
    dispensedat?: Date | string | null
    blockchaintx?: string | null
    drugbatch?: DrugBatchCreateNestedOneWithoutDispenserecordInput
    prescription?: PrescriptionCreateNestedOneWithoutDispenserecordInput
  }

  export type DispenseRecordUncheckedCreateWithoutPharmacistInput = {
    id?: number
    prescriptionid?: number | null
    drugbatchid?: number | null
    quantity: number
    dispensedat?: Date | string | null
    blockchaintx?: string | null
  }

  export type DispenseRecordCreateOrConnectWithoutPharmacistInput = {
    where: DispenseRecordWhereUniqueInput
    create: XOR<DispenseRecordCreateWithoutPharmacistInput, DispenseRecordUncheckedCreateWithoutPharmacistInput>
  }

  export type DispenseRecordCreateManyPharmacistInputEnvelope = {
    data: Enumerable<DispenseRecordCreateManyPharmacistInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutPharmacistInput = {
    wallet: string
    email?: string | null
    passwordhash?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    activitylog?: ActivityLogCreateNestedManyWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUsersInput
    alert?: AlertCreateNestedManyWithoutUsersInput
    distributor?: DistributorCreateNestedOneWithoutUsersInput
    doctor?: DoctorCreateNestedOneWithoutUsersInput
    manufacturer?: ManufacturerCreateNestedOneWithoutUsersInput
    otp?: OtpCreateNestedManyWithoutUsersInput
    patient?: PatientCreateNestedOneWithoutUsersInput
    regulator?: RegulatorCreateNestedOneWithoutUsersInput
    reports?: ReportCreateNestedManyWithoutUsersInput
    revocationrecord?: RevocationRecordCreateNestedManyWithoutUsersInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordCreateNestedManyWithoutUsers_supplychainrecord_fromentityidTousersInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordCreateNestedManyWithoutUsers_supplychainrecord_toentityidTousersInput
    roles?: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutPharmacistInput = {
    id?: number
    wallet: string
    email?: string | null
    passwordhash?: string | null
    roleid?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    activitylog?: ActivityLogUncheckedCreateNestedManyWithoutUsersInput
    admin?: AdminUncheckedCreateNestedOneWithoutUsersInput
    alert?: AlertUncheckedCreateNestedManyWithoutUsersInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUsersInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUsersInput
    manufacturer?: ManufacturerUncheckedCreateNestedOneWithoutUsersInput
    otp?: OtpUncheckedCreateNestedManyWithoutUsersInput
    patient?: PatientUncheckedCreateNestedOneWithoutUsersInput
    regulator?: RegulatorUncheckedCreateNestedOneWithoutUsersInput
    reports?: ReportUncheckedCreateNestedManyWithoutUsersInput
    revocationrecord?: RevocationRecordUncheckedCreateNestedManyWithoutUsersInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUncheckedCreateNestedManyWithoutUsers_supplychainrecord_fromentityidTousersInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUncheckedCreateNestedManyWithoutUsers_supplychainrecord_toentityidTousersInput
  }

  export type UserCreateOrConnectWithoutPharmacistInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPharmacistInput, UserUncheckedCreateWithoutPharmacistInput>
  }

  export type DispenseRecordUpsertWithWhereUniqueWithoutPharmacistInput = {
    where: DispenseRecordWhereUniqueInput
    update: XOR<DispenseRecordUpdateWithoutPharmacistInput, DispenseRecordUncheckedUpdateWithoutPharmacistInput>
    create: XOR<DispenseRecordCreateWithoutPharmacistInput, DispenseRecordUncheckedCreateWithoutPharmacistInput>
  }

  export type DispenseRecordUpdateWithWhereUniqueWithoutPharmacistInput = {
    where: DispenseRecordWhereUniqueInput
    data: XOR<DispenseRecordUpdateWithoutPharmacistInput, DispenseRecordUncheckedUpdateWithoutPharmacistInput>
  }

  export type DispenseRecordUpdateManyWithWhereWithoutPharmacistInput = {
    where: DispenseRecordScalarWhereInput
    data: XOR<DispenseRecordUpdateManyMutationInput, DispenseRecordUncheckedUpdateManyWithoutDispenserecordInput>
  }

  export type DispenseRecordScalarWhereInput = {
    AND?: Enumerable<DispenseRecordScalarWhereInput>
    OR?: Enumerable<DispenseRecordScalarWhereInput>
    NOT?: Enumerable<DispenseRecordScalarWhereInput>
    id?: IntFilter | number
    prescriptionid?: IntNullableFilter | number | null
    pharmacistid?: IntNullableFilter | number | null
    drugbatchid?: IntNullableFilter | number | null
    quantity?: IntFilter | number
    dispensedat?: DateTimeNullableFilter | Date | string | null
    blockchaintx?: StringNullableFilter | string | null
  }

  export type UserUpsertWithoutPharmacistInput = {
    update: XOR<UserUpdateWithoutPharmacistInput, UserUncheckedUpdateWithoutPharmacistInput>
    create: XOR<UserCreateWithoutPharmacistInput, UserUncheckedCreateWithoutPharmacistInput>
  }

  export type UserUpdateWithoutPharmacistInput = {
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: ActivityLogUpdateManyWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUsersNestedInput
    alert?: AlertUpdateManyWithoutUsersNestedInput
    distributor?: DistributorUpdateOneWithoutUsersNestedInput
    doctor?: DoctorUpdateOneWithoutUsersNestedInput
    manufacturer?: ManufacturerUpdateOneWithoutUsersNestedInput
    otp?: OtpUpdateManyWithoutUsersNestedInput
    patient?: PatientUpdateOneWithoutUsersNestedInput
    regulator?: RegulatorUpdateOneWithoutUsersNestedInput
    reports?: ReportUpdateManyWithoutUsersNestedInput
    revocationrecord?: RevocationRecordUpdateManyWithoutUsersNestedInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUpdateManyWithoutUsers_supplychainrecord_fromentityidTousersNestedInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUpdateManyWithoutUsers_supplychainrecord_toentityidTousersNestedInput
    roles?: RoleUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutPharmacistInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    roleid?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: ActivityLogUncheckedUpdateManyWithoutUsersNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUsersNestedInput
    alert?: AlertUncheckedUpdateManyWithoutUsersNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUsersNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUsersNestedInput
    manufacturer?: ManufacturerUncheckedUpdateOneWithoutUsersNestedInput
    otp?: OtpUncheckedUpdateManyWithoutUsersNestedInput
    patient?: PatientUncheckedUpdateOneWithoutUsersNestedInput
    regulator?: RegulatorUncheckedUpdateOneWithoutUsersNestedInput
    reports?: ReportUncheckedUpdateManyWithoutUsersNestedInput
    revocationrecord?: RevocationRecordUncheckedUpdateManyWithoutUsersNestedInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUncheckedUpdateManyWithoutUsers_supplychainrecord_fromentityidTousersNestedInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUncheckedUpdateManyWithoutUsers_supplychainrecord_toentityidTousersNestedInput
  }

  export type DrugBatchCreateWithoutManufacturerInput = {
    batchnumber: string
    manufacturedate: Date | string
    expirydate: Date | string
    blockchaintx?: string | null
    qrcode: string
    ipfshash?: string | null
    blockchaineventlog?: BlockchainEventLogCreateNestedManyWithoutDrugbatchInput
    dispenserecord?: DispenseRecordCreateNestedManyWithoutDrugbatchInput
    drug?: DrugCreateNestedOneWithoutDrugbatchInput
    supplychainrecord?: SupplyChainRecordCreateNestedManyWithoutDrugbatchInput
  }

  export type DrugBatchUncheckedCreateWithoutManufacturerInput = {
    id?: number
    drugid?: number | null
    batchnumber: string
    manufacturedate: Date | string
    expirydate: Date | string
    blockchaintx?: string | null
    qrcode: string
    ipfshash?: string | null
    blockchaineventlog?: BlockchainEventLogUncheckedCreateNestedManyWithoutDrugbatchInput
    dispenserecord?: DispenseRecordUncheckedCreateNestedManyWithoutDrugbatchInput
    supplychainrecord?: SupplyChainRecordUncheckedCreateNestedManyWithoutDrugbatchInput
  }

  export type DrugBatchCreateOrConnectWithoutManufacturerInput = {
    where: DrugBatchWhereUniqueInput
    create: XOR<DrugBatchCreateWithoutManufacturerInput, DrugBatchUncheckedCreateWithoutManufacturerInput>
  }

  export type DrugBatchCreateManyManufacturerInputEnvelope = {
    data: Enumerable<DrugBatchCreateManyManufacturerInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutManufacturerInput = {
    wallet: string
    email?: string | null
    passwordhash?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    activitylog?: ActivityLogCreateNestedManyWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUsersInput
    alert?: AlertCreateNestedManyWithoutUsersInput
    distributor?: DistributorCreateNestedOneWithoutUsersInput
    doctor?: DoctorCreateNestedOneWithoutUsersInput
    otp?: OtpCreateNestedManyWithoutUsersInput
    patient?: PatientCreateNestedOneWithoutUsersInput
    pharmacist?: PharmacistCreateNestedOneWithoutUsersInput
    regulator?: RegulatorCreateNestedOneWithoutUsersInput
    reports?: ReportCreateNestedManyWithoutUsersInput
    revocationrecord?: RevocationRecordCreateNestedManyWithoutUsersInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordCreateNestedManyWithoutUsers_supplychainrecord_fromentityidTousersInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordCreateNestedManyWithoutUsers_supplychainrecord_toentityidTousersInput
    roles?: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutManufacturerInput = {
    id?: number
    wallet: string
    email?: string | null
    passwordhash?: string | null
    roleid?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    activitylog?: ActivityLogUncheckedCreateNestedManyWithoutUsersInput
    admin?: AdminUncheckedCreateNestedOneWithoutUsersInput
    alert?: AlertUncheckedCreateNestedManyWithoutUsersInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUsersInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUsersInput
    otp?: OtpUncheckedCreateNestedManyWithoutUsersInput
    patient?: PatientUncheckedCreateNestedOneWithoutUsersInput
    pharmacist?: PharmacistUncheckedCreateNestedOneWithoutUsersInput
    regulator?: RegulatorUncheckedCreateNestedOneWithoutUsersInput
    reports?: ReportUncheckedCreateNestedManyWithoutUsersInput
    revocationrecord?: RevocationRecordUncheckedCreateNestedManyWithoutUsersInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUncheckedCreateNestedManyWithoutUsers_supplychainrecord_fromentityidTousersInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUncheckedCreateNestedManyWithoutUsers_supplychainrecord_toentityidTousersInput
  }

  export type UserCreateOrConnectWithoutManufacturerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutManufacturerInput, UserUncheckedCreateWithoutManufacturerInput>
  }

  export type DrugBatchUpsertWithWhereUniqueWithoutManufacturerInput = {
    where: DrugBatchWhereUniqueInput
    update: XOR<DrugBatchUpdateWithoutManufacturerInput, DrugBatchUncheckedUpdateWithoutManufacturerInput>
    create: XOR<DrugBatchCreateWithoutManufacturerInput, DrugBatchUncheckedCreateWithoutManufacturerInput>
  }

  export type DrugBatchUpdateWithWhereUniqueWithoutManufacturerInput = {
    where: DrugBatchWhereUniqueInput
    data: XOR<DrugBatchUpdateWithoutManufacturerInput, DrugBatchUncheckedUpdateWithoutManufacturerInput>
  }

  export type DrugBatchUpdateManyWithWhereWithoutManufacturerInput = {
    where: DrugBatchScalarWhereInput
    data: XOR<DrugBatchUpdateManyMutationInput, DrugBatchUncheckedUpdateManyWithoutDrugbatchInput>
  }

  export type DrugBatchScalarWhereInput = {
    AND?: Enumerable<DrugBatchScalarWhereInput>
    OR?: Enumerable<DrugBatchScalarWhereInput>
    NOT?: Enumerable<DrugBatchScalarWhereInput>
    id?: IntFilter | number
    manufacturerid?: IntNullableFilter | number | null
    drugid?: IntNullableFilter | number | null
    batchnumber?: StringFilter | string
    manufacturedate?: DateTimeFilter | Date | string
    expirydate?: DateTimeFilter | Date | string
    blockchaintx?: StringNullableFilter | string | null
    qrcode?: StringFilter | string
    ipfshash?: StringNullableFilter | string | null
  }

  export type UserUpsertWithoutManufacturerInput = {
    update: XOR<UserUpdateWithoutManufacturerInput, UserUncheckedUpdateWithoutManufacturerInput>
    create: XOR<UserCreateWithoutManufacturerInput, UserUncheckedCreateWithoutManufacturerInput>
  }

  export type UserUpdateWithoutManufacturerInput = {
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: ActivityLogUpdateManyWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUsersNestedInput
    alert?: AlertUpdateManyWithoutUsersNestedInput
    distributor?: DistributorUpdateOneWithoutUsersNestedInput
    doctor?: DoctorUpdateOneWithoutUsersNestedInput
    otp?: OtpUpdateManyWithoutUsersNestedInput
    patient?: PatientUpdateOneWithoutUsersNestedInput
    pharmacist?: PharmacistUpdateOneWithoutUsersNestedInput
    regulator?: RegulatorUpdateOneWithoutUsersNestedInput
    reports?: ReportUpdateManyWithoutUsersNestedInput
    revocationrecord?: RevocationRecordUpdateManyWithoutUsersNestedInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUpdateManyWithoutUsers_supplychainrecord_fromentityidTousersNestedInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUpdateManyWithoutUsers_supplychainrecord_toentityidTousersNestedInput
    roles?: RoleUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutManufacturerInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    roleid?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: ActivityLogUncheckedUpdateManyWithoutUsersNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUsersNestedInput
    alert?: AlertUncheckedUpdateManyWithoutUsersNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUsersNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUsersNestedInput
    otp?: OtpUncheckedUpdateManyWithoutUsersNestedInput
    patient?: PatientUncheckedUpdateOneWithoutUsersNestedInput
    pharmacist?: PharmacistUncheckedUpdateOneWithoutUsersNestedInput
    regulator?: RegulatorUncheckedUpdateOneWithoutUsersNestedInput
    reports?: ReportUncheckedUpdateManyWithoutUsersNestedInput
    revocationrecord?: RevocationRecordUncheckedUpdateManyWithoutUsersNestedInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUncheckedUpdateManyWithoutUsers_supplychainrecord_fromentityidTousersNestedInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUncheckedUpdateManyWithoutUsers_supplychainrecord_toentityidTousersNestedInput
  }

  export type UserCreateWithoutDistributorInput = {
    wallet: string
    email?: string | null
    passwordhash?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    activitylog?: ActivityLogCreateNestedManyWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUsersInput
    alert?: AlertCreateNestedManyWithoutUsersInput
    doctor?: DoctorCreateNestedOneWithoutUsersInput
    manufacturer?: ManufacturerCreateNestedOneWithoutUsersInput
    otp?: OtpCreateNestedManyWithoutUsersInput
    patient?: PatientCreateNestedOneWithoutUsersInput
    pharmacist?: PharmacistCreateNestedOneWithoutUsersInput
    regulator?: RegulatorCreateNestedOneWithoutUsersInput
    reports?: ReportCreateNestedManyWithoutUsersInput
    revocationrecord?: RevocationRecordCreateNestedManyWithoutUsersInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordCreateNestedManyWithoutUsers_supplychainrecord_fromentityidTousersInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordCreateNestedManyWithoutUsers_supplychainrecord_toentityidTousersInput
    roles?: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutDistributorInput = {
    id?: number
    wallet: string
    email?: string | null
    passwordhash?: string | null
    roleid?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    activitylog?: ActivityLogUncheckedCreateNestedManyWithoutUsersInput
    admin?: AdminUncheckedCreateNestedOneWithoutUsersInput
    alert?: AlertUncheckedCreateNestedManyWithoutUsersInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUsersInput
    manufacturer?: ManufacturerUncheckedCreateNestedOneWithoutUsersInput
    otp?: OtpUncheckedCreateNestedManyWithoutUsersInput
    patient?: PatientUncheckedCreateNestedOneWithoutUsersInput
    pharmacist?: PharmacistUncheckedCreateNestedOneWithoutUsersInput
    regulator?: RegulatorUncheckedCreateNestedOneWithoutUsersInput
    reports?: ReportUncheckedCreateNestedManyWithoutUsersInput
    revocationrecord?: RevocationRecordUncheckedCreateNestedManyWithoutUsersInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUncheckedCreateNestedManyWithoutUsers_supplychainrecord_fromentityidTousersInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUncheckedCreateNestedManyWithoutUsers_supplychainrecord_toentityidTousersInput
  }

  export type UserCreateOrConnectWithoutDistributorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDistributorInput, UserUncheckedCreateWithoutDistributorInput>
  }

  export type UserUpsertWithoutDistributorInput = {
    update: XOR<UserUpdateWithoutDistributorInput, UserUncheckedUpdateWithoutDistributorInput>
    create: XOR<UserCreateWithoutDistributorInput, UserUncheckedCreateWithoutDistributorInput>
  }

  export type UserUpdateWithoutDistributorInput = {
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: ActivityLogUpdateManyWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUsersNestedInput
    alert?: AlertUpdateManyWithoutUsersNestedInput
    doctor?: DoctorUpdateOneWithoutUsersNestedInput
    manufacturer?: ManufacturerUpdateOneWithoutUsersNestedInput
    otp?: OtpUpdateManyWithoutUsersNestedInput
    patient?: PatientUpdateOneWithoutUsersNestedInput
    pharmacist?: PharmacistUpdateOneWithoutUsersNestedInput
    regulator?: RegulatorUpdateOneWithoutUsersNestedInput
    reports?: ReportUpdateManyWithoutUsersNestedInput
    revocationrecord?: RevocationRecordUpdateManyWithoutUsersNestedInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUpdateManyWithoutUsers_supplychainrecord_fromentityidTousersNestedInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUpdateManyWithoutUsers_supplychainrecord_toentityidTousersNestedInput
    roles?: RoleUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutDistributorInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    roleid?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: ActivityLogUncheckedUpdateManyWithoutUsersNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUsersNestedInput
    alert?: AlertUncheckedUpdateManyWithoutUsersNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUsersNestedInput
    manufacturer?: ManufacturerUncheckedUpdateOneWithoutUsersNestedInput
    otp?: OtpUncheckedUpdateManyWithoutUsersNestedInput
    patient?: PatientUncheckedUpdateOneWithoutUsersNestedInput
    pharmacist?: PharmacistUncheckedUpdateOneWithoutUsersNestedInput
    regulator?: RegulatorUncheckedUpdateOneWithoutUsersNestedInput
    reports?: ReportUncheckedUpdateManyWithoutUsersNestedInput
    revocationrecord?: RevocationRecordUncheckedUpdateManyWithoutUsersNestedInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUncheckedUpdateManyWithoutUsers_supplychainrecord_fromentityidTousersNestedInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUncheckedUpdateManyWithoutUsers_supplychainrecord_toentityidTousersNestedInput
  }

  export type UserCreateWithoutRegulatorInput = {
    wallet: string
    email?: string | null
    passwordhash?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    activitylog?: ActivityLogCreateNestedManyWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUsersInput
    alert?: AlertCreateNestedManyWithoutUsersInput
    distributor?: DistributorCreateNestedOneWithoutUsersInput
    doctor?: DoctorCreateNestedOneWithoutUsersInput
    manufacturer?: ManufacturerCreateNestedOneWithoutUsersInput
    otp?: OtpCreateNestedManyWithoutUsersInput
    patient?: PatientCreateNestedOneWithoutUsersInput
    pharmacist?: PharmacistCreateNestedOneWithoutUsersInput
    reports?: ReportCreateNestedManyWithoutUsersInput
    revocationrecord?: RevocationRecordCreateNestedManyWithoutUsersInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordCreateNestedManyWithoutUsers_supplychainrecord_fromentityidTousersInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordCreateNestedManyWithoutUsers_supplychainrecord_toentityidTousersInput
    roles?: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutRegulatorInput = {
    id?: number
    wallet: string
    email?: string | null
    passwordhash?: string | null
    roleid?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    activitylog?: ActivityLogUncheckedCreateNestedManyWithoutUsersInput
    admin?: AdminUncheckedCreateNestedOneWithoutUsersInput
    alert?: AlertUncheckedCreateNestedManyWithoutUsersInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUsersInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUsersInput
    manufacturer?: ManufacturerUncheckedCreateNestedOneWithoutUsersInput
    otp?: OtpUncheckedCreateNestedManyWithoutUsersInput
    patient?: PatientUncheckedCreateNestedOneWithoutUsersInput
    pharmacist?: PharmacistUncheckedCreateNestedOneWithoutUsersInput
    reports?: ReportUncheckedCreateNestedManyWithoutUsersInput
    revocationrecord?: RevocationRecordUncheckedCreateNestedManyWithoutUsersInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUncheckedCreateNestedManyWithoutUsers_supplychainrecord_fromentityidTousersInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUncheckedCreateNestedManyWithoutUsers_supplychainrecord_toentityidTousersInput
  }

  export type UserCreateOrConnectWithoutRegulatorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRegulatorInput, UserUncheckedCreateWithoutRegulatorInput>
  }

  export type UserUpsertWithoutRegulatorInput = {
    update: XOR<UserUpdateWithoutRegulatorInput, UserUncheckedUpdateWithoutRegulatorInput>
    create: XOR<UserCreateWithoutRegulatorInput, UserUncheckedCreateWithoutRegulatorInput>
  }

  export type UserUpdateWithoutRegulatorInput = {
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: ActivityLogUpdateManyWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUsersNestedInput
    alert?: AlertUpdateManyWithoutUsersNestedInput
    distributor?: DistributorUpdateOneWithoutUsersNestedInput
    doctor?: DoctorUpdateOneWithoutUsersNestedInput
    manufacturer?: ManufacturerUpdateOneWithoutUsersNestedInput
    otp?: OtpUpdateManyWithoutUsersNestedInput
    patient?: PatientUpdateOneWithoutUsersNestedInput
    pharmacist?: PharmacistUpdateOneWithoutUsersNestedInput
    reports?: ReportUpdateManyWithoutUsersNestedInput
    revocationrecord?: RevocationRecordUpdateManyWithoutUsersNestedInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUpdateManyWithoutUsers_supplychainrecord_fromentityidTousersNestedInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUpdateManyWithoutUsers_supplychainrecord_toentityidTousersNestedInput
    roles?: RoleUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutRegulatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    roleid?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: ActivityLogUncheckedUpdateManyWithoutUsersNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUsersNestedInput
    alert?: AlertUncheckedUpdateManyWithoutUsersNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUsersNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUsersNestedInput
    manufacturer?: ManufacturerUncheckedUpdateOneWithoutUsersNestedInput
    otp?: OtpUncheckedUpdateManyWithoutUsersNestedInput
    patient?: PatientUncheckedUpdateOneWithoutUsersNestedInput
    pharmacist?: PharmacistUncheckedUpdateOneWithoutUsersNestedInput
    reports?: ReportUncheckedUpdateManyWithoutUsersNestedInput
    revocationrecord?: RevocationRecordUncheckedUpdateManyWithoutUsersNestedInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUncheckedUpdateManyWithoutUsers_supplychainrecord_fromentityidTousersNestedInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUncheckedUpdateManyWithoutUsers_supplychainrecord_toentityidTousersNestedInput
  }

  export type UserCreateWithoutAdminInput = {
    wallet: string
    email?: string | null
    passwordhash?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    activitylog?: ActivityLogCreateNestedManyWithoutUsersInput
    alert?: AlertCreateNestedManyWithoutUsersInput
    distributor?: DistributorCreateNestedOneWithoutUsersInput
    doctor?: DoctorCreateNestedOneWithoutUsersInput
    manufacturer?: ManufacturerCreateNestedOneWithoutUsersInput
    otp?: OtpCreateNestedManyWithoutUsersInput
    patient?: PatientCreateNestedOneWithoutUsersInput
    pharmacist?: PharmacistCreateNestedOneWithoutUsersInput
    regulator?: RegulatorCreateNestedOneWithoutUsersInput
    reports?: ReportCreateNestedManyWithoutUsersInput
    revocationrecord?: RevocationRecordCreateNestedManyWithoutUsersInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordCreateNestedManyWithoutUsers_supplychainrecord_fromentityidTousersInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordCreateNestedManyWithoutUsers_supplychainrecord_toentityidTousersInput
    roles?: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutAdminInput = {
    id?: number
    wallet: string
    email?: string | null
    passwordhash?: string | null
    roleid?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    activitylog?: ActivityLogUncheckedCreateNestedManyWithoutUsersInput
    alert?: AlertUncheckedCreateNestedManyWithoutUsersInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUsersInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUsersInput
    manufacturer?: ManufacturerUncheckedCreateNestedOneWithoutUsersInput
    otp?: OtpUncheckedCreateNestedManyWithoutUsersInput
    patient?: PatientUncheckedCreateNestedOneWithoutUsersInput
    pharmacist?: PharmacistUncheckedCreateNestedOneWithoutUsersInput
    regulator?: RegulatorUncheckedCreateNestedOneWithoutUsersInput
    reports?: ReportUncheckedCreateNestedManyWithoutUsersInput
    revocationrecord?: RevocationRecordUncheckedCreateNestedManyWithoutUsersInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUncheckedCreateNestedManyWithoutUsers_supplychainrecord_fromentityidTousersInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUncheckedCreateNestedManyWithoutUsers_supplychainrecord_toentityidTousersInput
  }

  export type UserCreateOrConnectWithoutAdminInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
  }

  export type UserUpsertWithoutAdminInput = {
    update: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
  }

  export type UserUpdateWithoutAdminInput = {
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: ActivityLogUpdateManyWithoutUsersNestedInput
    alert?: AlertUpdateManyWithoutUsersNestedInput
    distributor?: DistributorUpdateOneWithoutUsersNestedInput
    doctor?: DoctorUpdateOneWithoutUsersNestedInput
    manufacturer?: ManufacturerUpdateOneWithoutUsersNestedInput
    otp?: OtpUpdateManyWithoutUsersNestedInput
    patient?: PatientUpdateOneWithoutUsersNestedInput
    pharmacist?: PharmacistUpdateOneWithoutUsersNestedInput
    regulator?: RegulatorUpdateOneWithoutUsersNestedInput
    reports?: ReportUpdateManyWithoutUsersNestedInput
    revocationrecord?: RevocationRecordUpdateManyWithoutUsersNestedInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUpdateManyWithoutUsers_supplychainrecord_fromentityidTousersNestedInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUpdateManyWithoutUsers_supplychainrecord_toentityidTousersNestedInput
    roles?: RoleUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    roleid?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: ActivityLogUncheckedUpdateManyWithoutUsersNestedInput
    alert?: AlertUncheckedUpdateManyWithoutUsersNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUsersNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUsersNestedInput
    manufacturer?: ManufacturerUncheckedUpdateOneWithoutUsersNestedInput
    otp?: OtpUncheckedUpdateManyWithoutUsersNestedInput
    patient?: PatientUncheckedUpdateOneWithoutUsersNestedInput
    pharmacist?: PharmacistUncheckedUpdateOneWithoutUsersNestedInput
    regulator?: RegulatorUncheckedUpdateOneWithoutUsersNestedInput
    reports?: ReportUncheckedUpdateManyWithoutUsersNestedInput
    revocationrecord?: RevocationRecordUncheckedUpdateManyWithoutUsersNestedInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUncheckedUpdateManyWithoutUsers_supplychainrecord_fromentityidTousersNestedInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUncheckedUpdateManyWithoutUsers_supplychainrecord_toentityidTousersNestedInput
  }

  export type DrugBatchCreateWithoutDrugInput = {
    batchnumber: string
    manufacturedate: Date | string
    expirydate: Date | string
    blockchaintx?: string | null
    qrcode: string
    ipfshash?: string | null
    blockchaineventlog?: BlockchainEventLogCreateNestedManyWithoutDrugbatchInput
    dispenserecord?: DispenseRecordCreateNestedManyWithoutDrugbatchInput
    manufacturer?: ManufacturerCreateNestedOneWithoutDrugbatchInput
    supplychainrecord?: SupplyChainRecordCreateNestedManyWithoutDrugbatchInput
  }

  export type DrugBatchUncheckedCreateWithoutDrugInput = {
    id?: number
    manufacturerid?: number | null
    batchnumber: string
    manufacturedate: Date | string
    expirydate: Date | string
    blockchaintx?: string | null
    qrcode: string
    ipfshash?: string | null
    blockchaineventlog?: BlockchainEventLogUncheckedCreateNestedManyWithoutDrugbatchInput
    dispenserecord?: DispenseRecordUncheckedCreateNestedManyWithoutDrugbatchInput
    supplychainrecord?: SupplyChainRecordUncheckedCreateNestedManyWithoutDrugbatchInput
  }

  export type DrugBatchCreateOrConnectWithoutDrugInput = {
    where: DrugBatchWhereUniqueInput
    create: XOR<DrugBatchCreateWithoutDrugInput, DrugBatchUncheckedCreateWithoutDrugInput>
  }

  export type DrugBatchCreateManyDrugInputEnvelope = {
    data: Enumerable<DrugBatchCreateManyDrugInput>
    skipDuplicates?: boolean
  }

  export type PrescriptionCreateWithoutDrugInput = {
    dosage: string
    issuedat?: Date | string | null
    expiresat: Date | string
    blockchaintx?: string | null
    qrcode: string
    ipfshash?: string | null
    status: string
    blockchaineventlog?: BlockchainEventLogCreateNestedManyWithoutPrescriptionInput
    dispenserecord?: DispenseRecordCreateNestedManyWithoutPrescriptionInput
    doctor?: DoctorCreateNestedOneWithoutPrescriptionInput
    patient?: PatientCreateNestedOneWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutDrugInput = {
    id?: number
    patientid?: number | null
    doctorid?: number | null
    dosage: string
    issuedat?: Date | string | null
    expiresat: Date | string
    blockchaintx?: string | null
    qrcode: string
    ipfshash?: string | null
    status: string
    blockchaineventlog?: BlockchainEventLogUncheckedCreateNestedManyWithoutPrescriptionInput
    dispenserecord?: DispenseRecordUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionCreateOrConnectWithoutDrugInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutDrugInput, PrescriptionUncheckedCreateWithoutDrugInput>
  }

  export type PrescriptionCreateManyDrugInputEnvelope = {
    data: Enumerable<PrescriptionCreateManyDrugInput>
    skipDuplicates?: boolean
  }

  export type DrugBatchUpsertWithWhereUniqueWithoutDrugInput = {
    where: DrugBatchWhereUniqueInput
    update: XOR<DrugBatchUpdateWithoutDrugInput, DrugBatchUncheckedUpdateWithoutDrugInput>
    create: XOR<DrugBatchCreateWithoutDrugInput, DrugBatchUncheckedCreateWithoutDrugInput>
  }

  export type DrugBatchUpdateWithWhereUniqueWithoutDrugInput = {
    where: DrugBatchWhereUniqueInput
    data: XOR<DrugBatchUpdateWithoutDrugInput, DrugBatchUncheckedUpdateWithoutDrugInput>
  }

  export type DrugBatchUpdateManyWithWhereWithoutDrugInput = {
    where: DrugBatchScalarWhereInput
    data: XOR<DrugBatchUpdateManyMutationInput, DrugBatchUncheckedUpdateManyWithoutDrugbatchInput>
  }

  export type PrescriptionUpsertWithWhereUniqueWithoutDrugInput = {
    where: PrescriptionWhereUniqueInput
    update: XOR<PrescriptionUpdateWithoutDrugInput, PrescriptionUncheckedUpdateWithoutDrugInput>
    create: XOR<PrescriptionCreateWithoutDrugInput, PrescriptionUncheckedCreateWithoutDrugInput>
  }

  export type PrescriptionUpdateWithWhereUniqueWithoutDrugInput = {
    where: PrescriptionWhereUniqueInput
    data: XOR<PrescriptionUpdateWithoutDrugInput, PrescriptionUncheckedUpdateWithoutDrugInput>
  }

  export type PrescriptionUpdateManyWithWhereWithoutDrugInput = {
    where: PrescriptionScalarWhereInput
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyWithoutPrescriptionInput>
  }

  export type BlockchainEventLogCreateWithoutPrescriptionInput = {
    eventname: string
    contractname: string
    entitytype?: string | null
    transactionhash: string
    timestamp?: Date | string | null
    processed?: boolean | null
    drugbatch?: DrugBatchCreateNestedOneWithoutBlockchaineventlogInput
    supplychainrecord?: SupplyChainRecordCreateNestedOneWithoutBlockchaineventlogInput
  }

  export type BlockchainEventLogUncheckedCreateWithoutPrescriptionInput = {
    id?: number
    eventname: string
    contractname: string
    entitytype?: string | null
    transactionhash: string
    timestamp?: Date | string | null
    processed?: boolean | null
  }

  export type BlockchainEventLogCreateOrConnectWithoutPrescriptionInput = {
    where: BlockchainEventLogWhereUniqueInput
    create: XOR<BlockchainEventLogCreateWithoutPrescriptionInput, BlockchainEventLogUncheckedCreateWithoutPrescriptionInput>
  }

  export type BlockchainEventLogCreateManyPrescriptionInputEnvelope = {
    data: Enumerable<BlockchainEventLogCreateManyPrescriptionInput>
    skipDuplicates?: boolean
  }

  export type DispenseRecordCreateWithoutPrescriptionInput = {
    quantity: number
    dispensedat?: Date | string | null
    blockchaintx?: string | null
    drugbatch?: DrugBatchCreateNestedOneWithoutDispenserecordInput
    pharmacist?: PharmacistCreateNestedOneWithoutDispenserecordInput
  }

  export type DispenseRecordUncheckedCreateWithoutPrescriptionInput = {
    id?: number
    pharmacistid?: number | null
    drugbatchid?: number | null
    quantity: number
    dispensedat?: Date | string | null
    blockchaintx?: string | null
  }

  export type DispenseRecordCreateOrConnectWithoutPrescriptionInput = {
    where: DispenseRecordWhereUniqueInput
    create: XOR<DispenseRecordCreateWithoutPrescriptionInput, DispenseRecordUncheckedCreateWithoutPrescriptionInput>
  }

  export type DispenseRecordCreateManyPrescriptionInputEnvelope = {
    data: Enumerable<DispenseRecordCreateManyPrescriptionInput>
    skipDuplicates?: boolean
  }

  export type DoctorCreateWithoutPrescriptionInput = {
    licenseno: string
    hospital: string
    users?: UserCreateNestedOneWithoutDoctorInput
  }

  export type DoctorUncheckedCreateWithoutPrescriptionInput = {
    id?: number
    userid?: number | null
    licenseno: string
    hospital: string
  }

  export type DoctorCreateOrConnectWithoutPrescriptionInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutPrescriptionInput, DoctorUncheckedCreateWithoutPrescriptionInput>
  }

  export type DrugCreateWithoutPrescriptionInput = {
    name: string
    code: string
    formulation: string
    dosageunit: string
    drugbatch?: DrugBatchCreateNestedManyWithoutDrugInput
  }

  export type DrugUncheckedCreateWithoutPrescriptionInput = {
    id?: number
    name: string
    code: string
    formulation: string
    dosageunit: string
    drugbatch?: DrugBatchUncheckedCreateNestedManyWithoutDrugInput
  }

  export type DrugCreateOrConnectWithoutPrescriptionInput = {
    where: DrugWhereUniqueInput
    create: XOR<DrugCreateWithoutPrescriptionInput, DrugUncheckedCreateWithoutPrescriptionInput>
  }

  export type PatientCreateWithoutPrescriptionInput = {
    dateofbirth: Date | string
    users?: UserCreateNestedOneWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutPrescriptionInput = {
    id?: number
    userid?: number | null
    dateofbirth: Date | string
  }

  export type PatientCreateOrConnectWithoutPrescriptionInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutPrescriptionInput, PatientUncheckedCreateWithoutPrescriptionInput>
  }

  export type BlockchainEventLogUpsertWithWhereUniqueWithoutPrescriptionInput = {
    where: BlockchainEventLogWhereUniqueInput
    update: XOR<BlockchainEventLogUpdateWithoutPrescriptionInput, BlockchainEventLogUncheckedUpdateWithoutPrescriptionInput>
    create: XOR<BlockchainEventLogCreateWithoutPrescriptionInput, BlockchainEventLogUncheckedCreateWithoutPrescriptionInput>
  }

  export type BlockchainEventLogUpdateWithWhereUniqueWithoutPrescriptionInput = {
    where: BlockchainEventLogWhereUniqueInput
    data: XOR<BlockchainEventLogUpdateWithoutPrescriptionInput, BlockchainEventLogUncheckedUpdateWithoutPrescriptionInput>
  }

  export type BlockchainEventLogUpdateManyWithWhereWithoutPrescriptionInput = {
    where: BlockchainEventLogScalarWhereInput
    data: XOR<BlockchainEventLogUpdateManyMutationInput, BlockchainEventLogUncheckedUpdateManyWithoutBlockchaineventlogInput>
  }

  export type BlockchainEventLogScalarWhereInput = {
    AND?: Enumerable<BlockchainEventLogScalarWhereInput>
    OR?: Enumerable<BlockchainEventLogScalarWhereInput>
    NOT?: Enumerable<BlockchainEventLogScalarWhereInput>
    id?: IntFilter | number
    eventname?: StringFilter | string
    contractname?: StringFilter | string
    entityid?: IntNullableFilter | number | null
    entitytype?: StringNullableFilter | string | null
    transactionhash?: StringFilter | string
    timestamp?: DateTimeNullableFilter | Date | string | null
    processed?: BoolNullableFilter | boolean | null
  }

  export type DispenseRecordUpsertWithWhereUniqueWithoutPrescriptionInput = {
    where: DispenseRecordWhereUniqueInput
    update: XOR<DispenseRecordUpdateWithoutPrescriptionInput, DispenseRecordUncheckedUpdateWithoutPrescriptionInput>
    create: XOR<DispenseRecordCreateWithoutPrescriptionInput, DispenseRecordUncheckedCreateWithoutPrescriptionInput>
  }

  export type DispenseRecordUpdateWithWhereUniqueWithoutPrescriptionInput = {
    where: DispenseRecordWhereUniqueInput
    data: XOR<DispenseRecordUpdateWithoutPrescriptionInput, DispenseRecordUncheckedUpdateWithoutPrescriptionInput>
  }

  export type DispenseRecordUpdateManyWithWhereWithoutPrescriptionInput = {
    where: DispenseRecordScalarWhereInput
    data: XOR<DispenseRecordUpdateManyMutationInput, DispenseRecordUncheckedUpdateManyWithoutDispenserecordInput>
  }

  export type DoctorUpsertWithoutPrescriptionInput = {
    update: XOR<DoctorUpdateWithoutPrescriptionInput, DoctorUncheckedUpdateWithoutPrescriptionInput>
    create: XOR<DoctorCreateWithoutPrescriptionInput, DoctorUncheckedCreateWithoutPrescriptionInput>
  }

  export type DoctorUpdateWithoutPrescriptionInput = {
    licenseno?: StringFieldUpdateOperationsInput | string
    hospital?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateOneWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateWithoutPrescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    licenseno?: StringFieldUpdateOperationsInput | string
    hospital?: StringFieldUpdateOperationsInput | string
  }

  export type DrugUpsertWithoutPrescriptionInput = {
    update: XOR<DrugUpdateWithoutPrescriptionInput, DrugUncheckedUpdateWithoutPrescriptionInput>
    create: XOR<DrugCreateWithoutPrescriptionInput, DrugUncheckedCreateWithoutPrescriptionInput>
  }

  export type DrugUpdateWithoutPrescriptionInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    formulation?: StringFieldUpdateOperationsInput | string
    dosageunit?: StringFieldUpdateOperationsInput | string
    drugbatch?: DrugBatchUpdateManyWithoutDrugNestedInput
  }

  export type DrugUncheckedUpdateWithoutPrescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    formulation?: StringFieldUpdateOperationsInput | string
    dosageunit?: StringFieldUpdateOperationsInput | string
    drugbatch?: DrugBatchUncheckedUpdateManyWithoutDrugNestedInput
  }

  export type PatientUpsertWithoutPrescriptionInput = {
    update: XOR<PatientUpdateWithoutPrescriptionInput, PatientUncheckedUpdateWithoutPrescriptionInput>
    create: XOR<PatientCreateWithoutPrescriptionInput, PatientUncheckedCreateWithoutPrescriptionInput>
  }

  export type PatientUpdateWithoutPrescriptionInput = {
    dateofbirth?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateOneWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutPrescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    dateofbirth?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockchainEventLogCreateWithoutDrugbatchInput = {
    eventname: string
    contractname: string
    entitytype?: string | null
    transactionhash: string
    timestamp?: Date | string | null
    processed?: boolean | null
    prescription?: PrescriptionCreateNestedOneWithoutBlockchaineventlogInput
    supplychainrecord?: SupplyChainRecordCreateNestedOneWithoutBlockchaineventlogInput
  }

  export type BlockchainEventLogUncheckedCreateWithoutDrugbatchInput = {
    id?: number
    eventname: string
    contractname: string
    entitytype?: string | null
    transactionhash: string
    timestamp?: Date | string | null
    processed?: boolean | null
  }

  export type BlockchainEventLogCreateOrConnectWithoutDrugbatchInput = {
    where: BlockchainEventLogWhereUniqueInput
    create: XOR<BlockchainEventLogCreateWithoutDrugbatchInput, BlockchainEventLogUncheckedCreateWithoutDrugbatchInput>
  }

  export type BlockchainEventLogCreateManyDrugbatchInputEnvelope = {
    data: Enumerable<BlockchainEventLogCreateManyDrugbatchInput>
    skipDuplicates?: boolean
  }

  export type DispenseRecordCreateWithoutDrugbatchInput = {
    quantity: number
    dispensedat?: Date | string | null
    blockchaintx?: string | null
    pharmacist?: PharmacistCreateNestedOneWithoutDispenserecordInput
    prescription?: PrescriptionCreateNestedOneWithoutDispenserecordInput
  }

  export type DispenseRecordUncheckedCreateWithoutDrugbatchInput = {
    id?: number
    prescriptionid?: number | null
    pharmacistid?: number | null
    quantity: number
    dispensedat?: Date | string | null
    blockchaintx?: string | null
  }

  export type DispenseRecordCreateOrConnectWithoutDrugbatchInput = {
    where: DispenseRecordWhereUniqueInput
    create: XOR<DispenseRecordCreateWithoutDrugbatchInput, DispenseRecordUncheckedCreateWithoutDrugbatchInput>
  }

  export type DispenseRecordCreateManyDrugbatchInputEnvelope = {
    data: Enumerable<DispenseRecordCreateManyDrugbatchInput>
    skipDuplicates?: boolean
  }

  export type DrugCreateWithoutDrugbatchInput = {
    name: string
    code: string
    formulation: string
    dosageunit: string
    prescription?: PrescriptionCreateNestedManyWithoutDrugInput
  }

  export type DrugUncheckedCreateWithoutDrugbatchInput = {
    id?: number
    name: string
    code: string
    formulation: string
    dosageunit: string
    prescription?: PrescriptionUncheckedCreateNestedManyWithoutDrugInput
  }

  export type DrugCreateOrConnectWithoutDrugbatchInput = {
    where: DrugWhereUniqueInput
    create: XOR<DrugCreateWithoutDrugbatchInput, DrugUncheckedCreateWithoutDrugbatchInput>
  }

  export type ManufacturerCreateWithoutDrugbatchInput = {
    companyname: string
    users?: UserCreateNestedOneWithoutManufacturerInput
  }

  export type ManufacturerUncheckedCreateWithoutDrugbatchInput = {
    id?: number
    userid?: number | null
    companyname: string
  }

  export type ManufacturerCreateOrConnectWithoutDrugbatchInput = {
    where: ManufacturerWhereUniqueInput
    create: XOR<ManufacturerCreateWithoutDrugbatchInput, ManufacturerUncheckedCreateWithoutDrugbatchInput>
  }

  export type SupplyChainRecordCreateWithoutDrugbatchInput = {
    action: string
    timestamp?: Date | string | null
    blockchaintx?: string | null
    blockchaineventlog?: BlockchainEventLogCreateNestedManyWithoutSupplychainrecordInput
    users_supplychainrecord_fromentityidTousers?: UserCreateNestedOneWithoutSupplychainrecord_supplychainrecord_fromentityidTousersInput
    users_supplychainrecord_toentityidTousers?: UserCreateNestedOneWithoutSupplychainrecord_supplychainrecord_toentityidTousersInput
  }

  export type SupplyChainRecordUncheckedCreateWithoutDrugbatchInput = {
    id?: number
    fromentityid?: number | null
    toentityid?: number | null
    action: string
    timestamp?: Date | string | null
    blockchaintx?: string | null
    blockchaineventlog?: BlockchainEventLogUncheckedCreateNestedManyWithoutSupplychainrecordInput
  }

  export type SupplyChainRecordCreateOrConnectWithoutDrugbatchInput = {
    where: SupplyChainRecordWhereUniqueInput
    create: XOR<SupplyChainRecordCreateWithoutDrugbatchInput, SupplyChainRecordUncheckedCreateWithoutDrugbatchInput>
  }

  export type SupplyChainRecordCreateManyDrugbatchInputEnvelope = {
    data: Enumerable<SupplyChainRecordCreateManyDrugbatchInput>
    skipDuplicates?: boolean
  }

  export type BlockchainEventLogUpsertWithWhereUniqueWithoutDrugbatchInput = {
    where: BlockchainEventLogWhereUniqueInput
    update: XOR<BlockchainEventLogUpdateWithoutDrugbatchInput, BlockchainEventLogUncheckedUpdateWithoutDrugbatchInput>
    create: XOR<BlockchainEventLogCreateWithoutDrugbatchInput, BlockchainEventLogUncheckedCreateWithoutDrugbatchInput>
  }

  export type BlockchainEventLogUpdateWithWhereUniqueWithoutDrugbatchInput = {
    where: BlockchainEventLogWhereUniqueInput
    data: XOR<BlockchainEventLogUpdateWithoutDrugbatchInput, BlockchainEventLogUncheckedUpdateWithoutDrugbatchInput>
  }

  export type BlockchainEventLogUpdateManyWithWhereWithoutDrugbatchInput = {
    where: BlockchainEventLogScalarWhereInput
    data: XOR<BlockchainEventLogUpdateManyMutationInput, BlockchainEventLogUncheckedUpdateManyWithoutBlockchaineventlogInput>
  }

  export type DispenseRecordUpsertWithWhereUniqueWithoutDrugbatchInput = {
    where: DispenseRecordWhereUniqueInput
    update: XOR<DispenseRecordUpdateWithoutDrugbatchInput, DispenseRecordUncheckedUpdateWithoutDrugbatchInput>
    create: XOR<DispenseRecordCreateWithoutDrugbatchInput, DispenseRecordUncheckedCreateWithoutDrugbatchInput>
  }

  export type DispenseRecordUpdateWithWhereUniqueWithoutDrugbatchInput = {
    where: DispenseRecordWhereUniqueInput
    data: XOR<DispenseRecordUpdateWithoutDrugbatchInput, DispenseRecordUncheckedUpdateWithoutDrugbatchInput>
  }

  export type DispenseRecordUpdateManyWithWhereWithoutDrugbatchInput = {
    where: DispenseRecordScalarWhereInput
    data: XOR<DispenseRecordUpdateManyMutationInput, DispenseRecordUncheckedUpdateManyWithoutDispenserecordInput>
  }

  export type DrugUpsertWithoutDrugbatchInput = {
    update: XOR<DrugUpdateWithoutDrugbatchInput, DrugUncheckedUpdateWithoutDrugbatchInput>
    create: XOR<DrugCreateWithoutDrugbatchInput, DrugUncheckedCreateWithoutDrugbatchInput>
  }

  export type DrugUpdateWithoutDrugbatchInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    formulation?: StringFieldUpdateOperationsInput | string
    dosageunit?: StringFieldUpdateOperationsInput | string
    prescription?: PrescriptionUpdateManyWithoutDrugNestedInput
  }

  export type DrugUncheckedUpdateWithoutDrugbatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    formulation?: StringFieldUpdateOperationsInput | string
    dosageunit?: StringFieldUpdateOperationsInput | string
    prescription?: PrescriptionUncheckedUpdateManyWithoutDrugNestedInput
  }

  export type ManufacturerUpsertWithoutDrugbatchInput = {
    update: XOR<ManufacturerUpdateWithoutDrugbatchInput, ManufacturerUncheckedUpdateWithoutDrugbatchInput>
    create: XOR<ManufacturerCreateWithoutDrugbatchInput, ManufacturerUncheckedCreateWithoutDrugbatchInput>
  }

  export type ManufacturerUpdateWithoutDrugbatchInput = {
    companyname?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateOneWithoutManufacturerNestedInput
  }

  export type ManufacturerUncheckedUpdateWithoutDrugbatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    companyname?: StringFieldUpdateOperationsInput | string
  }

  export type SupplyChainRecordUpsertWithWhereUniqueWithoutDrugbatchInput = {
    where: SupplyChainRecordWhereUniqueInput
    update: XOR<SupplyChainRecordUpdateWithoutDrugbatchInput, SupplyChainRecordUncheckedUpdateWithoutDrugbatchInput>
    create: XOR<SupplyChainRecordCreateWithoutDrugbatchInput, SupplyChainRecordUncheckedCreateWithoutDrugbatchInput>
  }

  export type SupplyChainRecordUpdateWithWhereUniqueWithoutDrugbatchInput = {
    where: SupplyChainRecordWhereUniqueInput
    data: XOR<SupplyChainRecordUpdateWithoutDrugbatchInput, SupplyChainRecordUncheckedUpdateWithoutDrugbatchInput>
  }

  export type SupplyChainRecordUpdateManyWithWhereWithoutDrugbatchInput = {
    where: SupplyChainRecordScalarWhereInput
    data: XOR<SupplyChainRecordUpdateManyMutationInput, SupplyChainRecordUncheckedUpdateManyWithoutSupplychainrecordInput>
  }

  export type BlockchainEventLogCreateWithoutSupplychainrecordInput = {
    eventname: string
    contractname: string
    entitytype?: string | null
    transactionhash: string
    timestamp?: Date | string | null
    processed?: boolean | null
    drugbatch?: DrugBatchCreateNestedOneWithoutBlockchaineventlogInput
    prescription?: PrescriptionCreateNestedOneWithoutBlockchaineventlogInput
  }

  export type BlockchainEventLogUncheckedCreateWithoutSupplychainrecordInput = {
    id?: number
    eventname: string
    contractname: string
    entitytype?: string | null
    transactionhash: string
    timestamp?: Date | string | null
    processed?: boolean | null
  }

  export type BlockchainEventLogCreateOrConnectWithoutSupplychainrecordInput = {
    where: BlockchainEventLogWhereUniqueInput
    create: XOR<BlockchainEventLogCreateWithoutSupplychainrecordInput, BlockchainEventLogUncheckedCreateWithoutSupplychainrecordInput>
  }

  export type BlockchainEventLogCreateManySupplychainrecordInputEnvelope = {
    data: Enumerable<BlockchainEventLogCreateManySupplychainrecordInput>
    skipDuplicates?: boolean
  }

  export type DrugBatchCreateWithoutSupplychainrecordInput = {
    batchnumber: string
    manufacturedate: Date | string
    expirydate: Date | string
    blockchaintx?: string | null
    qrcode: string
    ipfshash?: string | null
    blockchaineventlog?: BlockchainEventLogCreateNestedManyWithoutDrugbatchInput
    dispenserecord?: DispenseRecordCreateNestedManyWithoutDrugbatchInput
    drug?: DrugCreateNestedOneWithoutDrugbatchInput
    manufacturer?: ManufacturerCreateNestedOneWithoutDrugbatchInput
  }

  export type DrugBatchUncheckedCreateWithoutSupplychainrecordInput = {
    id?: number
    manufacturerid?: number | null
    drugid?: number | null
    batchnumber: string
    manufacturedate: Date | string
    expirydate: Date | string
    blockchaintx?: string | null
    qrcode: string
    ipfshash?: string | null
    blockchaineventlog?: BlockchainEventLogUncheckedCreateNestedManyWithoutDrugbatchInput
    dispenserecord?: DispenseRecordUncheckedCreateNestedManyWithoutDrugbatchInput
  }

  export type DrugBatchCreateOrConnectWithoutSupplychainrecordInput = {
    where: DrugBatchWhereUniqueInput
    create: XOR<DrugBatchCreateWithoutSupplychainrecordInput, DrugBatchUncheckedCreateWithoutSupplychainrecordInput>
  }

  export type UserCreateWithoutSupplychainrecord_supplychainrecord_fromentityidTousersInput = {
    wallet: string
    email?: string | null
    passwordhash?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    activitylog?: ActivityLogCreateNestedManyWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUsersInput
    alert?: AlertCreateNestedManyWithoutUsersInput
    distributor?: DistributorCreateNestedOneWithoutUsersInput
    doctor?: DoctorCreateNestedOneWithoutUsersInput
    manufacturer?: ManufacturerCreateNestedOneWithoutUsersInput
    otp?: OtpCreateNestedManyWithoutUsersInput
    patient?: PatientCreateNestedOneWithoutUsersInput
    pharmacist?: PharmacistCreateNestedOneWithoutUsersInput
    regulator?: RegulatorCreateNestedOneWithoutUsersInput
    reports?: ReportCreateNestedManyWithoutUsersInput
    revocationrecord?: RevocationRecordCreateNestedManyWithoutUsersInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordCreateNestedManyWithoutUsers_supplychainrecord_toentityidTousersInput
    roles?: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutSupplychainrecord_supplychainrecord_fromentityidTousersInput = {
    id?: number
    wallet: string
    email?: string | null
    passwordhash?: string | null
    roleid?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    activitylog?: ActivityLogUncheckedCreateNestedManyWithoutUsersInput
    admin?: AdminUncheckedCreateNestedOneWithoutUsersInput
    alert?: AlertUncheckedCreateNestedManyWithoutUsersInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUsersInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUsersInput
    manufacturer?: ManufacturerUncheckedCreateNestedOneWithoutUsersInput
    otp?: OtpUncheckedCreateNestedManyWithoutUsersInput
    patient?: PatientUncheckedCreateNestedOneWithoutUsersInput
    pharmacist?: PharmacistUncheckedCreateNestedOneWithoutUsersInput
    regulator?: RegulatorUncheckedCreateNestedOneWithoutUsersInput
    reports?: ReportUncheckedCreateNestedManyWithoutUsersInput
    revocationrecord?: RevocationRecordUncheckedCreateNestedManyWithoutUsersInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUncheckedCreateNestedManyWithoutUsers_supplychainrecord_toentityidTousersInput
  }

  export type UserCreateOrConnectWithoutSupplychainrecord_supplychainrecord_fromentityidTousersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSupplychainrecord_supplychainrecord_fromentityidTousersInput, UserUncheckedCreateWithoutSupplychainrecord_supplychainrecord_fromentityidTousersInput>
  }

  export type UserCreateWithoutSupplychainrecord_supplychainrecord_toentityidTousersInput = {
    wallet: string
    email?: string | null
    passwordhash?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    activitylog?: ActivityLogCreateNestedManyWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUsersInput
    alert?: AlertCreateNestedManyWithoutUsersInput
    distributor?: DistributorCreateNestedOneWithoutUsersInput
    doctor?: DoctorCreateNestedOneWithoutUsersInput
    manufacturer?: ManufacturerCreateNestedOneWithoutUsersInput
    otp?: OtpCreateNestedManyWithoutUsersInput
    patient?: PatientCreateNestedOneWithoutUsersInput
    pharmacist?: PharmacistCreateNestedOneWithoutUsersInput
    regulator?: RegulatorCreateNestedOneWithoutUsersInput
    reports?: ReportCreateNestedManyWithoutUsersInput
    revocationrecord?: RevocationRecordCreateNestedManyWithoutUsersInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordCreateNestedManyWithoutUsers_supplychainrecord_fromentityidTousersInput
    roles?: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutSupplychainrecord_supplychainrecord_toentityidTousersInput = {
    id?: number
    wallet: string
    email?: string | null
    passwordhash?: string | null
    roleid?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    activitylog?: ActivityLogUncheckedCreateNestedManyWithoutUsersInput
    admin?: AdminUncheckedCreateNestedOneWithoutUsersInput
    alert?: AlertUncheckedCreateNestedManyWithoutUsersInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUsersInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUsersInput
    manufacturer?: ManufacturerUncheckedCreateNestedOneWithoutUsersInput
    otp?: OtpUncheckedCreateNestedManyWithoutUsersInput
    patient?: PatientUncheckedCreateNestedOneWithoutUsersInput
    pharmacist?: PharmacistUncheckedCreateNestedOneWithoutUsersInput
    regulator?: RegulatorUncheckedCreateNestedOneWithoutUsersInput
    reports?: ReportUncheckedCreateNestedManyWithoutUsersInput
    revocationrecord?: RevocationRecordUncheckedCreateNestedManyWithoutUsersInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUncheckedCreateNestedManyWithoutUsers_supplychainrecord_fromentityidTousersInput
  }

  export type UserCreateOrConnectWithoutSupplychainrecord_supplychainrecord_toentityidTousersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSupplychainrecord_supplychainrecord_toentityidTousersInput, UserUncheckedCreateWithoutSupplychainrecord_supplychainrecord_toentityidTousersInput>
  }

  export type BlockchainEventLogUpsertWithWhereUniqueWithoutSupplychainrecordInput = {
    where: BlockchainEventLogWhereUniqueInput
    update: XOR<BlockchainEventLogUpdateWithoutSupplychainrecordInput, BlockchainEventLogUncheckedUpdateWithoutSupplychainrecordInput>
    create: XOR<BlockchainEventLogCreateWithoutSupplychainrecordInput, BlockchainEventLogUncheckedCreateWithoutSupplychainrecordInput>
  }

  export type BlockchainEventLogUpdateWithWhereUniqueWithoutSupplychainrecordInput = {
    where: BlockchainEventLogWhereUniqueInput
    data: XOR<BlockchainEventLogUpdateWithoutSupplychainrecordInput, BlockchainEventLogUncheckedUpdateWithoutSupplychainrecordInput>
  }

  export type BlockchainEventLogUpdateManyWithWhereWithoutSupplychainrecordInput = {
    where: BlockchainEventLogScalarWhereInput
    data: XOR<BlockchainEventLogUpdateManyMutationInput, BlockchainEventLogUncheckedUpdateManyWithoutBlockchaineventlogInput>
  }

  export type DrugBatchUpsertWithoutSupplychainrecordInput = {
    update: XOR<DrugBatchUpdateWithoutSupplychainrecordInput, DrugBatchUncheckedUpdateWithoutSupplychainrecordInput>
    create: XOR<DrugBatchCreateWithoutSupplychainrecordInput, DrugBatchUncheckedCreateWithoutSupplychainrecordInput>
  }

  export type DrugBatchUpdateWithoutSupplychainrecordInput = {
    batchnumber?: StringFieldUpdateOperationsInput | string
    manufacturedate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirydate?: DateTimeFieldUpdateOperationsInput | Date | string
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: StringFieldUpdateOperationsInput | string
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
    blockchaineventlog?: BlockchainEventLogUpdateManyWithoutDrugbatchNestedInput
    dispenserecord?: DispenseRecordUpdateManyWithoutDrugbatchNestedInput
    drug?: DrugUpdateOneWithoutDrugbatchNestedInput
    manufacturer?: ManufacturerUpdateOneWithoutDrugbatchNestedInput
  }

  export type DrugBatchUncheckedUpdateWithoutSupplychainrecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    manufacturerid?: NullableIntFieldUpdateOperationsInput | number | null
    drugid?: NullableIntFieldUpdateOperationsInput | number | null
    batchnumber?: StringFieldUpdateOperationsInput | string
    manufacturedate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirydate?: DateTimeFieldUpdateOperationsInput | Date | string
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: StringFieldUpdateOperationsInput | string
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
    blockchaineventlog?: BlockchainEventLogUncheckedUpdateManyWithoutDrugbatchNestedInput
    dispenserecord?: DispenseRecordUncheckedUpdateManyWithoutDrugbatchNestedInput
  }

  export type UserUpsertWithoutSupplychainrecord_supplychainrecord_fromentityidTousersInput = {
    update: XOR<UserUpdateWithoutSupplychainrecord_supplychainrecord_fromentityidTousersInput, UserUncheckedUpdateWithoutSupplychainrecord_supplychainrecord_fromentityidTousersInput>
    create: XOR<UserCreateWithoutSupplychainrecord_supplychainrecord_fromentityidTousersInput, UserUncheckedCreateWithoutSupplychainrecord_supplychainrecord_fromentityidTousersInput>
  }

  export type UserUpdateWithoutSupplychainrecord_supplychainrecord_fromentityidTousersInput = {
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: ActivityLogUpdateManyWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUsersNestedInput
    alert?: AlertUpdateManyWithoutUsersNestedInput
    distributor?: DistributorUpdateOneWithoutUsersNestedInput
    doctor?: DoctorUpdateOneWithoutUsersNestedInput
    manufacturer?: ManufacturerUpdateOneWithoutUsersNestedInput
    otp?: OtpUpdateManyWithoutUsersNestedInput
    patient?: PatientUpdateOneWithoutUsersNestedInput
    pharmacist?: PharmacistUpdateOneWithoutUsersNestedInput
    regulator?: RegulatorUpdateOneWithoutUsersNestedInput
    reports?: ReportUpdateManyWithoutUsersNestedInput
    revocationrecord?: RevocationRecordUpdateManyWithoutUsersNestedInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUpdateManyWithoutUsers_supplychainrecord_toentityidTousersNestedInput
    roles?: RoleUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutSupplychainrecord_supplychainrecord_fromentityidTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    roleid?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: ActivityLogUncheckedUpdateManyWithoutUsersNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUsersNestedInput
    alert?: AlertUncheckedUpdateManyWithoutUsersNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUsersNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUsersNestedInput
    manufacturer?: ManufacturerUncheckedUpdateOneWithoutUsersNestedInput
    otp?: OtpUncheckedUpdateManyWithoutUsersNestedInput
    patient?: PatientUncheckedUpdateOneWithoutUsersNestedInput
    pharmacist?: PharmacistUncheckedUpdateOneWithoutUsersNestedInput
    regulator?: RegulatorUncheckedUpdateOneWithoutUsersNestedInput
    reports?: ReportUncheckedUpdateManyWithoutUsersNestedInput
    revocationrecord?: RevocationRecordUncheckedUpdateManyWithoutUsersNestedInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUncheckedUpdateManyWithoutUsers_supplychainrecord_toentityidTousersNestedInput
  }

  export type UserUpsertWithoutSupplychainrecord_supplychainrecord_toentityidTousersInput = {
    update: XOR<UserUpdateWithoutSupplychainrecord_supplychainrecord_toentityidTousersInput, UserUncheckedUpdateWithoutSupplychainrecord_supplychainrecord_toentityidTousersInput>
    create: XOR<UserCreateWithoutSupplychainrecord_supplychainrecord_toentityidTousersInput, UserUncheckedCreateWithoutSupplychainrecord_supplychainrecord_toentityidTousersInput>
  }

  export type UserUpdateWithoutSupplychainrecord_supplychainrecord_toentityidTousersInput = {
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: ActivityLogUpdateManyWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUsersNestedInput
    alert?: AlertUpdateManyWithoutUsersNestedInput
    distributor?: DistributorUpdateOneWithoutUsersNestedInput
    doctor?: DoctorUpdateOneWithoutUsersNestedInput
    manufacturer?: ManufacturerUpdateOneWithoutUsersNestedInput
    otp?: OtpUpdateManyWithoutUsersNestedInput
    patient?: PatientUpdateOneWithoutUsersNestedInput
    pharmacist?: PharmacistUpdateOneWithoutUsersNestedInput
    regulator?: RegulatorUpdateOneWithoutUsersNestedInput
    reports?: ReportUpdateManyWithoutUsersNestedInput
    revocationrecord?: RevocationRecordUpdateManyWithoutUsersNestedInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUpdateManyWithoutUsers_supplychainrecord_fromentityidTousersNestedInput
    roles?: RoleUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutSupplychainrecord_supplychainrecord_toentityidTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    roleid?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: ActivityLogUncheckedUpdateManyWithoutUsersNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUsersNestedInput
    alert?: AlertUncheckedUpdateManyWithoutUsersNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUsersNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUsersNestedInput
    manufacturer?: ManufacturerUncheckedUpdateOneWithoutUsersNestedInput
    otp?: OtpUncheckedUpdateManyWithoutUsersNestedInput
    patient?: PatientUncheckedUpdateOneWithoutUsersNestedInput
    pharmacist?: PharmacistUncheckedUpdateOneWithoutUsersNestedInput
    regulator?: RegulatorUncheckedUpdateOneWithoutUsersNestedInput
    reports?: ReportUncheckedUpdateManyWithoutUsersNestedInput
    revocationrecord?: RevocationRecordUncheckedUpdateManyWithoutUsersNestedInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUncheckedUpdateManyWithoutUsers_supplychainrecord_fromentityidTousersNestedInput
  }

  export type UserCreateWithoutRevocationrecordInput = {
    wallet: string
    email?: string | null
    passwordhash?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    activitylog?: ActivityLogCreateNestedManyWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUsersInput
    alert?: AlertCreateNestedManyWithoutUsersInput
    distributor?: DistributorCreateNestedOneWithoutUsersInput
    doctor?: DoctorCreateNestedOneWithoutUsersInput
    manufacturer?: ManufacturerCreateNestedOneWithoutUsersInput
    otp?: OtpCreateNestedManyWithoutUsersInput
    patient?: PatientCreateNestedOneWithoutUsersInput
    pharmacist?: PharmacistCreateNestedOneWithoutUsersInput
    regulator?: RegulatorCreateNestedOneWithoutUsersInput
    reports?: ReportCreateNestedManyWithoutUsersInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordCreateNestedManyWithoutUsers_supplychainrecord_fromentityidTousersInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordCreateNestedManyWithoutUsers_supplychainrecord_toentityidTousersInput
    roles?: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutRevocationrecordInput = {
    id?: number
    wallet: string
    email?: string | null
    passwordhash?: string | null
    roleid?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    activitylog?: ActivityLogUncheckedCreateNestedManyWithoutUsersInput
    admin?: AdminUncheckedCreateNestedOneWithoutUsersInput
    alert?: AlertUncheckedCreateNestedManyWithoutUsersInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUsersInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUsersInput
    manufacturer?: ManufacturerUncheckedCreateNestedOneWithoutUsersInput
    otp?: OtpUncheckedCreateNestedManyWithoutUsersInput
    patient?: PatientUncheckedCreateNestedOneWithoutUsersInput
    pharmacist?: PharmacistUncheckedCreateNestedOneWithoutUsersInput
    regulator?: RegulatorUncheckedCreateNestedOneWithoutUsersInput
    reports?: ReportUncheckedCreateNestedManyWithoutUsersInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUncheckedCreateNestedManyWithoutUsers_supplychainrecord_fromentityidTousersInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUncheckedCreateNestedManyWithoutUsers_supplychainrecord_toentityidTousersInput
  }

  export type UserCreateOrConnectWithoutRevocationrecordInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRevocationrecordInput, UserUncheckedCreateWithoutRevocationrecordInput>
  }

  export type UserUpsertWithoutRevocationrecordInput = {
    update: XOR<UserUpdateWithoutRevocationrecordInput, UserUncheckedUpdateWithoutRevocationrecordInput>
    create: XOR<UserCreateWithoutRevocationrecordInput, UserUncheckedCreateWithoutRevocationrecordInput>
  }

  export type UserUpdateWithoutRevocationrecordInput = {
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: ActivityLogUpdateManyWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUsersNestedInput
    alert?: AlertUpdateManyWithoutUsersNestedInput
    distributor?: DistributorUpdateOneWithoutUsersNestedInput
    doctor?: DoctorUpdateOneWithoutUsersNestedInput
    manufacturer?: ManufacturerUpdateOneWithoutUsersNestedInput
    otp?: OtpUpdateManyWithoutUsersNestedInput
    patient?: PatientUpdateOneWithoutUsersNestedInput
    pharmacist?: PharmacistUpdateOneWithoutUsersNestedInput
    regulator?: RegulatorUpdateOneWithoutUsersNestedInput
    reports?: ReportUpdateManyWithoutUsersNestedInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUpdateManyWithoutUsers_supplychainrecord_fromentityidTousersNestedInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUpdateManyWithoutUsers_supplychainrecord_toentityidTousersNestedInput
    roles?: RoleUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutRevocationrecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    roleid?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: ActivityLogUncheckedUpdateManyWithoutUsersNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUsersNestedInput
    alert?: AlertUncheckedUpdateManyWithoutUsersNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUsersNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUsersNestedInput
    manufacturer?: ManufacturerUncheckedUpdateOneWithoutUsersNestedInput
    otp?: OtpUncheckedUpdateManyWithoutUsersNestedInput
    patient?: PatientUncheckedUpdateOneWithoutUsersNestedInput
    pharmacist?: PharmacistUncheckedUpdateOneWithoutUsersNestedInput
    regulator?: RegulatorUncheckedUpdateOneWithoutUsersNestedInput
    reports?: ReportUncheckedUpdateManyWithoutUsersNestedInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUncheckedUpdateManyWithoutUsers_supplychainrecord_fromentityidTousersNestedInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUncheckedUpdateManyWithoutUsers_supplychainrecord_toentityidTousersNestedInput
  }

  export type UserCreateWithoutOtpInput = {
    wallet: string
    email?: string | null
    passwordhash?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    activitylog?: ActivityLogCreateNestedManyWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUsersInput
    alert?: AlertCreateNestedManyWithoutUsersInput
    distributor?: DistributorCreateNestedOneWithoutUsersInput
    doctor?: DoctorCreateNestedOneWithoutUsersInput
    manufacturer?: ManufacturerCreateNestedOneWithoutUsersInput
    patient?: PatientCreateNestedOneWithoutUsersInput
    pharmacist?: PharmacistCreateNestedOneWithoutUsersInput
    regulator?: RegulatorCreateNestedOneWithoutUsersInput
    reports?: ReportCreateNestedManyWithoutUsersInput
    revocationrecord?: RevocationRecordCreateNestedManyWithoutUsersInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordCreateNestedManyWithoutUsers_supplychainrecord_fromentityidTousersInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordCreateNestedManyWithoutUsers_supplychainrecord_toentityidTousersInput
    roles?: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutOtpInput = {
    id?: number
    wallet: string
    email?: string | null
    passwordhash?: string | null
    roleid?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    activitylog?: ActivityLogUncheckedCreateNestedManyWithoutUsersInput
    admin?: AdminUncheckedCreateNestedOneWithoutUsersInput
    alert?: AlertUncheckedCreateNestedManyWithoutUsersInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUsersInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUsersInput
    manufacturer?: ManufacturerUncheckedCreateNestedOneWithoutUsersInput
    patient?: PatientUncheckedCreateNestedOneWithoutUsersInput
    pharmacist?: PharmacistUncheckedCreateNestedOneWithoutUsersInput
    regulator?: RegulatorUncheckedCreateNestedOneWithoutUsersInput
    reports?: ReportUncheckedCreateNestedManyWithoutUsersInput
    revocationrecord?: RevocationRecordUncheckedCreateNestedManyWithoutUsersInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUncheckedCreateNestedManyWithoutUsers_supplychainrecord_fromentityidTousersInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUncheckedCreateNestedManyWithoutUsers_supplychainrecord_toentityidTousersInput
  }

  export type UserCreateOrConnectWithoutOtpInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOtpInput, UserUncheckedCreateWithoutOtpInput>
  }

  export type UserUpsertWithoutOtpInput = {
    update: XOR<UserUpdateWithoutOtpInput, UserUncheckedUpdateWithoutOtpInput>
    create: XOR<UserCreateWithoutOtpInput, UserUncheckedCreateWithoutOtpInput>
  }

  export type UserUpdateWithoutOtpInput = {
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: ActivityLogUpdateManyWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUsersNestedInput
    alert?: AlertUpdateManyWithoutUsersNestedInput
    distributor?: DistributorUpdateOneWithoutUsersNestedInput
    doctor?: DoctorUpdateOneWithoutUsersNestedInput
    manufacturer?: ManufacturerUpdateOneWithoutUsersNestedInput
    patient?: PatientUpdateOneWithoutUsersNestedInput
    pharmacist?: PharmacistUpdateOneWithoutUsersNestedInput
    regulator?: RegulatorUpdateOneWithoutUsersNestedInput
    reports?: ReportUpdateManyWithoutUsersNestedInput
    revocationrecord?: RevocationRecordUpdateManyWithoutUsersNestedInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUpdateManyWithoutUsers_supplychainrecord_fromentityidTousersNestedInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUpdateManyWithoutUsers_supplychainrecord_toentityidTousersNestedInput
    roles?: RoleUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutOtpInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    roleid?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: ActivityLogUncheckedUpdateManyWithoutUsersNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUsersNestedInput
    alert?: AlertUncheckedUpdateManyWithoutUsersNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUsersNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUsersNestedInput
    manufacturer?: ManufacturerUncheckedUpdateOneWithoutUsersNestedInput
    patient?: PatientUncheckedUpdateOneWithoutUsersNestedInput
    pharmacist?: PharmacistUncheckedUpdateOneWithoutUsersNestedInput
    regulator?: RegulatorUncheckedUpdateOneWithoutUsersNestedInput
    reports?: ReportUncheckedUpdateManyWithoutUsersNestedInput
    revocationrecord?: RevocationRecordUncheckedUpdateManyWithoutUsersNestedInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUncheckedUpdateManyWithoutUsers_supplychainrecord_fromentityidTousersNestedInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUncheckedUpdateManyWithoutUsers_supplychainrecord_toentityidTousersNestedInput
  }

  export type UserCreateWithoutAlertInput = {
    wallet: string
    email?: string | null
    passwordhash?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    activitylog?: ActivityLogCreateNestedManyWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUsersInput
    distributor?: DistributorCreateNestedOneWithoutUsersInput
    doctor?: DoctorCreateNestedOneWithoutUsersInput
    manufacturer?: ManufacturerCreateNestedOneWithoutUsersInput
    otp?: OtpCreateNestedManyWithoutUsersInput
    patient?: PatientCreateNestedOneWithoutUsersInput
    pharmacist?: PharmacistCreateNestedOneWithoutUsersInput
    regulator?: RegulatorCreateNestedOneWithoutUsersInput
    reports?: ReportCreateNestedManyWithoutUsersInput
    revocationrecord?: RevocationRecordCreateNestedManyWithoutUsersInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordCreateNestedManyWithoutUsers_supplychainrecord_fromentityidTousersInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordCreateNestedManyWithoutUsers_supplychainrecord_toentityidTousersInput
    roles?: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutAlertInput = {
    id?: number
    wallet: string
    email?: string | null
    passwordhash?: string | null
    roleid?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    activitylog?: ActivityLogUncheckedCreateNestedManyWithoutUsersInput
    admin?: AdminUncheckedCreateNestedOneWithoutUsersInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUsersInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUsersInput
    manufacturer?: ManufacturerUncheckedCreateNestedOneWithoutUsersInput
    otp?: OtpUncheckedCreateNestedManyWithoutUsersInput
    patient?: PatientUncheckedCreateNestedOneWithoutUsersInput
    pharmacist?: PharmacistUncheckedCreateNestedOneWithoutUsersInput
    regulator?: RegulatorUncheckedCreateNestedOneWithoutUsersInput
    reports?: ReportUncheckedCreateNestedManyWithoutUsersInput
    revocationrecord?: RevocationRecordUncheckedCreateNestedManyWithoutUsersInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUncheckedCreateNestedManyWithoutUsers_supplychainrecord_fromentityidTousersInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUncheckedCreateNestedManyWithoutUsers_supplychainrecord_toentityidTousersInput
  }

  export type UserCreateOrConnectWithoutAlertInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAlertInput, UserUncheckedCreateWithoutAlertInput>
  }

  export type UserUpsertWithoutAlertInput = {
    update: XOR<UserUpdateWithoutAlertInput, UserUncheckedUpdateWithoutAlertInput>
    create: XOR<UserCreateWithoutAlertInput, UserUncheckedCreateWithoutAlertInput>
  }

  export type UserUpdateWithoutAlertInput = {
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: ActivityLogUpdateManyWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUsersNestedInput
    distributor?: DistributorUpdateOneWithoutUsersNestedInput
    doctor?: DoctorUpdateOneWithoutUsersNestedInput
    manufacturer?: ManufacturerUpdateOneWithoutUsersNestedInput
    otp?: OtpUpdateManyWithoutUsersNestedInput
    patient?: PatientUpdateOneWithoutUsersNestedInput
    pharmacist?: PharmacistUpdateOneWithoutUsersNestedInput
    regulator?: RegulatorUpdateOneWithoutUsersNestedInput
    reports?: ReportUpdateManyWithoutUsersNestedInput
    revocationrecord?: RevocationRecordUpdateManyWithoutUsersNestedInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUpdateManyWithoutUsers_supplychainrecord_fromentityidTousersNestedInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUpdateManyWithoutUsers_supplychainrecord_toentityidTousersNestedInput
    roles?: RoleUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutAlertInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    roleid?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: ActivityLogUncheckedUpdateManyWithoutUsersNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUsersNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUsersNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUsersNestedInput
    manufacturer?: ManufacturerUncheckedUpdateOneWithoutUsersNestedInput
    otp?: OtpUncheckedUpdateManyWithoutUsersNestedInput
    patient?: PatientUncheckedUpdateOneWithoutUsersNestedInput
    pharmacist?: PharmacistUncheckedUpdateOneWithoutUsersNestedInput
    regulator?: RegulatorUncheckedUpdateOneWithoutUsersNestedInput
    reports?: ReportUncheckedUpdateManyWithoutUsersNestedInput
    revocationrecord?: RevocationRecordUncheckedUpdateManyWithoutUsersNestedInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUncheckedUpdateManyWithoutUsers_supplychainrecord_fromentityidTousersNestedInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUncheckedUpdateManyWithoutUsers_supplychainrecord_toentityidTousersNestedInput
  }

  export type UserCreateWithoutActivitylogInput = {
    wallet: string
    email?: string | null
    passwordhash?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    admin?: AdminCreateNestedOneWithoutUsersInput
    alert?: AlertCreateNestedManyWithoutUsersInput
    distributor?: DistributorCreateNestedOneWithoutUsersInput
    doctor?: DoctorCreateNestedOneWithoutUsersInput
    manufacturer?: ManufacturerCreateNestedOneWithoutUsersInput
    otp?: OtpCreateNestedManyWithoutUsersInput
    patient?: PatientCreateNestedOneWithoutUsersInput
    pharmacist?: PharmacistCreateNestedOneWithoutUsersInput
    regulator?: RegulatorCreateNestedOneWithoutUsersInput
    reports?: ReportCreateNestedManyWithoutUsersInput
    revocationrecord?: RevocationRecordCreateNestedManyWithoutUsersInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordCreateNestedManyWithoutUsers_supplychainrecord_fromentityidTousersInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordCreateNestedManyWithoutUsers_supplychainrecord_toentityidTousersInput
    roles?: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutActivitylogInput = {
    id?: number
    wallet: string
    email?: string | null
    passwordhash?: string | null
    roleid?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    admin?: AdminUncheckedCreateNestedOneWithoutUsersInput
    alert?: AlertUncheckedCreateNestedManyWithoutUsersInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUsersInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUsersInput
    manufacturer?: ManufacturerUncheckedCreateNestedOneWithoutUsersInput
    otp?: OtpUncheckedCreateNestedManyWithoutUsersInput
    patient?: PatientUncheckedCreateNestedOneWithoutUsersInput
    pharmacist?: PharmacistUncheckedCreateNestedOneWithoutUsersInput
    regulator?: RegulatorUncheckedCreateNestedOneWithoutUsersInput
    reports?: ReportUncheckedCreateNestedManyWithoutUsersInput
    revocationrecord?: RevocationRecordUncheckedCreateNestedManyWithoutUsersInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUncheckedCreateNestedManyWithoutUsers_supplychainrecord_fromentityidTousersInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUncheckedCreateNestedManyWithoutUsers_supplychainrecord_toentityidTousersInput
  }

  export type UserCreateOrConnectWithoutActivitylogInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivitylogInput, UserUncheckedCreateWithoutActivitylogInput>
  }

  export type UserUpsertWithoutActivitylogInput = {
    update: XOR<UserUpdateWithoutActivitylogInput, UserUncheckedUpdateWithoutActivitylogInput>
    create: XOR<UserCreateWithoutActivitylogInput, UserUncheckedCreateWithoutActivitylogInput>
  }

  export type UserUpdateWithoutActivitylogInput = {
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: AdminUpdateOneWithoutUsersNestedInput
    alert?: AlertUpdateManyWithoutUsersNestedInput
    distributor?: DistributorUpdateOneWithoutUsersNestedInput
    doctor?: DoctorUpdateOneWithoutUsersNestedInput
    manufacturer?: ManufacturerUpdateOneWithoutUsersNestedInput
    otp?: OtpUpdateManyWithoutUsersNestedInput
    patient?: PatientUpdateOneWithoutUsersNestedInput
    pharmacist?: PharmacistUpdateOneWithoutUsersNestedInput
    regulator?: RegulatorUpdateOneWithoutUsersNestedInput
    reports?: ReportUpdateManyWithoutUsersNestedInput
    revocationrecord?: RevocationRecordUpdateManyWithoutUsersNestedInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUpdateManyWithoutUsers_supplychainrecord_fromentityidTousersNestedInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUpdateManyWithoutUsers_supplychainrecord_toentityidTousersNestedInput
    roles?: RoleUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutActivitylogInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    roleid?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: AdminUncheckedUpdateOneWithoutUsersNestedInput
    alert?: AlertUncheckedUpdateManyWithoutUsersNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUsersNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUsersNestedInput
    manufacturer?: ManufacturerUncheckedUpdateOneWithoutUsersNestedInput
    otp?: OtpUncheckedUpdateManyWithoutUsersNestedInput
    patient?: PatientUncheckedUpdateOneWithoutUsersNestedInput
    pharmacist?: PharmacistUncheckedUpdateOneWithoutUsersNestedInput
    regulator?: RegulatorUncheckedUpdateOneWithoutUsersNestedInput
    reports?: ReportUncheckedUpdateManyWithoutUsersNestedInput
    revocationrecord?: RevocationRecordUncheckedUpdateManyWithoutUsersNestedInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUncheckedUpdateManyWithoutUsers_supplychainrecord_fromentityidTousersNestedInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUncheckedUpdateManyWithoutUsers_supplychainrecord_toentityidTousersNestedInput
  }

  export type UserCreateWithoutReportsInput = {
    wallet: string
    email?: string | null
    passwordhash?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    activitylog?: ActivityLogCreateNestedManyWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUsersInput
    alert?: AlertCreateNestedManyWithoutUsersInput
    distributor?: DistributorCreateNestedOneWithoutUsersInput
    doctor?: DoctorCreateNestedOneWithoutUsersInput
    manufacturer?: ManufacturerCreateNestedOneWithoutUsersInput
    otp?: OtpCreateNestedManyWithoutUsersInput
    patient?: PatientCreateNestedOneWithoutUsersInput
    pharmacist?: PharmacistCreateNestedOneWithoutUsersInput
    regulator?: RegulatorCreateNestedOneWithoutUsersInput
    revocationrecord?: RevocationRecordCreateNestedManyWithoutUsersInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordCreateNestedManyWithoutUsers_supplychainrecord_fromentityidTousersInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordCreateNestedManyWithoutUsers_supplychainrecord_toentityidTousersInput
    roles?: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutReportsInput = {
    id?: number
    wallet: string
    email?: string | null
    passwordhash?: string | null
    roleid?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    activitylog?: ActivityLogUncheckedCreateNestedManyWithoutUsersInput
    admin?: AdminUncheckedCreateNestedOneWithoutUsersInput
    alert?: AlertUncheckedCreateNestedManyWithoutUsersInput
    distributor?: DistributorUncheckedCreateNestedOneWithoutUsersInput
    doctor?: DoctorUncheckedCreateNestedOneWithoutUsersInput
    manufacturer?: ManufacturerUncheckedCreateNestedOneWithoutUsersInput
    otp?: OtpUncheckedCreateNestedManyWithoutUsersInput
    patient?: PatientUncheckedCreateNestedOneWithoutUsersInput
    pharmacist?: PharmacistUncheckedCreateNestedOneWithoutUsersInput
    regulator?: RegulatorUncheckedCreateNestedOneWithoutUsersInput
    revocationrecord?: RevocationRecordUncheckedCreateNestedManyWithoutUsersInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUncheckedCreateNestedManyWithoutUsers_supplychainrecord_fromentityidTousersInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUncheckedCreateNestedManyWithoutUsers_supplychainrecord_toentityidTousersInput
  }

  export type UserCreateOrConnectWithoutReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
  }

  export type UserUpsertWithoutReportsInput = {
    update: XOR<UserUpdateWithoutReportsInput, UserUncheckedUpdateWithoutReportsInput>
    create: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
  }

  export type UserUpdateWithoutReportsInput = {
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: ActivityLogUpdateManyWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUsersNestedInput
    alert?: AlertUpdateManyWithoutUsersNestedInput
    distributor?: DistributorUpdateOneWithoutUsersNestedInput
    doctor?: DoctorUpdateOneWithoutUsersNestedInput
    manufacturer?: ManufacturerUpdateOneWithoutUsersNestedInput
    otp?: OtpUpdateManyWithoutUsersNestedInput
    patient?: PatientUpdateOneWithoutUsersNestedInput
    pharmacist?: PharmacistUpdateOneWithoutUsersNestedInput
    regulator?: RegulatorUpdateOneWithoutUsersNestedInput
    revocationrecord?: RevocationRecordUpdateManyWithoutUsersNestedInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUpdateManyWithoutUsers_supplychainrecord_fromentityidTousersNestedInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUpdateManyWithoutUsers_supplychainrecord_toentityidTousersNestedInput
    roles?: RoleUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    roleid?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: ActivityLogUncheckedUpdateManyWithoutUsersNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUsersNestedInput
    alert?: AlertUncheckedUpdateManyWithoutUsersNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUsersNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUsersNestedInput
    manufacturer?: ManufacturerUncheckedUpdateOneWithoutUsersNestedInput
    otp?: OtpUncheckedUpdateManyWithoutUsersNestedInput
    patient?: PatientUncheckedUpdateOneWithoutUsersNestedInput
    pharmacist?: PharmacistUncheckedUpdateOneWithoutUsersNestedInput
    regulator?: RegulatorUncheckedUpdateOneWithoutUsersNestedInput
    revocationrecord?: RevocationRecordUncheckedUpdateManyWithoutUsersNestedInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUncheckedUpdateManyWithoutUsers_supplychainrecord_fromentityidTousersNestedInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUncheckedUpdateManyWithoutUsers_supplychainrecord_toentityidTousersNestedInput
  }

  export type DrugBatchCreateWithoutDispenserecordInput = {
    batchnumber: string
    manufacturedate: Date | string
    expirydate: Date | string
    blockchaintx?: string | null
    qrcode: string
    ipfshash?: string | null
    blockchaineventlog?: BlockchainEventLogCreateNestedManyWithoutDrugbatchInput
    drug?: DrugCreateNestedOneWithoutDrugbatchInput
    manufacturer?: ManufacturerCreateNestedOneWithoutDrugbatchInput
    supplychainrecord?: SupplyChainRecordCreateNestedManyWithoutDrugbatchInput
  }

  export type DrugBatchUncheckedCreateWithoutDispenserecordInput = {
    id?: number
    manufacturerid?: number | null
    drugid?: number | null
    batchnumber: string
    manufacturedate: Date | string
    expirydate: Date | string
    blockchaintx?: string | null
    qrcode: string
    ipfshash?: string | null
    blockchaineventlog?: BlockchainEventLogUncheckedCreateNestedManyWithoutDrugbatchInput
    supplychainrecord?: SupplyChainRecordUncheckedCreateNestedManyWithoutDrugbatchInput
  }

  export type DrugBatchCreateOrConnectWithoutDispenserecordInput = {
    where: DrugBatchWhereUniqueInput
    create: XOR<DrugBatchCreateWithoutDispenserecordInput, DrugBatchUncheckedCreateWithoutDispenserecordInput>
  }

  export type PharmacistCreateWithoutDispenserecordInput = {
    licenseno: string
    pharmacy: string
    users?: UserCreateNestedOneWithoutPharmacistInput
  }

  export type PharmacistUncheckedCreateWithoutDispenserecordInput = {
    id?: number
    userid?: number | null
    licenseno: string
    pharmacy: string
  }

  export type PharmacistCreateOrConnectWithoutDispenserecordInput = {
    where: PharmacistWhereUniqueInput
    create: XOR<PharmacistCreateWithoutDispenserecordInput, PharmacistUncheckedCreateWithoutDispenserecordInput>
  }

  export type PrescriptionCreateWithoutDispenserecordInput = {
    dosage: string
    issuedat?: Date | string | null
    expiresat: Date | string
    blockchaintx?: string | null
    qrcode: string
    ipfshash?: string | null
    status: string
    blockchaineventlog?: BlockchainEventLogCreateNestedManyWithoutPrescriptionInput
    doctor?: DoctorCreateNestedOneWithoutPrescriptionInput
    drug?: DrugCreateNestedOneWithoutPrescriptionInput
    patient?: PatientCreateNestedOneWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutDispenserecordInput = {
    id?: number
    patientid?: number | null
    doctorid?: number | null
    drugid?: number | null
    dosage: string
    issuedat?: Date | string | null
    expiresat: Date | string
    blockchaintx?: string | null
    qrcode: string
    ipfshash?: string | null
    status: string
    blockchaineventlog?: BlockchainEventLogUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionCreateOrConnectWithoutDispenserecordInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutDispenserecordInput, PrescriptionUncheckedCreateWithoutDispenserecordInput>
  }

  export type DrugBatchUpsertWithoutDispenserecordInput = {
    update: XOR<DrugBatchUpdateWithoutDispenserecordInput, DrugBatchUncheckedUpdateWithoutDispenserecordInput>
    create: XOR<DrugBatchCreateWithoutDispenserecordInput, DrugBatchUncheckedCreateWithoutDispenserecordInput>
  }

  export type DrugBatchUpdateWithoutDispenserecordInput = {
    batchnumber?: StringFieldUpdateOperationsInput | string
    manufacturedate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirydate?: DateTimeFieldUpdateOperationsInput | Date | string
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: StringFieldUpdateOperationsInput | string
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
    blockchaineventlog?: BlockchainEventLogUpdateManyWithoutDrugbatchNestedInput
    drug?: DrugUpdateOneWithoutDrugbatchNestedInput
    manufacturer?: ManufacturerUpdateOneWithoutDrugbatchNestedInput
    supplychainrecord?: SupplyChainRecordUpdateManyWithoutDrugbatchNestedInput
  }

  export type DrugBatchUncheckedUpdateWithoutDispenserecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    manufacturerid?: NullableIntFieldUpdateOperationsInput | number | null
    drugid?: NullableIntFieldUpdateOperationsInput | number | null
    batchnumber?: StringFieldUpdateOperationsInput | string
    manufacturedate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirydate?: DateTimeFieldUpdateOperationsInput | Date | string
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: StringFieldUpdateOperationsInput | string
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
    blockchaineventlog?: BlockchainEventLogUncheckedUpdateManyWithoutDrugbatchNestedInput
    supplychainrecord?: SupplyChainRecordUncheckedUpdateManyWithoutDrugbatchNestedInput
  }

  export type PharmacistUpsertWithoutDispenserecordInput = {
    update: XOR<PharmacistUpdateWithoutDispenserecordInput, PharmacistUncheckedUpdateWithoutDispenserecordInput>
    create: XOR<PharmacistCreateWithoutDispenserecordInput, PharmacistUncheckedCreateWithoutDispenserecordInput>
  }

  export type PharmacistUpdateWithoutDispenserecordInput = {
    licenseno?: StringFieldUpdateOperationsInput | string
    pharmacy?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateOneWithoutPharmacistNestedInput
  }

  export type PharmacistUncheckedUpdateWithoutDispenserecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    userid?: NullableIntFieldUpdateOperationsInput | number | null
    licenseno?: StringFieldUpdateOperationsInput | string
    pharmacy?: StringFieldUpdateOperationsInput | string
  }

  export type PrescriptionUpsertWithoutDispenserecordInput = {
    update: XOR<PrescriptionUpdateWithoutDispenserecordInput, PrescriptionUncheckedUpdateWithoutDispenserecordInput>
    create: XOR<PrescriptionCreateWithoutDispenserecordInput, PrescriptionUncheckedCreateWithoutDispenserecordInput>
  }

  export type PrescriptionUpdateWithoutDispenserecordInput = {
    dosage?: StringFieldUpdateOperationsInput | string
    issuedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresat?: DateTimeFieldUpdateOperationsInput | Date | string
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: StringFieldUpdateOperationsInput | string
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    blockchaineventlog?: BlockchainEventLogUpdateManyWithoutPrescriptionNestedInput
    doctor?: DoctorUpdateOneWithoutPrescriptionNestedInput
    drug?: DrugUpdateOneWithoutPrescriptionNestedInput
    patient?: PatientUpdateOneWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutDispenserecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientid?: NullableIntFieldUpdateOperationsInput | number | null
    doctorid?: NullableIntFieldUpdateOperationsInput | number | null
    drugid?: NullableIntFieldUpdateOperationsInput | number | null
    dosage?: StringFieldUpdateOperationsInput | string
    issuedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresat?: DateTimeFieldUpdateOperationsInput | Date | string
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: StringFieldUpdateOperationsInput | string
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    blockchaineventlog?: BlockchainEventLogUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type DrugBatchCreateWithoutBlockchaineventlogInput = {
    batchnumber: string
    manufacturedate: Date | string
    expirydate: Date | string
    blockchaintx?: string | null
    qrcode: string
    ipfshash?: string | null
    dispenserecord?: DispenseRecordCreateNestedManyWithoutDrugbatchInput
    drug?: DrugCreateNestedOneWithoutDrugbatchInput
    manufacturer?: ManufacturerCreateNestedOneWithoutDrugbatchInput
    supplychainrecord?: SupplyChainRecordCreateNestedManyWithoutDrugbatchInput
  }

  export type DrugBatchUncheckedCreateWithoutBlockchaineventlogInput = {
    id?: number
    manufacturerid?: number | null
    drugid?: number | null
    batchnumber: string
    manufacturedate: Date | string
    expirydate: Date | string
    blockchaintx?: string | null
    qrcode: string
    ipfshash?: string | null
    dispenserecord?: DispenseRecordUncheckedCreateNestedManyWithoutDrugbatchInput
    supplychainrecord?: SupplyChainRecordUncheckedCreateNestedManyWithoutDrugbatchInput
  }

  export type DrugBatchCreateOrConnectWithoutBlockchaineventlogInput = {
    where: DrugBatchWhereUniqueInput
    create: XOR<DrugBatchCreateWithoutBlockchaineventlogInput, DrugBatchUncheckedCreateWithoutBlockchaineventlogInput>
  }

  export type PrescriptionCreateWithoutBlockchaineventlogInput = {
    dosage: string
    issuedat?: Date | string | null
    expiresat: Date | string
    blockchaintx?: string | null
    qrcode: string
    ipfshash?: string | null
    status: string
    dispenserecord?: DispenseRecordCreateNestedManyWithoutPrescriptionInput
    doctor?: DoctorCreateNestedOneWithoutPrescriptionInput
    drug?: DrugCreateNestedOneWithoutPrescriptionInput
    patient?: PatientCreateNestedOneWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutBlockchaineventlogInput = {
    id?: number
    patientid?: number | null
    doctorid?: number | null
    drugid?: number | null
    dosage: string
    issuedat?: Date | string | null
    expiresat: Date | string
    blockchaintx?: string | null
    qrcode: string
    ipfshash?: string | null
    status: string
    dispenserecord?: DispenseRecordUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionCreateOrConnectWithoutBlockchaineventlogInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutBlockchaineventlogInput, PrescriptionUncheckedCreateWithoutBlockchaineventlogInput>
  }

  export type SupplyChainRecordCreateWithoutBlockchaineventlogInput = {
    action: string
    timestamp?: Date | string | null
    blockchaintx?: string | null
    drugbatch?: DrugBatchCreateNestedOneWithoutSupplychainrecordInput
    users_supplychainrecord_fromentityidTousers?: UserCreateNestedOneWithoutSupplychainrecord_supplychainrecord_fromentityidTousersInput
    users_supplychainrecord_toentityidTousers?: UserCreateNestedOneWithoutSupplychainrecord_supplychainrecord_toentityidTousersInput
  }

  export type SupplyChainRecordUncheckedCreateWithoutBlockchaineventlogInput = {
    id?: number
    drugbatchid?: number | null
    fromentityid?: number | null
    toentityid?: number | null
    action: string
    timestamp?: Date | string | null
    blockchaintx?: string | null
  }

  export type SupplyChainRecordCreateOrConnectWithoutBlockchaineventlogInput = {
    where: SupplyChainRecordWhereUniqueInput
    create: XOR<SupplyChainRecordCreateWithoutBlockchaineventlogInput, SupplyChainRecordUncheckedCreateWithoutBlockchaineventlogInput>
  }

  export type DrugBatchUpsertWithoutBlockchaineventlogInput = {
    update: XOR<DrugBatchUpdateWithoutBlockchaineventlogInput, DrugBatchUncheckedUpdateWithoutBlockchaineventlogInput>
    create: XOR<DrugBatchCreateWithoutBlockchaineventlogInput, DrugBatchUncheckedCreateWithoutBlockchaineventlogInput>
  }

  export type DrugBatchUpdateWithoutBlockchaineventlogInput = {
    batchnumber?: StringFieldUpdateOperationsInput | string
    manufacturedate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirydate?: DateTimeFieldUpdateOperationsInput | Date | string
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: StringFieldUpdateOperationsInput | string
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
    dispenserecord?: DispenseRecordUpdateManyWithoutDrugbatchNestedInput
    drug?: DrugUpdateOneWithoutDrugbatchNestedInput
    manufacturer?: ManufacturerUpdateOneWithoutDrugbatchNestedInput
    supplychainrecord?: SupplyChainRecordUpdateManyWithoutDrugbatchNestedInput
  }

  export type DrugBatchUncheckedUpdateWithoutBlockchaineventlogInput = {
    id?: IntFieldUpdateOperationsInput | number
    manufacturerid?: NullableIntFieldUpdateOperationsInput | number | null
    drugid?: NullableIntFieldUpdateOperationsInput | number | null
    batchnumber?: StringFieldUpdateOperationsInput | string
    manufacturedate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirydate?: DateTimeFieldUpdateOperationsInput | Date | string
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: StringFieldUpdateOperationsInput | string
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
    dispenserecord?: DispenseRecordUncheckedUpdateManyWithoutDrugbatchNestedInput
    supplychainrecord?: SupplyChainRecordUncheckedUpdateManyWithoutDrugbatchNestedInput
  }

  export type PrescriptionUpsertWithoutBlockchaineventlogInput = {
    update: XOR<PrescriptionUpdateWithoutBlockchaineventlogInput, PrescriptionUncheckedUpdateWithoutBlockchaineventlogInput>
    create: XOR<PrescriptionCreateWithoutBlockchaineventlogInput, PrescriptionUncheckedCreateWithoutBlockchaineventlogInput>
  }

  export type PrescriptionUpdateWithoutBlockchaineventlogInput = {
    dosage?: StringFieldUpdateOperationsInput | string
    issuedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresat?: DateTimeFieldUpdateOperationsInput | Date | string
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: StringFieldUpdateOperationsInput | string
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dispenserecord?: DispenseRecordUpdateManyWithoutPrescriptionNestedInput
    doctor?: DoctorUpdateOneWithoutPrescriptionNestedInput
    drug?: DrugUpdateOneWithoutPrescriptionNestedInput
    patient?: PatientUpdateOneWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutBlockchaineventlogInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientid?: NullableIntFieldUpdateOperationsInput | number | null
    doctorid?: NullableIntFieldUpdateOperationsInput | number | null
    drugid?: NullableIntFieldUpdateOperationsInput | number | null
    dosage?: StringFieldUpdateOperationsInput | string
    issuedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresat?: DateTimeFieldUpdateOperationsInput | Date | string
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: StringFieldUpdateOperationsInput | string
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dispenserecord?: DispenseRecordUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type SupplyChainRecordUpsertWithoutBlockchaineventlogInput = {
    update: XOR<SupplyChainRecordUpdateWithoutBlockchaineventlogInput, SupplyChainRecordUncheckedUpdateWithoutBlockchaineventlogInput>
    create: XOR<SupplyChainRecordCreateWithoutBlockchaineventlogInput, SupplyChainRecordUncheckedCreateWithoutBlockchaineventlogInput>
  }

  export type SupplyChainRecordUpdateWithoutBlockchaineventlogInput = {
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    drugbatch?: DrugBatchUpdateOneWithoutSupplychainrecordNestedInput
    users_supplychainrecord_fromentityidTousers?: UserUpdateOneWithoutSupplychainrecord_supplychainrecord_fromentityidTousersNestedInput
    users_supplychainrecord_toentityidTousers?: UserUpdateOneWithoutSupplychainrecord_supplychainrecord_toentityidTousersNestedInput
  }

  export type SupplyChainRecordUncheckedUpdateWithoutBlockchaineventlogInput = {
    id?: IntFieldUpdateOperationsInput | number
    drugbatchid?: NullableIntFieldUpdateOperationsInput | number | null
    fromentityid?: NullableIntFieldUpdateOperationsInput | number | null
    toentityid?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateManyRolesInput = {
    id?: number
    wallet: string
    email?: string | null
    passwordhash?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UserUpdateWithoutRolesInput = {
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: ActivityLogUpdateManyWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUsersNestedInput
    alert?: AlertUpdateManyWithoutUsersNestedInput
    distributor?: DistributorUpdateOneWithoutUsersNestedInput
    doctor?: DoctorUpdateOneWithoutUsersNestedInput
    manufacturer?: ManufacturerUpdateOneWithoutUsersNestedInput
    otp?: OtpUpdateManyWithoutUsersNestedInput
    patient?: PatientUpdateOneWithoutUsersNestedInput
    pharmacist?: PharmacistUpdateOneWithoutUsersNestedInput
    regulator?: RegulatorUpdateOneWithoutUsersNestedInput
    reports?: ReportUpdateManyWithoutUsersNestedInput
    revocationrecord?: RevocationRecordUpdateManyWithoutUsersNestedInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUpdateManyWithoutUsers_supplychainrecord_fromentityidTousersNestedInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUpdateManyWithoutUsers_supplychainrecord_toentityidTousersNestedInput
  }

  export type UserUncheckedUpdateWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activitylog?: ActivityLogUncheckedUpdateManyWithoutUsersNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUsersNestedInput
    alert?: AlertUncheckedUpdateManyWithoutUsersNestedInput
    distributor?: DistributorUncheckedUpdateOneWithoutUsersNestedInput
    doctor?: DoctorUncheckedUpdateOneWithoutUsersNestedInput
    manufacturer?: ManufacturerUncheckedUpdateOneWithoutUsersNestedInput
    otp?: OtpUncheckedUpdateManyWithoutUsersNestedInput
    patient?: PatientUncheckedUpdateOneWithoutUsersNestedInput
    pharmacist?: PharmacistUncheckedUpdateOneWithoutUsersNestedInput
    regulator?: RegulatorUncheckedUpdateOneWithoutUsersNestedInput
    reports?: ReportUncheckedUpdateManyWithoutUsersNestedInput
    revocationrecord?: RevocationRecordUncheckedUpdateManyWithoutUsersNestedInput
    supplychainrecord_supplychainrecord_fromentityidTousers?: SupplyChainRecordUncheckedUpdateManyWithoutUsers_supplychainrecord_fromentityidTousersNestedInput
    supplychainrecord_supplychainrecord_toentityidTousers?: SupplyChainRecordUncheckedUpdateManyWithoutUsers_supplychainrecord_toentityidTousersNestedInput
  }

  export type UserUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    passwordhash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActivityLogCreateManyUsersInput = {
    id?: number
    action: string
    details?: string | null
    timestamp?: Date | string | null
  }

  export type AlertCreateManyUsersInput = {
    id?: number
    title: string
    message: string
    isread?: boolean | null
    priority: string
    createdat?: Date | string | null
  }

  export type OtpCreateManyUsersInput = {
    id?: number
    code: string
    expiresat: Date | string
    createdat?: Date | string | null
  }

  export type ReportCreateManyUsersInput = {
    id?: number
    reporttype: string
    filters?: NullableJsonNullValueInput | InputJsonValue
    generatedat?: Date | string | null
    ipfshash?: string | null
  }

  export type RevocationRecordCreateManyUsersInput = {
    id?: number
    type: string
    refid: number
    reason: string
    timestamp?: Date | string | null
    blockchaintx?: string | null
  }

  export type SupplyChainRecordCreateManyUsers_supplychainrecord_fromentityidTousersInput = {
    id?: number
    drugbatchid?: number | null
    toentityid?: number | null
    action: string
    timestamp?: Date | string | null
    blockchaintx?: string | null
  }

  export type SupplyChainRecordCreateManyUsers_supplychainrecord_toentityidTousersInput = {
    id?: number
    drugbatchid?: number | null
    fromentityid?: number | null
    action: string
    timestamp?: Date | string | null
    blockchaintx?: string | null
  }

  export type ActivityLogUpdateWithoutUsersInput = {
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActivityLogUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActivityLogUncheckedUpdateManyWithoutActivitylogInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AlertUpdateWithoutUsersInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isread?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priority?: StringFieldUpdateOperationsInput | string
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AlertUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isread?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priority?: StringFieldUpdateOperationsInput | string
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AlertUncheckedUpdateManyWithoutAlertInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isread?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priority?: StringFieldUpdateOperationsInput | string
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OtpUpdateWithoutUsersInput = {
    code?: StringFieldUpdateOperationsInput | string
    expiresat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OtpUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    expiresat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OtpUncheckedUpdateManyWithoutOtpInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    expiresat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportUpdateWithoutUsersInput = {
    reporttype?: StringFieldUpdateOperationsInput | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    generatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    reporttype?: StringFieldUpdateOperationsInput | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    generatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportUncheckedUpdateManyWithoutReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    reporttype?: StringFieldUpdateOperationsInput | string
    filters?: NullableJsonNullValueInput | InputJsonValue
    generatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RevocationRecordUpdateWithoutUsersInput = {
    type?: StringFieldUpdateOperationsInput | string
    refid?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RevocationRecordUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    refid?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RevocationRecordUncheckedUpdateManyWithoutRevocationrecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    refid?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupplyChainRecordUpdateWithoutUsers_supplychainrecord_fromentityidTousersInput = {
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    blockchaineventlog?: BlockchainEventLogUpdateManyWithoutSupplychainrecordNestedInput
    drugbatch?: DrugBatchUpdateOneWithoutSupplychainrecordNestedInput
    users_supplychainrecord_toentityidTousers?: UserUpdateOneWithoutSupplychainrecord_supplychainrecord_toentityidTousersNestedInput
  }

  export type SupplyChainRecordUncheckedUpdateWithoutUsers_supplychainrecord_fromentityidTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    drugbatchid?: NullableIntFieldUpdateOperationsInput | number | null
    toentityid?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    blockchaineventlog?: BlockchainEventLogUncheckedUpdateManyWithoutSupplychainrecordNestedInput
  }

  export type SupplyChainRecordUncheckedUpdateManyWithoutSupplychainrecord_supplychainrecord_fromentityidTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    drugbatchid?: NullableIntFieldUpdateOperationsInput | number | null
    toentityid?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupplyChainRecordUpdateWithoutUsers_supplychainrecord_toentityidTousersInput = {
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    blockchaineventlog?: BlockchainEventLogUpdateManyWithoutSupplychainrecordNestedInput
    drugbatch?: DrugBatchUpdateOneWithoutSupplychainrecordNestedInput
    users_supplychainrecord_fromentityidTousers?: UserUpdateOneWithoutSupplychainrecord_supplychainrecord_fromentityidTousersNestedInput
  }

  export type SupplyChainRecordUncheckedUpdateWithoutUsers_supplychainrecord_toentityidTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    drugbatchid?: NullableIntFieldUpdateOperationsInput | number | null
    fromentityid?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    blockchaineventlog?: BlockchainEventLogUncheckedUpdateManyWithoutSupplychainrecordNestedInput
  }

  export type SupplyChainRecordUncheckedUpdateManyWithoutSupplychainrecord_supplychainrecord_toentityidTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    drugbatchid?: NullableIntFieldUpdateOperationsInput | number | null
    fromentityid?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrescriptionCreateManyDoctorInput = {
    id?: number
    patientid?: number | null
    drugid?: number | null
    dosage: string
    issuedat?: Date | string | null
    expiresat: Date | string
    blockchaintx?: string | null
    qrcode: string
    ipfshash?: string | null
    status: string
  }

  export type PrescriptionUpdateWithoutDoctorInput = {
    dosage?: StringFieldUpdateOperationsInput | string
    issuedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresat?: DateTimeFieldUpdateOperationsInput | Date | string
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: StringFieldUpdateOperationsInput | string
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    blockchaineventlog?: BlockchainEventLogUpdateManyWithoutPrescriptionNestedInput
    dispenserecord?: DispenseRecordUpdateManyWithoutPrescriptionNestedInput
    drug?: DrugUpdateOneWithoutPrescriptionNestedInput
    patient?: PatientUpdateOneWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientid?: NullableIntFieldUpdateOperationsInput | number | null
    drugid?: NullableIntFieldUpdateOperationsInput | number | null
    dosage?: StringFieldUpdateOperationsInput | string
    issuedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresat?: DateTimeFieldUpdateOperationsInput | Date | string
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: StringFieldUpdateOperationsInput | string
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    blockchaineventlog?: BlockchainEventLogUncheckedUpdateManyWithoutPrescriptionNestedInput
    dispenserecord?: DispenseRecordUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateManyWithoutPrescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientid?: NullableIntFieldUpdateOperationsInput | number | null
    drugid?: NullableIntFieldUpdateOperationsInput | number | null
    dosage?: StringFieldUpdateOperationsInput | string
    issuedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresat?: DateTimeFieldUpdateOperationsInput | Date | string
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: StringFieldUpdateOperationsInput | string
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type PrescriptionCreateManyPatientInput = {
    id?: number
    doctorid?: number | null
    drugid?: number | null
    dosage: string
    issuedat?: Date | string | null
    expiresat: Date | string
    blockchaintx?: string | null
    qrcode: string
    ipfshash?: string | null
    status: string
  }

  export type PrescriptionUpdateWithoutPatientInput = {
    dosage?: StringFieldUpdateOperationsInput | string
    issuedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresat?: DateTimeFieldUpdateOperationsInput | Date | string
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: StringFieldUpdateOperationsInput | string
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    blockchaineventlog?: BlockchainEventLogUpdateManyWithoutPrescriptionNestedInput
    dispenserecord?: DispenseRecordUpdateManyWithoutPrescriptionNestedInput
    doctor?: DoctorUpdateOneWithoutPrescriptionNestedInput
    drug?: DrugUpdateOneWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorid?: NullableIntFieldUpdateOperationsInput | number | null
    drugid?: NullableIntFieldUpdateOperationsInput | number | null
    dosage?: StringFieldUpdateOperationsInput | string
    issuedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresat?: DateTimeFieldUpdateOperationsInput | Date | string
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: StringFieldUpdateOperationsInput | string
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    blockchaineventlog?: BlockchainEventLogUncheckedUpdateManyWithoutPrescriptionNestedInput
    dispenserecord?: DispenseRecordUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type DispenseRecordCreateManyPharmacistInput = {
    id?: number
    prescriptionid?: number | null
    drugbatchid?: number | null
    quantity: number
    dispensedat?: Date | string | null
    blockchaintx?: string | null
  }

  export type DispenseRecordUpdateWithoutPharmacistInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    dispensedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    drugbatch?: DrugBatchUpdateOneWithoutDispenserecordNestedInput
    prescription?: PrescriptionUpdateOneWithoutDispenserecordNestedInput
  }

  export type DispenseRecordUncheckedUpdateWithoutPharmacistInput = {
    id?: IntFieldUpdateOperationsInput | number
    prescriptionid?: NullableIntFieldUpdateOperationsInput | number | null
    drugbatchid?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    dispensedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DispenseRecordUncheckedUpdateManyWithoutDispenserecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    prescriptionid?: NullableIntFieldUpdateOperationsInput | number | null
    drugbatchid?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    dispensedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DrugBatchCreateManyManufacturerInput = {
    id?: number
    drugid?: number | null
    batchnumber: string
    manufacturedate: Date | string
    expirydate: Date | string
    blockchaintx?: string | null
    qrcode: string
    ipfshash?: string | null
  }

  export type DrugBatchUpdateWithoutManufacturerInput = {
    batchnumber?: StringFieldUpdateOperationsInput | string
    manufacturedate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirydate?: DateTimeFieldUpdateOperationsInput | Date | string
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: StringFieldUpdateOperationsInput | string
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
    blockchaineventlog?: BlockchainEventLogUpdateManyWithoutDrugbatchNestedInput
    dispenserecord?: DispenseRecordUpdateManyWithoutDrugbatchNestedInput
    drug?: DrugUpdateOneWithoutDrugbatchNestedInput
    supplychainrecord?: SupplyChainRecordUpdateManyWithoutDrugbatchNestedInput
  }

  export type DrugBatchUncheckedUpdateWithoutManufacturerInput = {
    id?: IntFieldUpdateOperationsInput | number
    drugid?: NullableIntFieldUpdateOperationsInput | number | null
    batchnumber?: StringFieldUpdateOperationsInput | string
    manufacturedate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirydate?: DateTimeFieldUpdateOperationsInput | Date | string
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: StringFieldUpdateOperationsInput | string
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
    blockchaineventlog?: BlockchainEventLogUncheckedUpdateManyWithoutDrugbatchNestedInput
    dispenserecord?: DispenseRecordUncheckedUpdateManyWithoutDrugbatchNestedInput
    supplychainrecord?: SupplyChainRecordUncheckedUpdateManyWithoutDrugbatchNestedInput
  }

  export type DrugBatchUncheckedUpdateManyWithoutDrugbatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    drugid?: NullableIntFieldUpdateOperationsInput | number | null
    batchnumber?: StringFieldUpdateOperationsInput | string
    manufacturedate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirydate?: DateTimeFieldUpdateOperationsInput | Date | string
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: StringFieldUpdateOperationsInput | string
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DrugBatchCreateManyDrugInput = {
    id?: number
    manufacturerid?: number | null
    batchnumber: string
    manufacturedate: Date | string
    expirydate: Date | string
    blockchaintx?: string | null
    qrcode: string
    ipfshash?: string | null
  }

  export type PrescriptionCreateManyDrugInput = {
    id?: number
    patientid?: number | null
    doctorid?: number | null
    dosage: string
    issuedat?: Date | string | null
    expiresat: Date | string
    blockchaintx?: string | null
    qrcode: string
    ipfshash?: string | null
    status: string
  }

  export type DrugBatchUpdateWithoutDrugInput = {
    batchnumber?: StringFieldUpdateOperationsInput | string
    manufacturedate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirydate?: DateTimeFieldUpdateOperationsInput | Date | string
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: StringFieldUpdateOperationsInput | string
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
    blockchaineventlog?: BlockchainEventLogUpdateManyWithoutDrugbatchNestedInput
    dispenserecord?: DispenseRecordUpdateManyWithoutDrugbatchNestedInput
    manufacturer?: ManufacturerUpdateOneWithoutDrugbatchNestedInput
    supplychainrecord?: SupplyChainRecordUpdateManyWithoutDrugbatchNestedInput
  }

  export type DrugBatchUncheckedUpdateWithoutDrugInput = {
    id?: IntFieldUpdateOperationsInput | number
    manufacturerid?: NullableIntFieldUpdateOperationsInput | number | null
    batchnumber?: StringFieldUpdateOperationsInput | string
    manufacturedate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirydate?: DateTimeFieldUpdateOperationsInput | Date | string
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: StringFieldUpdateOperationsInput | string
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
    blockchaineventlog?: BlockchainEventLogUncheckedUpdateManyWithoutDrugbatchNestedInput
    dispenserecord?: DispenseRecordUncheckedUpdateManyWithoutDrugbatchNestedInput
    supplychainrecord?: SupplyChainRecordUncheckedUpdateManyWithoutDrugbatchNestedInput
  }

  export type PrescriptionUpdateWithoutDrugInput = {
    dosage?: StringFieldUpdateOperationsInput | string
    issuedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresat?: DateTimeFieldUpdateOperationsInput | Date | string
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: StringFieldUpdateOperationsInput | string
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    blockchaineventlog?: BlockchainEventLogUpdateManyWithoutPrescriptionNestedInput
    dispenserecord?: DispenseRecordUpdateManyWithoutPrescriptionNestedInput
    doctor?: DoctorUpdateOneWithoutPrescriptionNestedInput
    patient?: PatientUpdateOneWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutDrugInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientid?: NullableIntFieldUpdateOperationsInput | number | null
    doctorid?: NullableIntFieldUpdateOperationsInput | number | null
    dosage?: StringFieldUpdateOperationsInput | string
    issuedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresat?: DateTimeFieldUpdateOperationsInput | Date | string
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    qrcode?: StringFieldUpdateOperationsInput | string
    ipfshash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    blockchaineventlog?: BlockchainEventLogUncheckedUpdateManyWithoutPrescriptionNestedInput
    dispenserecord?: DispenseRecordUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type BlockchainEventLogCreateManyPrescriptionInput = {
    id?: number
    eventname: string
    contractname: string
    entitytype?: string | null
    transactionhash: string
    timestamp?: Date | string | null
    processed?: boolean | null
  }

  export type DispenseRecordCreateManyPrescriptionInput = {
    id?: number
    pharmacistid?: number | null
    drugbatchid?: number | null
    quantity: number
    dispensedat?: Date | string | null
    blockchaintx?: string | null
  }

  export type BlockchainEventLogUpdateWithoutPrescriptionInput = {
    eventname?: StringFieldUpdateOperationsInput | string
    contractname?: StringFieldUpdateOperationsInput | string
    entitytype?: NullableStringFieldUpdateOperationsInput | string | null
    transactionhash?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    drugbatch?: DrugBatchUpdateOneWithoutBlockchaineventlogNestedInput
    supplychainrecord?: SupplyChainRecordUpdateOneWithoutBlockchaineventlogNestedInput
  }

  export type BlockchainEventLogUncheckedUpdateWithoutPrescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventname?: StringFieldUpdateOperationsInput | string
    contractname?: StringFieldUpdateOperationsInput | string
    entitytype?: NullableStringFieldUpdateOperationsInput | string | null
    transactionhash?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processed?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type BlockchainEventLogUncheckedUpdateManyWithoutBlockchaineventlogInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventname?: StringFieldUpdateOperationsInput | string
    contractname?: StringFieldUpdateOperationsInput | string
    entitytype?: NullableStringFieldUpdateOperationsInput | string | null
    transactionhash?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processed?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DispenseRecordUpdateWithoutPrescriptionInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    dispensedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    drugbatch?: DrugBatchUpdateOneWithoutDispenserecordNestedInput
    pharmacist?: PharmacistUpdateOneWithoutDispenserecordNestedInput
  }

  export type DispenseRecordUncheckedUpdateWithoutPrescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    pharmacistid?: NullableIntFieldUpdateOperationsInput | number | null
    drugbatchid?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    dispensedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BlockchainEventLogCreateManyDrugbatchInput = {
    id?: number
    eventname: string
    contractname: string
    entitytype?: string | null
    transactionhash: string
    timestamp?: Date | string | null
    processed?: boolean | null
  }

  export type DispenseRecordCreateManyDrugbatchInput = {
    id?: number
    prescriptionid?: number | null
    pharmacistid?: number | null
    quantity: number
    dispensedat?: Date | string | null
    blockchaintx?: string | null
  }

  export type SupplyChainRecordCreateManyDrugbatchInput = {
    id?: number
    fromentityid?: number | null
    toentityid?: number | null
    action: string
    timestamp?: Date | string | null
    blockchaintx?: string | null
  }

  export type BlockchainEventLogUpdateWithoutDrugbatchInput = {
    eventname?: StringFieldUpdateOperationsInput | string
    contractname?: StringFieldUpdateOperationsInput | string
    entitytype?: NullableStringFieldUpdateOperationsInput | string | null
    transactionhash?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    prescription?: PrescriptionUpdateOneWithoutBlockchaineventlogNestedInput
    supplychainrecord?: SupplyChainRecordUpdateOneWithoutBlockchaineventlogNestedInput
  }

  export type BlockchainEventLogUncheckedUpdateWithoutDrugbatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventname?: StringFieldUpdateOperationsInput | string
    contractname?: StringFieldUpdateOperationsInput | string
    entitytype?: NullableStringFieldUpdateOperationsInput | string | null
    transactionhash?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processed?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DispenseRecordUpdateWithoutDrugbatchInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    dispensedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    pharmacist?: PharmacistUpdateOneWithoutDispenserecordNestedInput
    prescription?: PrescriptionUpdateOneWithoutDispenserecordNestedInput
  }

  export type DispenseRecordUncheckedUpdateWithoutDrugbatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    prescriptionid?: NullableIntFieldUpdateOperationsInput | number | null
    pharmacistid?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    dispensedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupplyChainRecordUpdateWithoutDrugbatchInput = {
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    blockchaineventlog?: BlockchainEventLogUpdateManyWithoutSupplychainrecordNestedInput
    users_supplychainrecord_fromentityidTousers?: UserUpdateOneWithoutSupplychainrecord_supplychainrecord_fromentityidTousersNestedInput
    users_supplychainrecord_toentityidTousers?: UserUpdateOneWithoutSupplychainrecord_supplychainrecord_toentityidTousersNestedInput
  }

  export type SupplyChainRecordUncheckedUpdateWithoutDrugbatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromentityid?: NullableIntFieldUpdateOperationsInput | number | null
    toentityid?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
    blockchaineventlog?: BlockchainEventLogUncheckedUpdateManyWithoutSupplychainrecordNestedInput
  }

  export type SupplyChainRecordUncheckedUpdateManyWithoutSupplychainrecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromentityid?: NullableIntFieldUpdateOperationsInput | number | null
    toentityid?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockchaintx?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BlockchainEventLogCreateManySupplychainrecordInput = {
    id?: number
    eventname: string
    contractname: string
    entitytype?: string | null
    transactionhash: string
    timestamp?: Date | string | null
    processed?: boolean | null
  }

  export type BlockchainEventLogUpdateWithoutSupplychainrecordInput = {
    eventname?: StringFieldUpdateOperationsInput | string
    contractname?: StringFieldUpdateOperationsInput | string
    entitytype?: NullableStringFieldUpdateOperationsInput | string | null
    transactionhash?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    drugbatch?: DrugBatchUpdateOneWithoutBlockchaineventlogNestedInput
    prescription?: PrescriptionUpdateOneWithoutBlockchaineventlogNestedInput
  }

  export type BlockchainEventLogUncheckedUpdateWithoutSupplychainrecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventname?: StringFieldUpdateOperationsInput | string
    contractname?: StringFieldUpdateOperationsInput | string
    entitytype?: NullableStringFieldUpdateOperationsInput | string | null
    transactionhash?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processed?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}